/* automatically generated by rust-bindgen 0.55.1 */

pub const BYTEDEF: u32 = 1;
pub const MICRODEF: u32 = 1;
pub const MISSING_DATA: i32 = -32768;
pub const MISSING: i32 = -32768;
pub const INaN: i32 = -32768;
pub const LEFT_EYE: u32 = 0;
pub const RIGHT_EYE: u32 = 1;
pub const LEFTEYEI: u32 = 0;
pub const RIGHTEYEI: u32 = 1;
pub const LEFT: u32 = 0;
pub const RIGHT: u32 = 1;
pub const BINOCULAR: u32 = 2;
pub const SAMPLE_LEFT: u32 = 32768;
pub const SAMPLE_RIGHT: u32 = 16384;
pub const SAMPLE_TIMESTAMP: u32 = 8192;
pub const SAMPLE_PUPILXY: u32 = 4096;
pub const SAMPLE_HREFXY: u32 = 2048;
pub const SAMPLE_GAZEXY: u32 = 1024;
pub const SAMPLE_GAZERES: u32 = 512;
pub const SAMPLE_PUPILSIZE: u32 = 256;
pub const SAMPLE_STATUS: u32 = 128;
pub const SAMPLE_INPUTS: u32 = 64;
pub const SAMPLE_BUTTONS: u32 = 32;
pub const SAMPLE_HEADPOS: u32 = 16;
pub const SAMPLE_TAGGED: u32 = 8;
pub const SAMPLE_UTAGGED: u32 = 4;
pub const SAMPLE_ADD_OFFSET: u32 = 2;
pub const FSAMPLEDEF: u32 = 1;
pub const DSAMPLEDEF: u32 = 1;
pub const FSAMPLERAWDEF: u32 = 1;
pub const FEVENTDEF: u32 = 1;
pub const DEVENTDEF: u32 = 1;
pub const SAMPLE_TYPE: u32 = 200;
pub const STARTPARSE: u32 = 1;
pub const ENDPARSE: u32 = 2;
pub const BREAKPARSE: u32 = 10;
pub const STARTBLINK: u32 = 3;
pub const ENDBLINK: u32 = 4;
pub const STARTSACC: u32 = 5;
pub const ENDSACC: u32 = 6;
pub const STARTFIX: u32 = 7;
pub const ENDFIX: u32 = 8;
pub const FIXUPDATE: u32 = 9;
pub const STARTSAMPLES: u32 = 15;
pub const ENDSAMPLES: u32 = 16;
pub const STARTEVENTS: u32 = 17;
pub const ENDEVENTS: u32 = 18;
pub const MESSAGEEVENT: u32 = 24;
pub const BUTTONEVENT: u32 = 25;
pub const INPUTEVENT: u32 = 28;
pub const LOST_DATA_EVENT: u32 = 63;
pub const ISAMPLE_BUFFER: u32 = 200;
pub const IEVENT_BUFFER: u32 = 66;
pub const IOEVENT_BUFFER: u32 = 8;
pub const IMESSAGE_BUFFER: u32 = 250;
pub const CONTROL_BUFFER: u32 = 36;
pub const ILINKDATA_BUFFER: u32 = 36;
pub const READ_ENDTIME: u32 = 64;
pub const READ_GRES: u32 = 512;
pub const READ_SIZE: u32 = 128;
pub const READ_VEL: u32 = 256;
pub const READ_STATUS: u32 = 8192;
pub const READ_BEG: u32 = 1;
pub const READ_END: u32 = 2;
pub const READ_AVG: u32 = 4;
pub const READ_PUPILXY: u32 = 1024;
pub const READ_HREFXY: u32 = 2048;
pub const READ_GAZEXY: u32 = 4096;
pub const READ_BEGPOS: u32 = 8;
pub const READ_ENDPOS: u32 = 16;
pub const READ_AVGPOS: u32 = 32;
pub const FRIGHTEYE_EVENTS: u32 = 32768;
pub const FLEFTEYE_EVENTS: u32 = 16384;
pub const LEFTEYE_EVENTS: u32 = 32768;
pub const RIGHTEYE_EVENTS: u32 = 16384;
pub const BLINK_EVENTS: u32 = 8192;
pub const FIXATION_EVENTS: u32 = 4096;
pub const FIXUPDATE_EVENTS: u32 = 2048;
pub const SACCADE_EVENTS: u32 = 1024;
pub const MESSAGE_EVENTS: u32 = 512;
pub const BUTTON_EVENTS: u32 = 64;
pub const INPUT_EVENTS: u32 = 32;
pub const EVENT_VELOCITY: u32 = 32768;
pub const EVENT_PUPILSIZE: u32 = 16384;
pub const EVENT_GAZERES: u32 = 8192;
pub const EVENT_STATUS: u32 = 4096;
pub const EVENT_GAZEXY: u32 = 1024;
pub const EVENT_HREFXY: u32 = 512;
pub const EVENT_PUPILXY: u32 = 256;
pub const FIX_AVG_ONLY: u32 = 8;
pub const START_TIME_ONLY: u32 = 4;
pub const PARSEDBY_GAZE: u32 = 192;
pub const PARSEDBY_HREF: u32 = 128;
pub const PARSEDBY_PUPIL: u32 = 64;
pub const ILINKDATAVERSION: u32 = 2;
pub const ELNAMESIZE: u32 = 40;
pub const ELREMBUFSIZE: u32 = 420;
pub const ELINKADDRSIZE: u32 = 16;
pub const PUPIL_DIA_FLAG: u32 = 1;
pub const HAVE_SAMPLES_FLAG: u32 = 2;
pub const HAVE_EVENTS_FLAG: u32 = 4;
pub const HAVE_LEFT_FLAG: u32 = 32768;
pub const HAVE_RIGHT_FLAG: u32 = 16384;
pub const DROPPED_SAMPLE: u32 = 32768;
pub const DROPPED_EVENT: u32 = 16384;
pub const DROPPED_CONTROL: u32 = 8192;
pub const DFILE_IS_OPEN: u32 = 128;
pub const DFILE_EVENTS_ON: u32 = 64;
pub const DFILE_SAMPLES_ON: u32 = 32;
pub const DLINK_EVENTS_ON: u32 = 8;
pub const DLINK_SAMPLES_ON: u32 = 4;
pub const DRECORD_ACTIVE: u32 = 1;
pub const COMMAND_FULL_WARN: u32 = 1;
pub const MESSAGE_FULL_WARN: u32 = 2;
pub const LINK_FULL_WARN: u32 = 4;
pub const FULL_WARN: u32 = 15;
pub const LINK_CONNECTED: u32 = 16;
pub const LINK_BROADCAST: u32 = 32;
pub const LINK_IS_TCPIP: u32 = 64;
pub const LED_TOP_WARNING: u32 = 128;
pub const LED_BOT_WARNING: u32 = 64;
pub const LED_LEFT_WARNING: u32 = 32;
pub const LED_RIGHT_WARNING: u32 = 16;
pub const HEAD_POSITION_WARNING: u32 = 240;
pub const LED_EXTRA_WARNING: u32 = 8;
pub const LED_MISSING_WARNING: u32 = 4;
pub const HEAD_VELOCITY_WARNING: u32 = 1;
pub const CALIBRATION_AREA_WARNING: u32 = 2;
pub const MATH_ERROR_WARNING: u32 = 8192;
pub const INTERP_SAMPLE_WARNING: u32 = 4096;
pub const INTERP_PUPIL_WARNING: u32 = 32768;
pub const CR_WARNING: u32 = 3840;
pub const CR_LEFT_WARNING: u32 = 1280;
pub const CR_RIGHT_WARNING: u32 = 2560;
pub const CR_LOST_WARNING: u32 = 768;
pub const CR_LOST_LEFT_WARNING: u32 = 256;
pub const CR_LOST_RIGHT_WARNING: u32 = 512;
pub const CR_RECOV_WARNING: u32 = 3072;
pub const CR_RECOV_LEFT_WARNING: u32 = 1024;
pub const CR_RECOV_RIGHT_WARNING: u32 = 2048;
pub const HPOS_TOP_WARNING: u32 = 128;
pub const HPOS_BOT_WARNING: u32 = 64;
pub const HPOS_LEFT_WARNING: u32 = 32;
pub const HPOS_RIGHT_WARNING: u32 = 16;
pub const HPOS_WARNING: u32 = 240;
pub const HPOS_ANGLE_WARNING: u32 = 8;
pub const HPOS_MISSING_WARNING: u32 = 4;
pub const HPOS_DISTANCE_WARNING: u32 = 1;
pub const TFLAG_MISSING: u32 = 16384;
pub const TFLAG_ANGLE: u32 = 8192;
pub const TFLAG_NEAREYE: u32 = 4096;
pub const TFLAG_CLOSE: u32 = 2048;
pub const TFLAG_FAR: u32 = 1024;
pub const TFLAG_T_TSIDE: u32 = 128;
pub const TFLAG_T_BSIDE: u32 = 64;
pub const TFLAG_T_LSIDE: u32 = 32;
pub const TFLAG_T_RSIDE: u32 = 16;
pub const TFLAG_E_TSIDE: u32 = 8;
pub const TFLAG_E_BSIDE: u32 = 4;
pub const TFLAG_E_LSIDE: u32 = 2;
pub const TFLAG_E_RSIDE: u32 = 1;
pub const OK_RESULT: u32 = 0;
pub const NO_REPLY: u32 = 1000;
pub const LINK_TERMINATED_RESULT: i32 = -100;
pub const ABORT_RESULT: u32 = 27;
pub const UNEXPECTED_EOL_RESULT: i32 = -1;
pub const SYNTAX_ERROR_RESULT: i32 = -2;
pub const BAD_VALUE_RESULT: i32 = -3;
pub const EXTRA_CHARACTERS_RESULT: i32 = -4;
pub const LINK_SEND_MAX: u32 = 244;
pub const LINK_INITIALIZE_FAILED: i32 = -200;
pub const CONNECT_TIMEOUT_FAILED: i32 = -201;
pub const WRONG_LINK_VERSION: i32 = -202;
pub const TRACKER_BUSY: i32 = -203;
pub const IN_DISCONNECT_MODE: u32 = 16384;
pub const IN_UNKNOWN_MODE: u32 = 0;
pub const IN_IDLE_MODE: u32 = 1;
pub const IN_SETUP_MODE: u32 = 2;
pub const IN_RECORD_MODE: u32 = 4;
pub const IN_TARGET_MODE: u32 = 8;
pub const IN_DRIFTCORR_MODE: u32 = 16;
pub const IN_IMAGE_MODE: u32 = 32;
pub const IN_USER_MENU: u32 = 64;
pub const IN_PLAYBACK_MODE: u32 = 256;
pub const EL_IDLE_MODE: u32 = 1;
pub const EL_IMAGE_MODE: u32 = 2;
pub const EL_SETUP_MENU_MODE: u32 = 3;
pub const EL_USER_MENU_1: u32 = 5;
pub const EL_USER_MENU_2: u32 = 6;
pub const EL_USER_MENU_3: u32 = 7;
pub const EL_OPTIONS_MENU_MODE: u32 = 8;
pub const EL_OUTPUT_MENU_MODE: u32 = 9;
pub const EL_DEMO_MENU_MODE: u32 = 10;
pub const EL_CALIBRATE_MODE: u32 = 11;
pub const EL_VALIDATE_MODE: u32 = 12;
pub const EL_DRIFT_CORR_MODE: u32 = 13;
pub const EL_RECORD_MODE: u32 = 14;
pub const SCENECAM_ALIGN_MODE: u32 = 15;
pub const SCENECAM_DEPTH_MODE: u32 = 16;
pub const RECORD_FILE_SAMPLES: u32 = 1;
pub const RECORD_FILE_EVENTS: u32 = 2;
pub const RECORD_LINK_SAMPLES: u32 = 4;
pub const RECORD_LINK_EVENTS: u32 = 8;
pub const ELIMAGE_2: u32 = 0;
pub const ELIMAGE_16: u32 = 1;
pub const ELIMAGE_16P: u32 = 2;
pub const ELIMAGE_256: u32 = 3;
pub const ELIMAGE_128HV: u32 = 4;
pub const ELIMAGE_128HVX: u32 = 5;
pub const KB_PRESS: u32 = 10;
pub const KB_RELEASE: i32 = -1;
pub const KB_REPEAT: u32 = 1;
pub const NUM_LOCK_ON: u32 = 32;
pub const CAPS_LOCK_ON: u32 = 64;
pub const ALT_KEY_DOWN: u32 = 8;
pub const CTRL_KEY_DOWN: u32 = 4;
pub const SHIFT_KEY_DOWN: u32 = 3;
pub const KB_BUTTON: u32 = 65280;
pub const F1_KEY: u32 = 15104;
pub const F2_KEY: u32 = 15360;
pub const F3_KEY: u32 = 15616;
pub const F4_KEY: u32 = 15872;
pub const F5_KEY: u32 = 16128;
pub const F6_KEY: u32 = 16384;
pub const F7_KEY: u32 = 16640;
pub const F8_KEY: u32 = 16896;
pub const F9_KEY: u32 = 17152;
pub const F10_KEY: u32 = 17408;
pub const PAGE_UP: u32 = 18688;
pub const PAGE_DOWN: u32 = 20736;
pub const CURS_UP: u32 = 18432;
pub const CURS_DOWN: u32 = 20480;
pub const CURS_LEFT: u32 = 19200;
pub const CURS_RIGHT: u32 = 19712;
pub const ESC_KEY: u32 = 27;
pub const ENTER_KEY: u32 = 13;
pub const FILE_XFER_ABORTED: i32 = -110;
pub const FILE_CANT_OPEN: i32 = -111;
pub const FILE_NO_REPLY: i32 = -112;
pub const FILE_BAD_DATA: i32 = -113;
pub const FILEDATA_SIZE_FLAG: u32 = 999;
pub const FILE_BLOCK_SIZE: u32 = 512;
pub const ABORT_BX: i32 = -32000;
pub const PAUSE_BX: i32 = -32001;
pub const DONE_BX: i32 = -32002;
pub const JUNK_KEY: u32 = 1;
pub const TERMINATE_KEY: u32 = 32767;
pub const DONE_TRIAL: u32 = 0;
pub const TRIAL_OK: u32 = 0;
pub const REPEAT_TRIAL: u32 = 1;
pub const SKIP_TRIAL: u32 = 2;
pub const ABORT_EXPT: u32 = 3;
pub const TRIAL_ERROR: i32 = -1;
pub const BX_AVERAGE: u32 = 0;
pub const BX_DARKEN: u32 = 1;
pub const BX_LIGHTEN: u32 = 2;
pub const BX_MAXCONTRAST: u32 = 4;
pub const BX_NODITHER: u32 = 8;
pub const BX_GRAYSCALE: u32 = 16;
pub const BX_TXFILE: u32 = 32;
pub const BX_DOTRANSFER: u32 = 256;
pub const SV_NOREPLACE: u32 = 1;
pub const SV_MAKEPATH: u32 = 2;
pub const BAD_FILENAME: i32 = -2222;
pub const BAD_ARGUMENT: i32 = -2223;
pub const KEYINPUT_EVENT: u32 = 1;
pub const MOUSE_INPUT_EVENT: u32 = 4;
pub const MOUSE_MOTION_INPUT_EVENT: u32 = 5;
pub const MOUSE_BUTTON_INPUT_EVENT: u32 = 6;
pub const ELKMOD_NONE: u32 = 0;
pub const ELKMOD_LSHIFT: u32 = 1;
pub const ELKMOD_RSHIFT: u32 = 2;
pub const ELKMOD_LCTRL: u32 = 64;
pub const ELKMOD_RCTRL: u32 = 128;
pub const ELKMOD_LALT: u32 = 256;
pub const ELKMOD_RALT: u32 = 512;
pub const ELKMOD_LMETA: u32 = 1024;
pub const ELKMOD_RMETA: u32 = 2048;
pub const ELKMOD_NUM: u32 = 4096;
pub const ELKMOD_CAPS: u32 = 8192;
pub const ELKMOD_MODE: u32 = 16384;
pub const ELKEY_DOWN: u32 = 1;
pub const ELKEY_UP: u32 = 0;
pub const FIVE_SAMPLE_MODEL: u32 = 1;
pub const NINE_SAMPLE_MODEL: u32 = 2;
pub const SEVENTEEN_SAMPLE_MODEL: u32 = 3;
pub const EL1000_TRACKER_MODEL: u32 = 4;
pub const CR_HAIR_COLOR: u32 = 1;
pub const PUPIL_HAIR_COLOR: u32 = 2;
pub const PUPIL_BOX_COLOR: u32 = 3;
pub const SEARCH_LIMIT_BOX_COLOR: u32 = 4;
pub const MOUSE_CURSOR_COLOR: u32 = 5;
pub type byte = ::std::os::raw::c_uchar;
pub type INT16 = ::std::os::raw::c_short;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type INT32 = ::std::os::raw::c_int;
pub type UINT32 = ::std::os::raw::c_uint;
#[doc = " @ingroup access_time_local"]
#[doc = "Structure to hold msec and usec."]
#[doc = "\\sa current_micro"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MICRO {
    pub msec: INT32,
    pub usec: INT16,
}
#[test]
fn bindgen_test_layout_MICRO() {
    assert_eq!(
        ::std::mem::size_of::<MICRO>(),
        8usize,
        concat!("Size of: ", stringify!(MICRO))
    );
    assert_eq!(
        ::std::mem::align_of::<MICRO>(),
        4usize,
        concat!("Alignment of ", stringify!(MICRO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MICRO>())).msec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MICRO),
            "::",
            stringify!(msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MICRO>())).usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MICRO),
            "::",
            stringify!(usec)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Integer sample data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ISAMPLE {
    #[doc = "< time of sample"]
    pub time: UINT32,
    #[doc = "< always SAMPLE_TYPE"]
    pub type_: INT16,
    #[doc = "< flags to indicate contents"]
    pub flags: UINT16,
    #[doc = "< pupil x"]
    pub px: [INT16; 2usize],
    #[doc = "< pupil y"]
    pub py: [INT16; 2usize],
    #[doc = "< headref x"]
    pub hx: [INT16; 2usize],
    #[doc = "< headref y"]
    pub hy: [INT16; 2usize],
    #[doc = "< pupil size or area"]
    pub pa: [UINT16; 2usize],
    #[doc = "< screen gaze x"]
    pub gx: [INT16; 2usize],
    #[doc = "< screen gaze y"]
    pub gy: [INT16; 2usize],
    #[doc = "< screen pixels per degree"]
    pub rx: INT16,
    #[doc = "< screen pixels per degree"]
    pub ry: INT16,
    #[doc = "< tracker status flags"]
    pub status: UINT16,
    #[doc = "< extra (input word)"]
    pub input: UINT16,
    #[doc = "< button state & changes"]
    pub buttons: UINT16,
    #[doc = "< head-tracker data type (0=none)"]
    pub htype: INT16,
    #[doc = "< head-tracker data"]
    pub hdata: [INT16; 8usize],
}
#[test]
fn bindgen_test_layout_ISAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<ISAMPLE>(),
        64usize,
        concat!("Size of: ", stringify!(ISAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<ISAMPLE>(),
        4usize,
        concat!("Alignment of ", stringify!(ISAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).px as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).py as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).hx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(hx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).hy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(hy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).pa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).gx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).gy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).rx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).ry as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).input as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).buttons as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).htype as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).hdata as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Floating-point sample"]
#[doc = ""]
#[doc = "The EyeLink tracker measures eye position 250, 500, 1000 or 2000 times per second depending on"]
#[doc = "the tracking mode you are working with, and computes true gaze position on the display"]
#[doc = "using the head camera data. This data is stored in the EDF file, and made available"]
#[doc = "through the link in as little as 3 milliseconds after a physical eye movement."]
#[doc = "Samples can be read from the link by eyelink_get_float_data() or eyelink_newest_float_sample()."]
#[doc = ""]
#[doc = "If sample rate is 2000hz, two samples with same time stamp possible. If SAMPLE_ADD_OFFSET is set on the"]
#[doc = "flags, add .5 ms to get the real time. Convenient FLOAT_TIME can also be used."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAMPLE {
    #[doc = "< time of sample"]
    pub time: UINT32,
    #[doc = "< always SAMPLE_TYPE"]
    pub type_: INT16,
    #[doc = "< flags to indicate contents"]
    pub flags: UINT16,
    #[doc = "< pupil x"]
    pub px: [f32; 2usize],
    #[doc = "< pupil y"]
    pub py: [f32; 2usize],
    #[doc = "< headref x"]
    pub hx: [f32; 2usize],
    #[doc = "< headref y"]
    pub hy: [f32; 2usize],
    #[doc = "< pupil size or area"]
    pub pa: [f32; 2usize],
    #[doc = "< screen gaze x"]
    pub gx: [f32; 2usize],
    #[doc = "< screen gaze y"]
    pub gy: [f32; 2usize],
    #[doc = "< screen pixels per degree"]
    pub rx: f32,
    #[doc = "< screen pixels per degree"]
    pub ry: f32,
    #[doc = "< tracker status flags"]
    pub status: UINT16,
    #[doc = "< extra (input word)"]
    pub input: UINT16,
    #[doc = "< button state & changes"]
    pub buttons: UINT16,
    #[doc = "< head-tracker data type (0=none)"]
    pub htype: INT16,
    #[doc = "< head-tracker data (not prescaled)"]
    pub hdata: [INT16; 8usize],
}
#[test]
fn bindgen_test_layout_FSAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<FSAMPLE>(),
        96usize,
        concat!("Size of: ", stringify!(FSAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<FSAMPLE>(),
        4usize,
        concat!("Alignment of ", stringify!(FSAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).px as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).py as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).hx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(hx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).hy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(hy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).pa as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).gx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).gy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).rx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).ry as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).status as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).input as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).buttons as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).htype as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).hdata as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Floating-point sample with floating point time"]
#[doc = ""]
#[doc = "The EyeLink tracker measures eye position 250, 500, 1000 or 2000 times per second depending on"]
#[doc = "the tracking mode you are working with, and computes true gaze position on the display"]
#[doc = "using the head camera data. This data is stored in the EDF file, and made available"]
#[doc = "through the link in as little as 3 milliseconds after a physical eye movement."]
#[doc = "Samples can be read from the link by eyelink_get_double_data() or eyelink_newest_double_sample()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DSAMPLE {
    #[doc = "< time of sample"]
    pub time: f64,
    #[doc = "< always SAMPLE_TYPE"]
    pub type_: INT16,
    #[doc = "< flags to indicate contents"]
    pub flags: UINT16,
    #[doc = "< pupil x"]
    pub px: [f32; 2usize],
    #[doc = "< pupil y"]
    pub py: [f32; 2usize],
    #[doc = "< headref x"]
    pub hx: [f32; 2usize],
    #[doc = "< headref y"]
    pub hy: [f32; 2usize],
    #[doc = "< pupil size or area"]
    pub pa: [f32; 2usize],
    #[doc = "< screen gaze x"]
    pub gx: [f32; 2usize],
    #[doc = "< screen gaze y"]
    pub gy: [f32; 2usize],
    #[doc = "< screen pixels per degree"]
    pub rx: f32,
    #[doc = "< screen pixels per degree"]
    pub ry: f32,
    #[doc = "< tracker status flags"]
    pub status: UINT16,
    #[doc = "< extra (input word)"]
    pub input: UINT16,
    #[doc = "< button state & changes"]
    pub buttons: UINT16,
    #[doc = "< head-tracker data type (0=none)"]
    pub htype: INT16,
    #[doc = "< head-tracker data (not prescaled)"]
    pub hdata: [INT16; 8usize],
}
#[test]
fn bindgen_test_layout_DSAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<DSAMPLE>(),
        104usize,
        concat!("Size of: ", stringify!(DSAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<DSAMPLE>(),
        8usize,
        concat!("Alignment of ", stringify!(DSAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).px as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).py as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).hx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(hx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).hy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(hy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).pa as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).gx as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).gy as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).rx as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).ry as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).status as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).input as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).buttons as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).htype as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).hdata as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = "@internal"]
#[doc = "Used to access raw online data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAMPLE_RAW {
    pub struct_size: UINT32,
    pub raw_pupil: [f32; 2usize],
    pub raw_cr: [f32; 2usize],
    pub pupil_area: UINT32,
    pub cr_area: UINT32,
    pub pupil_dimension: [UINT32; 2usize],
    pub cr_dimension: [UINT32; 2usize],
    pub window_position: [UINT32; 2usize],
    pub pupil_cr: [f32; 2usize],
    pub cr_area2: UINT32,
    pub raw_cr2: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_FSAMPLE_RAW() {
    assert_eq!(
        ::std::mem::size_of::<FSAMPLE_RAW>(),
        72usize,
        concat!("Size of: ", stringify!(FSAMPLE_RAW))
    );
    assert_eq!(
        ::std::mem::align_of::<FSAMPLE_RAW>(),
        4usize,
        concat!("Alignment of ", stringify!(FSAMPLE_RAW))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).struct_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).raw_pupil as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(raw_pupil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).raw_cr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(raw_cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).pupil_area as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(pupil_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).cr_area as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(cr_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).pupil_dimension as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(pupil_dimension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).cr_dimension as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(cr_dimension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).window_position as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(window_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).pupil_cr as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(pupil_cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).cr_area2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(cr_area2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).raw_cr2 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(raw_cr2)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Integer eye-movement events"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IEVENT {
    #[doc = "< effective time of event"]
    pub time: UINT32,
    #[doc = "< event type"]
    pub type_: INT16,
    #[doc = "< flags which items were included"]
    pub read: UINT16,
    #[doc = "< eye: 0=left,1=right"]
    pub eye: INT16,
    #[doc = "< start times"]
    pub sttime: UINT32,
    #[doc = "< end times"]
    pub entime: UINT32,
    #[doc = "< starting point x"]
    pub hstx: INT16,
    #[doc = "< starting point y"]
    pub hsty: INT16,
    #[doc = "< starting point x"]
    pub gstx: INT16,
    #[doc = "< starting point y"]
    pub gsty: INT16,
    pub sta: UINT16,
    #[doc = "< ending point x"]
    pub henx: INT16,
    #[doc = "< ending point y"]
    pub heny: INT16,
    #[doc = "< ending point x"]
    pub genx: INT16,
    #[doc = "< ending point y"]
    pub geny: INT16,
    pub ena: UINT16,
    #[doc = "< average x"]
    pub havx: INT16,
    #[doc = "< average y"]
    pub havy: INT16,
    #[doc = "< average x"]
    pub gavx: INT16,
    #[doc = "< average y"]
    pub gavy: INT16,
    #[doc = "< also used as accumulator"]
    pub ava: UINT16,
    #[doc = "< avg velocity accum"]
    pub avel: INT16,
    #[doc = "< peak velocity accum"]
    pub pvel: INT16,
    #[doc = "< start velocity"]
    pub svel: INT16,
    #[doc = "< end velocity"]
    pub evel: INT16,
    #[doc = "< start units-per-degree x"]
    pub supd_x: INT16,
    #[doc = "< end units-per-degree y"]
    pub eupd_x: INT16,
    #[doc = "< start units-per-degree y"]
    pub supd_y: INT16,
    #[doc = "< end units-per-degree y"]
    pub eupd_y: INT16,
    #[doc = "< error, warning flags"]
    pub status: UINT16,
}
#[test]
fn bindgen_test_layout_IEVENT() {
    assert_eq!(
        ::std::mem::size_of::<IEVENT>(),
        68usize,
        concat!("Size of: ", stringify!(IEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<IEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(IEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).read as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).eye as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).sttime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(sttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).entime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(entime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).hstx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(hstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).hsty as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(hsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gstx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gsty as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).sta as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(sta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).henx as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(henx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).heny as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(heny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).genx as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(genx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).geny as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(geny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).ena as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(ena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).havx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(havx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).havy as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(havy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gavx as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gavx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gavy as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gavy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).ava as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(ava)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).avel as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(avel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).pvel as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(pvel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).svel as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(svel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).evel as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(evel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).supd_x as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(supd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).eupd_x as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(eupd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).supd_y as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(supd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).eupd_y as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(eupd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).status as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Floating-point eye event"]
#[doc = ""]
#[doc = "The EyeLink tracker analyzes the eye-position samples during recording to"]
#[doc = "detect saccades, and accumulates data on saccades and fixations. Events"]
#[doc = "are produced to mark the start and end of saccades, fixations and blinks."]
#[doc = "When both eyes are being tracked, left and right eye events are produced,"]
#[doc = "as indicated in the eye field of the FEVENT structure."]
#[doc = ""]
#[doc = "Start events contain only the start time, and optionally the start eye"]
#[doc = "or gaze position. End events contain the start and end time, plus summary"]
#[doc = "data on saccades and fixations. This includes start and end and average"]
#[doc = "measures of position and pupil size, plus peak and average velocity in"]
#[doc = "degrees per second."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FEVENT {
    #[doc = "< effective time of event"]
    pub time: UINT32,
    #[doc = "< event type"]
    pub type_: INT16,
    #[doc = "< flags which items were included"]
    pub read: UINT16,
    #[doc = "< eye: 0=left,1=right"]
    pub eye: INT16,
    #[doc = "< start times"]
    pub sttime: UINT32,
    #[doc = "< end times"]
    pub entime: UINT32,
    #[doc = "< starting point x"]
    pub hstx: f32,
    #[doc = "< starting point y"]
    pub hsty: f32,
    #[doc = "< starting point x"]
    pub gstx: f32,
    #[doc = "< starting point y"]
    pub gsty: f32,
    #[doc = "< starting area"]
    pub sta: f32,
    #[doc = "< ending point x"]
    pub henx: f32,
    #[doc = "< ending point y"]
    pub heny: f32,
    #[doc = "< ending point x"]
    pub genx: f32,
    #[doc = "< ending point y"]
    pub geny: f32,
    #[doc = "< ending area"]
    pub ena: f32,
    #[doc = "< average x"]
    pub havx: f32,
    #[doc = "< average y"]
    pub havy: f32,
    #[doc = "< average x"]
    pub gavx: f32,
    #[doc = "< average y"]
    pub gavy: f32,
    #[doc = "< average area"]
    pub ava: f32,
    #[doc = "< avg velocity accum"]
    pub avel: f32,
    #[doc = "< peak velocity accum"]
    pub pvel: f32,
    #[doc = "< start velocity"]
    pub svel: f32,
    #[doc = "< end velocity"]
    pub evel: f32,
    #[doc = "< start units-per-degree x"]
    pub supd_x: f32,
    #[doc = "< end units-per-degree x"]
    pub eupd_x: f32,
    #[doc = "< start units-per-degree y"]
    pub supd_y: f32,
    #[doc = "< end units-per-degree y"]
    pub eupd_y: f32,
    #[doc = "< error, warning flags"]
    pub status: UINT16,
}
#[test]
fn bindgen_test_layout_FEVENT() {
    assert_eq!(
        ::std::mem::size_of::<FEVENT>(),
        116usize,
        concat!("Size of: ", stringify!(FEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<FEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(FEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).read as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).eye as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).sttime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(sttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).entime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(entime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).hstx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(hstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).hsty as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(hsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gstx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gsty as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).sta as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(sta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).henx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(henx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).heny as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(heny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).genx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(genx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).geny as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(geny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).ena as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(ena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).havx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(havx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).havy as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(havy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gavx as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gavx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gavy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gavy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).ava as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(ava)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).avel as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(avel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).pvel as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(pvel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).svel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(svel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).evel as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(evel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).supd_x as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(supd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).eupd_x as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(eupd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).supd_y as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(supd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).eupd_y as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(eupd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).status as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Floating-point eye event with floating point time"]
#[doc = ""]
#[doc = "The EyeLink tracker analyzes the eye-position samples during recording to"]
#[doc = "detect saccades, and accumulates data on saccades and fixations. Events"]
#[doc = "are produced to mark the start and end of saccades, fixations and blinks."]
#[doc = "When both eyes are being tracked, left and right eye events are produced,"]
#[doc = "as indicated in the eye field of the FEVENT structure."]
#[doc = ""]
#[doc = "Start events contain only the start time, and optionally the start eye"]
#[doc = "or gaze position. End events contain the start and end time, plus summary"]
#[doc = "data on saccades and fixations. This includes start and end and average"]
#[doc = "measures of position and pupil size, plus peak and average velocity in"]
#[doc = "degrees per second."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DEVENT {
    #[doc = "< effective time of event"]
    pub time: f64,
    #[doc = "< event type"]
    pub type_: INT16,
    #[doc = "< flags which items were included"]
    pub read: UINT16,
    #[doc = "< eye: 0=left,1=right"]
    pub eye: INT16,
    #[doc = "< start times"]
    pub sttime: f64,
    #[doc = "< end times"]
    pub entime: f64,
    #[doc = "< starting point x"]
    pub hstx: f32,
    #[doc = "< starting point y"]
    pub hsty: f32,
    #[doc = "< starting point x"]
    pub gstx: f32,
    #[doc = "< starting point y"]
    pub gsty: f32,
    #[doc = "< starting area"]
    pub sta: f32,
    #[doc = "< ending point x"]
    pub henx: f32,
    #[doc = "< ending point y"]
    pub heny: f32,
    #[doc = "< ending point x"]
    pub genx: f32,
    #[doc = "< ending point y"]
    pub geny: f32,
    #[doc = "< ending area"]
    pub ena: f32,
    #[doc = "< average x"]
    pub havx: f32,
    #[doc = "< average y"]
    pub havy: f32,
    #[doc = "< average x"]
    pub gavx: f32,
    #[doc = "< average y"]
    pub gavy: f32,
    #[doc = "< average area"]
    pub ava: f32,
    #[doc = "< avg velocity accum"]
    pub avel: f32,
    #[doc = "< peak velocity accum"]
    pub pvel: f32,
    #[doc = "< start velocity"]
    pub svel: f32,
    #[doc = "< end velocity"]
    pub evel: f32,
    #[doc = "< start units-per-degree x"]
    pub supd_x: f32,
    #[doc = "< end units-per-degree x"]
    pub eupd_x: f32,
    #[doc = "< start units-per-degree y"]
    pub supd_y: f32,
    #[doc = "< end units-per-degree y"]
    pub eupd_y: f32,
    #[doc = "< error, warning flags"]
    pub status: UINT16,
}
#[test]
fn bindgen_test_layout_DEVENT() {
    assert_eq!(
        ::std::mem::size_of::<DEVENT>(),
        128usize,
        concat!("Size of: ", stringify!(DEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<DEVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(DEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).read as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).eye as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).sttime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(sttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).entime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(entime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).hstx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(hstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).hsty as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(hsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gstx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gsty as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).sta as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(sta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).henx as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(henx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).heny as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(heny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).genx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(genx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).geny as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(geny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).ena as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(ena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).havx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(havx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).havy as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(havy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gavx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gavx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gavy as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gavy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).ava as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(ava)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).avel as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(avel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).pvel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(pvel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).svel as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(svel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).evel as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(evel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).supd_x as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(supd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).eupd_x as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(eupd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).supd_y as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(supd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).eupd_y as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(eupd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).status as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Message events: usually text but may contain binary data"]
#[doc = ""]
#[doc = "A message event is created by your experiment program, and placed in the EDF file."]
#[doc = "It is possible to enable the sending of these messages back through the link,"]
#[doc = "although there is rarely a reason to do this. Although this method might be"]
#[doc = "used to determine the tracker time (the time field of a message event will indicate"]
#[doc = "when the message was received by the tracker), the use of eyelink_request_time()"]
#[doc = "and eyelink_read_time() is more efficient for retrieving the current time from the"]
#[doc = "eye tracker's timestamp clock. The eye tracker time is rarely needed in any case,"]
#[doc = "and would only be useful to compute link transport delays."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMESSAGE {
    #[doc = "< time message logged"]
    pub time: UINT32,
    #[doc = "< event type: usually MESSAGEEVENT"]
    pub type_: INT16,
    #[doc = "< length of message"]
    pub length: UINT16,
    #[doc = "< message contents (max length 255)"]
    pub text: [byte; 260usize],
}
#[test]
fn bindgen_test_layout_IMESSAGE() {
    assert_eq!(
        ::std::mem::size_of::<IMESSAGE>(),
        268usize,
        concat!("Size of: ", stringify!(IMESSAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<IMESSAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(IMESSAGE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(text)
        )
    );
}
impl Default for IMESSAGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Message events: usually text but may contain binary data with floating point time."]
#[doc = ""]
#[doc = "A message event is created by your experiment program, and placed in the EDF file."]
#[doc = "It is possible to enable the sending of these messages back through the link,"]
#[doc = "although there is rarely a reason to do this. Although this method might be"]
#[doc = "used to determine the tracker time (the time field of a message event will indicate"]
#[doc = "when the message was received by the tracker), the use of eyelink_request_time()"]
#[doc = "and eyelink_read_time() is more efficient for retrieving the current time from the"]
#[doc = "eye tracker's timestamp clock. The eye tracker time is rarely needed in any case,"]
#[doc = "and would only be useful to compute link transport delays."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DMESSAGE {
    #[doc = "< time message logged"]
    pub time: f64,
    #[doc = "< event type: usually MESSAGEEVENT"]
    pub type_: INT16,
    #[doc = "< length of message"]
    pub length: UINT16,
    #[doc = "< message contents (max length 255)"]
    pub text: [byte; 260usize],
}
#[test]
fn bindgen_test_layout_DMESSAGE() {
    assert_eq!(
        ::std::mem::size_of::<DMESSAGE>(),
        272usize,
        concat!("Size of: ", stringify!(DMESSAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<DMESSAGE>(),
        8usize,
        concat!("Alignment of ", stringify!(DMESSAGE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).length as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).text as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(text)
        )
    );
}
impl Default for DMESSAGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Button, input, other simple events"]
#[doc = ""]
#[doc = "BUTTONEVENT and INPUTEVENT types are the simplest events, reporting"]
#[doc = "changes in button status or in the input port data. The time field"]
#[doc = "records the timestamp of the eye-data sample where the change occurred,"]
#[doc = "although the event itself is usually sent before that sample. The data"]
#[doc = "field contains the data after the change, in the same format as in the"]
#[doc = "FSAMPLE structure."]
#[doc = ""]
#[doc = "Button events from the link are rarely used; monitoring buttons with one"]
#[doc = "of eyelink_read_keybutton(), eyelink_last_button_press(), or"]
#[doc = "eyelink_button_states() is preferable, since these can report button"]
#[doc = "states at any time, not just during recording."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IOEVENT {
    #[doc = "< time logged"]
    pub time: UINT32,
    #[doc = "< event type:"]
    pub type_: INT16,
    #[doc = "< coded event data"]
    pub data: UINT16,
}
#[test]
fn bindgen_test_layout_IOEVENT() {
    assert_eq!(
        ::std::mem::size_of::<IOEVENT>(),
        8usize,
        concat!("Size of: ", stringify!(IOEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<IOEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(IOEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IOEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IOEVENT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IOEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IOEVENT>())).data as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IOEVENT),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Button, input, other simple events with floating point time."]
#[doc = ""]
#[doc = "BUTTONEVENT and INPUTEVENT types are the simplest events, reporting"]
#[doc = "changes in button status or in the input port data. The time field"]
#[doc = "records the timestamp of the eye-data sample where the change occurred,"]
#[doc = "although the event itself is usually sent before that sample. The data"]
#[doc = "field contains the data after the change, in the same format as in the"]
#[doc = "FSAMPLE structure."]
#[doc = ""]
#[doc = "Button events from the link are rarely used; monitoring buttons with one"]
#[doc = "of eyelink_read_keybutton(), eyelink_last_button_press(), or"]
#[doc = "eyelink_button_states() is preferable, since these can report button"]
#[doc = "states at any time, not just during recording."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DIOEVENT {
    #[doc = "< time logged"]
    pub time: f64,
    #[doc = "< event type:"]
    pub type_: INT16,
    #[doc = "< coded event data"]
    pub data: UINT16,
}
#[test]
fn bindgen_test_layout_DIOEVENT() {
    assert_eq!(
        ::std::mem::size_of::<DIOEVENT>(),
        16usize,
        concat!("Size of: ", stringify!(DIOEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<DIOEVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(DIOEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIOEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIOEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIOEVENT>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIOEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIOEVENT>())).data as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DIOEVENT),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALL_DATA {
    pub ie: IEVENT,
    pub im: IMESSAGE,
    pub io: IOEVENT,
    pub is: ISAMPLE,
    _bindgen_union_align: [u32; 67usize],
}
#[test]
fn bindgen_test_layout_ALL_DATA() {
    assert_eq!(
        ::std::mem::size_of::<ALL_DATA>(),
        268usize,
        concat!("Size of: ", stringify!(ALL_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ALL_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(ALL_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).ie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(ie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).is as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(is)
        )
    );
}
impl Default for ALL_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Union of message, io event and float sample and float event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALLF_DATA {
    pub fe: FEVENT,
    pub im: IMESSAGE,
    pub io: IOEVENT,
    pub fs: FSAMPLE,
    _bindgen_union_align: [u32; 67usize],
}
#[test]
fn bindgen_test_layout_ALLF_DATA() {
    assert_eq!(
        ::std::mem::size_of::<ALLF_DATA>(),
        268usize,
        concat!("Size of: ", stringify!(ALLF_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ALLF_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(ALLF_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).fe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(fe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(fs)
        )
    );
}
impl Default for ALLF_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Union of message, io event and double sample and double event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALLD_DATA {
    pub fe: DEVENT,
    pub im: DMESSAGE,
    pub io: DIOEVENT,
    pub fs: DSAMPLE,
    _bindgen_union_align: [u64; 34usize],
}
#[test]
fn bindgen_test_layout_ALLD_DATA() {
    assert_eq!(
        ::std::mem::size_of::<ALLD_DATA>(),
        272usize,
        concat!("Size of: ", stringify!(ALLD_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ALLD_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(ALLD_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).fe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(fe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(fs)
        )
    );
}
impl Default for ALLD_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ELINKADDR = [byte; 16usize];
#[doc = " \\brief Name and address for connection."]
#[doc = ""]
#[doc = "Name and address for connection or ping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ELINKNODE {
    #[doc = "< address of the remote  or local tracker"]
    pub addr: ELINKADDR,
    #[doc = "< name of the remote  or local tracker"]
    pub name: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ELINKNODE() {
    assert_eq!(
        ::std::mem::size_of::<ELINKNODE>(),
        56usize,
        concat!("Size of: ", stringify!(ELINKNODE))
    );
    assert_eq!(
        ::std::mem::align_of::<ELINKNODE>(),
        1usize,
        concat!("Alignment of ", stringify!(ELINKNODE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ELINKNODE>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ELINKNODE),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ELINKNODE>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ELINKNODE),
            "::",
            stringify!(name)
        )
    );
}
impl Default for ELINKNODE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief Class to represent tracker status."]
#[doc = ""]
#[doc = "Class to represent tracker status information such as time stamps, flags, tracker addresses and so on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ILINKDATA {
    #[doc = "< time of last control event"]
    pub time: UINT32,
    #[doc = "< structure version"]
    pub version: UINT32,
    #[doc = "< 10*sample rate (0 if no samples, 1 if nonconstant)"]
    pub samrate: UINT16,
    #[doc = "< sample \"divisor\" (min msec between samples)"]
    pub samdiv: UINT16,
    #[doc = "< amount to divide gaze x,y,res by"]
    pub prescaler: UINT16,
    #[doc = "< amount to divide velocity by"]
    pub vprescaler: UINT16,
    #[doc = "< pupil prescale (1 if area, greater if diameter)"]
    pub pprescaler: UINT16,
    #[doc = "< head-distance prescale (to mm)"]
    pub hprescaler: UINT16,
    #[doc = "< 0 if off, else all flags"]
    pub sample_data: UINT16,
    #[doc = "< 0 if off, else all flags"]
    pub event_data: UINT16,
    #[doc = "< 0 if off, else event-type flags"]
    pub event_types: UINT16,
    #[doc = "< set if in block with samples"]
    pub in_sample_block: byte,
    #[doc = "< set if in block with events"]
    pub in_event_block: byte,
    #[doc = "< set if any left-eye data expected"]
    pub have_left_eye: byte,
    #[doc = "< set if any right-eye data expected"]
    pub have_right_eye: byte,
    #[doc = "< flags what we lost before last item"]
    pub last_data_gap_types: UINT16,
    #[doc = "< buffer-type code"]
    pub last_data_buffer_type: UINT16,
    #[doc = "< buffer size of last item"]
    pub last_data_buffer_size: UINT16,
    #[doc = "< set if control event read with last data"]
    pub control_read: UINT16,
    #[doc = "< set if control event started new block"]
    pub first_in_block: UINT16,
    #[doc = "< time field of item"]
    pub last_data_item_time: UINT32,
    #[doc = "< type: 100=sample, 0=none, else event type"]
    pub last_data_item_type: UINT16,
    #[doc = "< content: &lt;read&gt; (IEVENT), &lt;flags&gt; (ISAMPLE)"]
    pub last_data_item_contents: UINT16,
    #[doc = "< buffer containing last item"]
    pub last_data_item: ALL_DATA,
    #[doc = "< block in file"]
    pub block_number: UINT32,
    #[doc = "< samples read in block so far"]
    pub block_sample: UINT32,
    #[doc = "< events (excl. control read in block"]
    pub block_event: UINT32,
    #[doc = "< updated by samples only"]
    pub last_resx: UINT16,
    #[doc = "< updated by samples only"]
    pub last_resy: UINT16,
    #[doc = "< updated by samples only"]
    pub last_pupil: [UINT16; 2usize],
    #[doc = "< updated by samples, events"]
    pub last_status: UINT16,
    #[doc = "< number of items in queue"]
    pub queued_samples: UINT16,
    #[doc = "< includes control events"]
    pub queued_events: UINT16,
    #[doc = "< total queue buffer size"]
    pub queue_size: UINT16,
    #[doc = "< unused bytes in queue"]
    pub queue_free: UINT16,
    #[doc = "< time tracker last sent packet"]
    pub last_rcve_time: UINT32,
    #[doc = "< data type rcve enable (switch)"]
    pub samples_on: byte,
    pub events_on: byte,
    #[doc = "< status flags from data packet"]
    pub packet_flags: UINT16,
    #[doc = "< status flags from link packet header"]
    pub link_flags: UINT16,
    #[doc = "< tracker error state flags"]
    pub state_flags: UINT16,
    #[doc = "< tracker data output state"]
    pub link_dstatus: byte,
    #[doc = "< tracker commands pending"]
    pub link_pendcmd: byte,
    #[doc = "< 0 for EyeLink I or original EyeLink API DLL."]
    #[doc = "EYELINK II ONLY: MSB set if read"]
    #[doc = "crmode<<8 + file_filter<<4 + link_filter"]
    #[doc = "crmode = 0 if pupil, else pupil-CR"]
    #[doc = "file_filter, link_filter: 0, 1, or 2"]
    #[doc = "for level of heuristic filter applied"]
    pub reserved: UINT16,
    #[doc = "< a name for our machine"]
    pub our_name: [::std::os::raw::c_char; 40usize],
    pub our_address: ELINKADDR,
    #[doc = "< name of tracker connected to"]
    pub eye_name: [::std::os::raw::c_char; 40usize],
    pub eye_address: ELINKADDR,
    #[doc = "< Broadcast address for eye trackers"]
    pub ebroadcast_address: ELINKADDR,
    #[doc = "< Broadcast address for remotes"]
    pub rbroadcast_address: ELINKADDR,
    #[doc = "< 1 if polling remotes, else polling trackers"]
    pub polling_remotes: UINT16,
    #[doc = "< total nodes responding to polling"]
    pub poll_responses: UINT16,
    #[doc = "< data on nodes"]
    pub nodes: [ELINKNODE; 4usize],
}
#[test]
fn bindgen_test_layout_ILINKDATA() {
    assert_eq!(
        ::std::mem::size_of::<ILINKDATA>(),
        736usize,
        concat!("Size of: ", stringify!(ILINKDATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ILINKDATA>(),
        4usize,
        concat!("Alignment of ", stringify!(ILINKDATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).samrate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(samrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).samdiv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(samdiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).prescaler as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(prescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).vprescaler as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(vprescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).pprescaler as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(pprescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).hprescaler as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(hprescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).sample_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(sample_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).event_data as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(event_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).event_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(event_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).in_sample_block as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(in_sample_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).in_event_block as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(in_event_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).have_left_eye as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(have_left_eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).have_right_eye as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(have_right_eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_gap_types as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_gap_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_buffer_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_buffer_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_buffer_size as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).control_read as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(control_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).first_in_block as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(first_in_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_item_time as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_item_type as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ILINKDATA>())).last_data_item_contents as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item_contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_item as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).block_number as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(block_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).block_sample as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(block_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).block_event as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(block_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_resx as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_resx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_resy as *const _ as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_resy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_pupil as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_pupil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_status as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queued_samples as *const _ as usize },
        338usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queued_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queued_events as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queued_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queue_size as *const _ as usize },
        342usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queue_free as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queue_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_rcve_time as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_rcve_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).samples_on as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(samples_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).events_on as *const _ as usize },
        353usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(events_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).packet_flags as *const _ as usize },
        354usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(packet_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).link_flags as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(link_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).state_flags as *const _ as usize },
        358usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(state_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).link_dstatus as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(link_dstatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).link_pendcmd as *const _ as usize },
        361usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(link_pendcmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).reserved as *const _ as usize },
        362usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).our_name as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(our_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).our_address as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(our_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).eye_name as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(eye_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).eye_address as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(eye_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).ebroadcast_address as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(ebroadcast_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).rbroadcast_address as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(rbroadcast_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).polling_remotes as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(polling_remotes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).poll_responses as *const _ as usize },
        510usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(poll_responses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).nodes as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(nodes)
        )
    );
}
impl Default for ILINKDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Use this function to initialize the EyeLink library.  This will also start"]
    #[doc = "the millisecond clock.  No connection is attempted to the eyetracker yet."]
    #[doc = "It is preferable to call open_eyelink_connection(\\c -1)  instead, as this"]
    #[doc = "prepares other parts of the DLL for use."]
    #[doc = ""]
    #[doc = "@remarks MUST BE FIRST CALL TO LINK INTERFACE."]
    #[doc = "@param bufsize Size of sample buffer.  \\c 60000 is the maximum allowed. (\\c 0 for default)"]
    #[doc = "@param options Text specifying initialization options.  Currently no options are supported."]
    #[doc = "(\\c NULL or \"\" for defaults)"]
    #[doc = "@return \\c 0 if failed, nonzero (\\c -1 or TSR SWI number) if success."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int dummy = 0;  // Sets the connection type"]
    #[doc = ""]
    #[doc = "if(!open_eyelink_system(0, \"\"))"]
    #[doc = "{"]
    #[doc = "printf(\"\\nERROR: Cannot initialize eyelink library\\n\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if(dummy)"]
    #[doc = "i = eyelink_dummy_open(); // Starts a dummy connection"]
    #[doc = "else"]
    #[doc = "i = eyelink_open();  // Connects to the tracker"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "set_offline_mode();"]
    #[doc = "eyecmd_printf(\"close_data_file\");    // close data file"]
    #[doc = "eyelink_close(1);         // disconnect from tracker"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "close_eyelink_system();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c close_eyelink_connection(), \\c close_eyelink_system(), \\c eyelink_close() and \\c eyelink_open()"]
    pub fn open_eyelink_system(bufsize: UINT16, options: *mut ::std::os::raw::c_char) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sets the node name of this computer (up to 35 characters)."]
    #[doc = ""]
    #[doc = "@param name String to become new name."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKNODE node;  // This will hold application name and address"]
    #[doc = ""]
    #[doc = "if (set_eyelink_address(\"100.1.1.7\"))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "eyelink_set_name(\"Newapplication\");"]
    #[doc = ""]
    #[doc = "if(eyelink_get_node(0, &node) == OK_RESULT)"]
    #[doc = "eyemsg_printf(\"%s\", node.name);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t2248248 Newapplication"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_node(), \\c open_eyelink_connection() and \\c set_eyelink_address()"]
    pub fn eyelink_set_name(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Resets the EyeLink library, releases the system resources used by the millisecond clock."]
    #[doc = ""]
    #[doc = "@remarks MUST DO BEFORE EXITING."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c open_eyelink_system()"]
    #[doc = ""]
    #[doc = "\\sa \\c open_eyelink_system(), \\c eyelink_close() and \\c set_offline_mode()"]
    pub fn close_eyelink_system();
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current millisecond since the initialization."]
    #[doc = ""]
    #[doc = "@remarks If the eyelink_exptkit library is not initialized, or initialized multiple times,"]
    #[doc = "the return value is invalid and the return value is unpredictable. So in order to avoid"]
    #[doc = "this, make sure that \\c close_eyelink_system() is called at the end."]
    #[doc = "The call to \\c current_msec() is always equivalent to \\c current_time()."]
    #[doc = "@return The current millisecond since the initialization of the library."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Delay test starts: %ld\", current_msec());"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf(\"Delay test ends: %ld\", current_time());"]
    #[doc = "\\endcode"]
    #[doc = "<pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t4532575 Delay test starts: 5236"]
    #[doc = "MSG\t4532671 Delay test ends: 5336"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c current_msec(), \\c current_micro(), \\c current_usec(), \\c eyelink_tracker_time() and \\c msec_delay()"]
    pub fn current_time() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current microsecond since the initialization."]
    #[doc = "Equivalent to \\c current_usec() and \\c current_double_usec()."]
    #[doc = ""]
    #[doc = "@param m Pointer to MICRO structure."]
    #[doc = "@return The current microsecond since the initialization of the library, modulo 2^32."]
    #[doc = "It can also fill in the \\c MICRO structure if the pointer is not \\c NULL."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c current_usec()"]
    #[doc = ""]
    #[doc = "\\sa \\c current_usec(), \\c current_double_usec(), \\c current_msec(), \\c current_time() and \\c msec_delay()"]
    pub fn current_micro(m: *mut MICRO) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current microsecond since the initialization."]
    #[doc = "Equivalent to \\c current_micro() and \\c current_double_usec()."]
    #[doc = ""]
    #[doc = "@remarks If the eyelink_exptkit library is not initialized, or initialized multiple times,"]
    #[doc = "the return value is invalid and unpredictable.  The call to"]
    #[doc = "\\c current_usec() is equivalent to \\c current_micro(NULL).  The function is very"]
    #[doc = "platform dependent. Platforms such as windows 95, 98, ME may not return usec"]
    #[doc = "properly. Ie. It may return <tt>current_time() * 1000</tt>."]
    #[doc = "@return The current microsecond since the initialization of the library, modulo 2^32."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "MICRO m1, m2;  // Special high-resolution time structure"]
    #[doc = ""]
    #[doc = "current_micro(&m1);"]
    #[doc = "eyemsg_printf(\"Delay test starts: %ld\", current_usec());"]
    #[doc = ""]
    #[doc = "msec_delay(100);"]
    #[doc = ""]
    #[doc = "current_micro(&m2);"]
    #[doc = "eyemsg_printf(\"Delay test ends: %ld\", current_usec());"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Total Delay: %6.3f\","]
    #[doc = "m2.msec + m2.usec/1000.0 - m1.msec + m1.usec/1000.0);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t5441107 Delay test starts: 4610094"]
    #[doc = "MSG\t5441206 Delay test ends: 4710005"]
    #[doc = "MSG\t5441206 Total Delay: 100.003"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c current_micro(), \\c current_double_usec(), \\c current_msec(), \\c current_time() and \\c msec_delay()"]
    pub fn current_usec() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Does a unblocked delay using \\c current_time()."]
    #[doc = ""]
    #[doc = "@param n n milliseconds to delay."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Delay test starts: %ld\", current_msec());"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf(\"Delay test ends: %ld\", current_time());"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t4346690 Delay test starts: 12768"]
    #[doc = "MSG\t4346791 Delay test ends: 12868"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c current_msec() and \\c pump_delay()"]
    pub fn msec_delay(n: UINT32);
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current microsecond as double (56 bits) since the initialization."]
    #[doc = "Equivalent to \\c current_micro() and \\c current_usec()."]
    #[doc = ""]
    #[doc = "@return The current microsecond as a double value since the initialization of the library, modulo 2^32."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c current_usec()"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\sa \\c current_micro(), \\c current_usec(), \\c current_msec(), \\c current_time() and \\c msec_delay()"]
    pub fn current_double_usec() -> f64;
}
extern "C" {
    pub static mut eye_broadcast_address: ELINKADDR;
}
extern "C" {
    pub static mut rem_broadcast_address: ELINKADDR;
}
extern "C" {
    pub static mut our_address: ELINKADDR;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Allows the computer to connect to tracker, where the tracker is on the same network."]
    #[doc = ""]
    #[doc = "@param node Must be an address returned by \\c eyelink_poll_trackers() and"]
    #[doc = "\\c eyelink_poll_responses() to connect to any tracker."]
    #[doc = "@param busytest If non-zero the call to \\c eyelink_open_node() will not disconnect an existing connection."]
    #[doc = "@return \\c 0 if successful.\\n"]
    #[doc = "\\c LINK_INITIALIZE_FAILED  if link could not be established.\\n"]
    #[doc = "\\c CONNECT_TIMEOUT_FAILED  if tracker did not respond.\\n"]
    #[doc = "\\c WRONG_LINK_VERSION if the versions of the EyeLink library and tracker are incompatible.\\n"]
    #[doc = "\\c TRACKER_BUSY if \\c &lt;busytest&gt; is set, and tracker is connected to another computer.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "ELINKADDR node;\t\t\t\t// EyeLink address node"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "text_to_elinkaddr(\"100.1.1.1\", node, 0);"]
    #[doc = ""]
    #[doc = "if (eyelink_open_node(node, 1))"]
    #[doc = "return -1;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_node_receive(), \\c eyelink_node_send(), \\c eyelink_node_send_message() and \\c eyelink_open()"]
    pub fn eyelink_open_node(node: *mut byte, busytest: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Attempts to open a link connection to the EyeLink tracker.  Simple connect to single Eyelink tracker."]
    #[doc = "Equivalent to \\c eyelink_open_node(broadcast_address, 0)."]
    #[doc = ""]
    #[doc = "@remarks The tracker address can be set by calling the function \\c set_eyelink_address().  If this"]
    #[doc = "address was \"255.255.255.255\" the call to \\c eyelink_open() will \"broadcast\" a request"]
    #[doc = "to any tracker, however this may fail if multiple Ethernet cards are installed."]
    #[doc = "For the broadcast option to work use EyeLink I v2.1 or higher, EyeLink II v1.1 or higher."]
    #[doc = "Before using this command, call either \\c open_eyelink_connection(-1) or"]
    #[doc = "\\c open_eyelink_system () to prepare the link for use."]
    #[doc = ""]
    #[doc = "@return \\c 0 if successful.\\n"]
    #[doc = "\\c LINK_INITIALIZE_FAILED  if link could not be established.\\n"]
    #[doc = "\\c CONNECT_TIMEOUT_FAILED  if tracker did not respond.\\n"]
    #[doc = "\\c WRONG_LINK_VERSION if the versions of the EyeLink library and tracker are incompatible.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "set_eyelink_address(\"100.1.1.1\");"]
    #[doc = ""]
    #[doc = "if (eyelink_open())"]
    #[doc = "return -1;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open(), \\c eyelink_close(), \\c eyelink_dummy_open(), \\c eyelink_open_node(),"]
    #[doc = "\\c open_eyelink_connection(), \\c open_eyelink_system() and \\c set_eyelink_address()"]
    pub fn eyelink_open() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Allows a third computer to listen in on a session between the eye tracker and a controlling"]
    #[doc = "remote machine.  This allows it to receive data during recording and playback, and to monitor"]
    #[doc = "the eye tracker mode.  The local computer will not be able to send commands to the eye tracker,"]
    #[doc = "but may be able to send messages or request the tracker time."]
    #[doc = ""]
    #[doc = "@remarks May not function properly, if there are more than one Ethernet cards installed."]
    #[doc = "@return \\c 0 if successful.\\n"]
    #[doc = "\\c LINK_INITIALIZE_FAILED  if link could not be established.\\n"]
    #[doc = "\\c CONNECT_TIMEOUT_FAILED  if tracker did not respond.\\n"]
    #[doc = "\\c WRONG_LINK_VERSION if the versions of the EyeLink library and tracker are incompatible.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "eyelink_set_name(\"Broadcast\");"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_broadcast_open())"]
    #[doc = "{"]
    #[doc = "printf(\"Cannot open broadcast connection to tracker\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyelink_reset_data(1);"]
    #[doc = "eyelink_data_switch(RECORD_LINK_SAMPLES | RECORD_LINK_EVENTS);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_close(), \\c eyelink_dummy_open(), \\c eyelink_is_connected(), \\c eyelink_open() and"]
    #[doc = "\\c eyelink_open_node()"]
    pub fn eyelink_broadcast_open() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sets the EyeLink library to simulate an eyetracker connection.  Functions will return"]
    #[doc = "plausible values, but no data."]
    #[doc = ""]
    #[doc = "@remarks The function \\c eyelink_is_connected() will return \\c -1 to indicate a simulated connection."]
    #[doc = "@return Always returns \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "eyelink_dummy_open();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open(), \\c eyelink_open() and \\c eyelink_open_node()"]
    pub fn eyelink_dummy_open() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sends a disconnect message to the EyeLink tracker, resets the link data system."]
    #[doc = ""]
    #[doc = "@param send_msg Usually \\c &lt;send_msg&gt; is \\c 1. However, \\c 0 can be used to reset the eyelink system"]
    #[doc = "if it is listening on a broadcast session."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "set_offline_mode();      \t// off-line mode"]
    #[doc = "eyecmd_printf(\"close_data_file\");"]
    #[doc = "eyelink_close(1);         // disconnect from tracker"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open(), \\c eyelink_open(), \\c eyelink_dummy_open() and \\c eyelink_open_node()"]
    pub fn eyelink_close(send_msg: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Initializes the high frequency clock."]
    #[doc = ""]
    #[doc = "With TSR interface under msdos, Start/stop timing resources."]
    #[doc = ""]
    #[doc = "@param enable Usually \\c &lt;enable&gt; is \\c 1. However, in MS-DOS passing \\c 0 will cleanup the timing resources."]
    #[doc = "In other platforms passing \\c 0 has no effect."]
    pub fn eyelink_reset_clock(enable: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Checks whether the connection to the tracker is alive."]
    #[doc = ""]
    #[doc = "@remarks Call this routine during loops and wherever the experiment might lock up if"]
    #[doc = "the tracker is shut down.  Exit the experiment (by terminating loops and"]
    #[doc = "returning from all calls) if this returns \\c 0."]
    #[doc = "@return \\c 0 if link closed.\\n"]
    #[doc = "\\c -1 if simulating connection.\\n"]
    #[doc = "\\c 1 for normal connection.\\n"]
    #[doc = "\\c 2 for broadcast connection (NEW for v2.1 and later).\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "error = do_drift_correct(SCRWIDTH/2, SCRHEIGHT/2, 1, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27) break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_close() and \\c eyelink_open()"]
    pub fn eyelink_is_connected() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Controls the level of control an application has over the tracker."]
    #[doc = ""]
    #[doc = "@remarks This is used in combination with broadcast mode (multiple applications connected to one tracker)"]
    #[doc = "to ensure that \"listener\" applications do not inadvertently send commands, key presses, or"]
    #[doc = "messages to the tracker.  This is mostly useful when quickly converting an existing"]
    #[doc = "application into a listener."]
    #[doc = "@param mode \\c 0 to allow all communication.\\n"]
    #[doc = "\\c 1 to block commands (allows only key presses, messages, and time or variable read requests).\\n"]
    #[doc = "\\c 2 to disable all commands, requests and messages.\\n"]
    #[doc = "\\c -1 to just return current setting.\\n"]
    #[doc = "@return The previous settings."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(eyelink_broadcast_open())"]
    #[doc = "{"]
    #[doc = "printf(\"Cannot open broadcast connection to tracker\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyelink_reset_data(1);"]
    #[doc = "eyelink_data_switch(RECORD_LINK_SAMPLES | RECORD_LINK_EVENTS);"]
    #[doc = ""]
    #[doc = "eyelink_quiet_mode(0);\t// Allows for message sending"]
    #[doc = "eyelink_send_message(\"This should be recorded in the EDF file\");"]
    #[doc = "eyelink_quiet_mode(2);   // Disables message sending"]
    #[doc = "eyelink_send_message(\"This should not appear in the EDF file\");"]
    #[doc = "eyelink_quiet_mode(0);   // Allows for message sending again"]
    #[doc = "eyelink_send_message(\"This should appear in the EDF file\");"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t3304947 This message should be recorded in the EDF file"]
    #[doc = "MSG\t3304947 This message should appear in the EDF file"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open() and \\c eyelink_open()"]
    pub fn eyelink_quiet_mode(mode: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Asks all trackers (with EyeLink software running) on the network to send their names and node address."]
    #[doc = ""]
    #[doc = "@return \\c OK_RESULT if successful, otherwise link error."]
    #[doc = "@return \\c LINK_TERMINATED_RESULT if link error."]
    #[doc = "@return \\c -1 if broadcast option is not available."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_poll_remotes()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_poll_remotes() and \\c eyelink_poll_responses()"]
    pub fn eyelink_poll_trackers() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Asks all non-tracker computers (with EyeLink software running) on the network to send their names"]
    #[doc = "and node address."]
    #[doc = ""]
    #[doc = "@return \\c OK_RESULT if successful, otherwise link error."]
    #[doc = "@return \\c LINK_TERMINATED_RESULT if link error."]
    #[doc = "@return \\c -1 if broadcast option is not available."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKADDR listener_address;  // Address of listener application"]
    #[doc = ""]
    #[doc = "int check_for_listener(void)"]
    #[doc = "{"]
    #[doc = "int i, n;"]
    #[doc = "ELINKNODE node;  // This will hold application name and address"]
    #[doc = ""]
    #[doc = "eyelink_poll_remotes(); // Polls network for EyeLink applications"]
    #[doc = "pump_delay(500);        // Gives applications time to respond"]
    #[doc = ""]
    #[doc = "n = eyelink_poll_responses();  // How many responses?"]
    #[doc = "for(i = 1; i<= n; i++)"]
    #[doc = "{"]
    #[doc = "if(eyelink_get_node(i, &node) < 0)"]
    #[doc = "return -1;  // error: no such data"]
    #[doc = ""]
    #[doc = "if(!_stricmp(node.name, \"comm_listener\"))"]
    #[doc = "{"]
    #[doc = "memcpy(listener_address, node.addr, sizeof(ELINKADDR));"]
    #[doc = ""]
    #[doc = "eyelink_node_send(listener_address, \"NAME comm_simple\", 40);"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "return 0;   // all communication checks out"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "return -1;    // no listener node found"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_poll_responses() and \\c eyelink_poll_trackers()"]
    pub fn eyelink_poll_remotes() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Returns the count of node addresses received so far following the call of"]
    #[doc = "\\c eyelink_poll_remotes() or \\c eyelink_poll_trackers()."]
    #[doc = ""]
    #[doc = "@remarks You should allow about 100 milliseconds for all nodes to respond.  Up to 4 node"]
    #[doc = "responses are saved."]
    #[doc = "@return Number of nodes responded.  \\c 0 if no responses."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_poll_remotes()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_poll_remotes() and \\c eyelink_poll_trackers()"]
    pub fn eyelink_poll_responses() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Reads the responses returned by other trackers or remotes in response to"]
    #[doc = "\\c eyelink_poll_trackers() or \\c eyelink_poll_remotes(). It can also read the tracker"]
    #[doc = "broadcast address and remote broadcast addresses."]
    #[doc = ""]
    #[doc = "@param resp Nmber of responses to read:\\c 0 gets our data, \\c 1 get first response, \\c 2 gets the"]
    #[doc = "second response, etc. \\c -1 to read the tracker broadcast address. \\c -2 to read"]
    #[doc = "remote broadcast addresses."]
    #[doc = "@param data Pointer to buffer of \\c ELINKNODE type, to hold name and \\c ELINKADDR of the respondent."]
    #[doc = "@return \\c 0 if OK, \\c -1 if node response number is too high."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_poll_remotes()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_node_receive(), \\c eyelink_node_send() and \\c eyelink_poll_remotes()"]
    pub fn eyelink_get_node(resp: INT16, data: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a given data to the given node."]
    #[doc = ""]
    #[doc = "@param node \\c ELINKADDR node address."]
    #[doc = "@param data Pointer to buffer containing data to send."]
    #[doc = "@param dsize Number of bytes of data. Maximum \\c ELREMBUFSIZE bytes."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKADDR listener_address; // Address of the listener application"]
    #[doc = "char text_message[256], echo_message[256];"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "sprintf(text_message, \"START_RECORD\");"]
    #[doc = "eyelink_node_send(listener_address, text_message, 40);"]
    #[doc = ""]
    #[doc = "while (1)"]
    #[doc = "{"]
    #[doc = "k = eyelink_node_receive(listener_address, echo_message);"]
    #[doc = "if (k > 0 && strstr(echo_message, text_message))"]
    #[doc = "break;"]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKADDR sender_address; // Address of the sender application"]
    #[doc = "char text_message[256], echo_message[256];"]
    #[doc = ""]
    #[doc = "k = eyelink_node_receive(sender_address, text_message);"]
    #[doc = ""]
    #[doc = "if(k > 0 && !_strnicmp(text_message, \"START_RECORD\", 12))"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(text_message);"]
    #[doc = "error = start_recording(1,1,1,1); // Starts recording"]
    #[doc = "if(error != 0)"]
    #[doc = "return error;        // Return error code if failed"]
    #[doc = ""]
    #[doc = "sprintf(echo_message, \"ECHO %s\", text_message);"]
    #[doc = "eyelink_node_send(sender_address, echo_message, 60);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_get_node(), \\c eyelink_node_receive() and \\c eyelink_open_node()"]
    pub fn eyelink_node_send(
        node: *mut byte,
        data: *mut ::std::os::raw::c_void,
        dsize: UINT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Checks for and gets the last packet received, stores the data and the node address sent from."]
    #[doc = ""]
    #[doc = "@remarks Data can only be read once, and is overwritten if a new packet arrives before the"]
    #[doc = "last packet has been read."]
    #[doc = "@param node Address of the sender."]
    #[doc = "@param data Pointer to a buffer to hold the data."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_node_send()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_open_node() and \\c eyelink_node_send()"]
    pub fn eyelink_node_receive(node: *mut byte, data: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a command to the connected eye tracker."]
    #[doc = ""]
    #[doc = "@remarks If \\c eyelink_send_commnd() is used, the text command will be executed, and a"]
    #[doc = "result code returned that can be read with \\c eyelink_command_result()."]
    #[doc = "@param text String command to send."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT32 t;"]
    #[doc = "int i, j;"]
    #[doc = "char buf[256];"]
    #[doc = ""]
    #[doc = "eyelink_send_command(\"button_function 1 'accept_target_fixation'\");"]
    #[doc = ""]
    #[doc = "t = current_msec();"]
    #[doc = "while(current_msec()-t < 1000)"]
    #[doc = "{"]
    #[doc = "i = eyelink_command_result();"]
    #[doc = "j = eyelink_last_message(buf);"]
    #[doc = ""]
    #[doc = "if (i == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Command executed successfully: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "else if (i!=NO_REPLY)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Error in executing command: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t4608038 Command executed successfully: OK"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_command_result() and \\c eyelink_timed_command()"]
    pub fn eyelink_send_command(text: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Check for and retrieves the numeric result code sent by the tracker from the last command."]
    #[doc = ""]
    #[doc = "@return \\c NO_REPLY if no reply to last command.\\n"]
    #[doc = "<tt>OK_RESULT (0)</tt> if OK.\\n"]
    #[doc = "Other error codes represent tracker execution error.\\n"]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_send_command()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_last_message(), \\c eyelink_send_command() and \\c eyelink_timed_command()"]
    pub fn eyelink_command_result() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a command to the connected eye tracker, wait for reply."]
    #[doc = ""]
    #[doc = "@remarks If \\c eyelink_send_command() is used, the text command will be executed, and a result"]
    #[doc = "code returned that can be read with \\c eyelink_command_result()."]
    #[doc = "@param text String command to send."]
    #[doc = "@param msec Maximum milliseconds to wait for reply."]
    #[doc = "@return <tt>OK_RESULT (0)</tt> if OK.\\n"]
    #[doc = "\\c NO_REPLY if timed out.\\n"]
    #[doc = "\\c LINK_TERMINATED_RESULT if cannot send.\\n"]
    #[doc = "other error codes represent tracker execution error.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "INT16 error;"]
    #[doc = "char buf[256];"]
    #[doc = ""]
    #[doc = "error = eyelink_timed_command(1000, \"button_function 5"]
    #[doc = "'accept_target_fixation'\");"]
    #[doc = ""]
    #[doc = "if (error)"]
    #[doc = "{"]
    #[doc = "eyelink_last_message(buf);"]
    #[doc = "eyemsg_printf(\"Error in excuting the command: %s\", buf);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_command_result() and \\c eyelink_send_command()"]
    pub fn eyelink_timed_command(msec: UINT32, text: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Checks for and gets the last packet received, stores the data and the node address sent from."]
    #[doc = ""]
    #[doc = "@param buf String buffer to return text message."]
    #[doc = "@return \\c 0 if no message since last command sent, otherwise length of string."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_timed_command()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_send_command() and \\c eyelink_timed_command()"]
    pub fn eyelink_last_message(buf: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a text message the connected eye tracker.  The text will be added to the EDF file."]
    #[doc = ""]
    #[doc = "@param msg Text to send to the tracker."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_quiet_mode()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_node_send_message(), \\c eyelink_quiet_mode() and \\c set_eyelink_address()"]
    pub fn eyelink_send_message(msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a text message the connected eye tracker.  The text will be added to the EDF file."]
    #[doc = ""]
    #[doc = "@remarks NEW (v2.1): If the link is initialized but not connected to a tracker, the"]
    #[doc = "message will be sent to the tracker set by \\c set_eyelink_address()."]
    #[doc = "@param msg Text to send to the tracker."]
    #[doc = "@param node Address of the tracker."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_quiet_mode()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_send_message(), \\c eyelink_quiet_mode() and \\c set_eyelink_address()"]
    pub fn eyelink_node_send_message(node: *mut byte, msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Send a data file message string to connected tracker with time offset."]
    #[doc = "@param exectime time offset. If the offset is 0, this function is the same as eyelink_send_message()"]
    #[doc = "@param msg Message to be sent"]
    #[doc = "@return \\c OK_RESULT or \\c LINK_TERMINATED_RESULT."]
    #[doc = "@sa eyemsg_printf_ex(), eyelink_send_message()"]
    pub fn eyelink_send_message_ex(exectime: UINT32, msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Send a data file message to any or all trackers with time offset."]
    #[doc = "@param exectime time offset. If the offset is 0, this function is the same as eyelink_node_send_message()"]
    #[doc = "@param node Node address"]
    #[doc = "@param msg Message to be sent"]
    #[doc = "@return \\c OK_RESULT or \\c LINK_TERMINATED_RESULT."]
    #[doc = "@sa eyelink_node_send_message()"]
    pub fn eyelink_node_send_message_ex(
        exectime: UINT32,
        node: *mut byte,
        msg: *mut ::std::os::raw::c_char,
    ) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a text variable name whose value is to be read and returned by the tracker as a text string."]
    #[doc = ""]
    #[doc = "@remarks NEW (v2.1): If the link is initialized but not connected to a tracker, the message will"]
    #[doc = "be sent to the tracker set by \\c set_eyelink_address(). However, these requests will be"]
    #[doc = "ignored by tracker versions older than EyeLink I v2.1 and EyeLink II v1.1."]
    #[doc = "@param text String with message to send."]
    #[doc = "@return \\c 0 if success, otherwise link error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "int read_tracker_pixel_coords(void)"]
    #[doc = "{"]
    #[doc = "char buf[100] = \"\";"]
    #[doc = "UINT32 t;"]
    #[doc = ""]
    #[doc = "if(!eyelink_is_connected() || break_pressed())"]
    #[doc = "return 1;"]
    #[doc = ""]
    #[doc = "eyelink_read_request(\"screen_pixel_coords\");"]
    #[doc = ""]
    #[doc = "t = current_msec();"]
    #[doc = "while(current_msec()-t < 500)"]
    #[doc = "{"]
    #[doc = "if(eyelink_read_reply(buf) == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"%s\", buf);"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "message_pump(NULL);  // Keeps Windows happy"]
    #[doc = "if(!eyelink_is_connected) return 1;"]
    #[doc = "if(break_pressed()) return 1;"]
    #[doc = "}"]
    #[doc = "return -1;  // Timed out"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t374986 0.000000,0.000000,1023.000000,767.000000"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_read_reply()"]
    pub fn eyelink_read_request(text: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Returns text with reply to last read request."]
    #[doc = ""]
    #[doc = "@param buf String to contain text."]
    #[doc = "@return <tt>OK_RESULT (0)</tt> if response received.\\n"]
    #[doc = "\\c NO_REPLY if no response yet."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_read_request()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_read_request()"]
    pub fn eyelink_read_reply(buf: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Sends a request the connected eye tracker to return its current time."]
    #[doc = ""]
    #[doc = "@remarks The time reply can be read with \\c eyelink_read_time()."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT32 current_tracker_time()"]
    #[doc = "{"]
    #[doc = "UINT32  time_subject=0, time_tracker=0;"]
    #[doc = ""]
    #[doc = "eyelink_request_time();        // request the tracker PC time"]
    #[doc = "time_subject = current_msec();"]
    #[doc = "while(!time_tracker && current_msec() -time_subject < 50)"]
    #[doc = "time_tracker = eyelink_read_time();  // read tracker PC time"]
    #[doc = ""]
    #[doc = "return time_tracker;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_node_request_time() and \\c eyelink_read_time()"]
    #[doc = "@deprecated  This function is depricated. It is left for compatibility reasons."]
    pub fn eyelink_request_time() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Sends a request the connected eye tracker to return its current time."]
    #[doc = ""]
    #[doc = "@remarks The time reply can be read with \\c eyelink_read_time()."]
    #[doc = "@param node Address of a specific tracker."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_request_time()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_request_time() and \\c eyelink_read_time()"]
    pub fn eyelink_node_request_time(node: *mut byte) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the tracker time requested by \\c eyelink_request_time() or \\c eyelink_node_request_time()."]
    #[doc = ""]
    #[doc = "@return \\c 0 if no response yet,  else timestamp in millisecond."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_request_time()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_node_request_time() and \\c eyelink_request_time()"]
    pub fn eyelink_read_time() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Places EyeLink tracker in off-line (idle) mode."]
    #[doc = ""]
    #[doc = "@remarks Use before attempting to draw graphics on the tracker display,"]
    #[doc = "transferring files, or closing link. Always call \\c eyelink_wait_for_mode_ready()"]
    #[doc = "afterwards to ensure tracker has finished the mode transition. This function"]
    #[doc = "pair is implemented by the eyelink_exptkit library function \\c set_offline_mode()."]
    #[doc = "@return \\c 0 if mode switch begun, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"heuristic_filter = ON\");"]
    #[doc = "eyelink_abort();    // stop data flow"]
    #[doc = "eyelink_wait_for_mode_ready(500); // wait till finished mode switch"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_wait_for_mode_ready() and \\c set_offline_mode()"]
    pub fn eyelink_abort() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Enters setup mode"]
    pub fn eyelink_start_setup() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Checks if tracker is still in a Setup menu activity (includes camera image view, calibration,"]
    #[doc = "and validation).  Used to terminate the subject setup loop."]
    #[doc = ""]
    #[doc = "@return \\c 0 if no longer in setup mode."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int current_mode;"]
    #[doc = "int prev_mode =0;"]
    #[doc = "UINT start_time  = current_msec();"]
    #[doc = ""]
    #[doc = "while(current_msec() < start_time + 10000)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "current_mode =eyelink_in_setup();"]
    #[doc = "if (current_mode!=prev_mode)"]
    #[doc = "eyemsg_printf(\"%s\", current_mode?\"In setup\":\"Not in setup\");"]
    #[doc = ""]
    #[doc = "prev_mode = current_mode;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t905992 In setup"]
    #[doc = "MSG\t909596 Not in setup"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_current_mode()"]
    pub fn eyelink_in_setup() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Returns the current target position and state."]
    #[doc = ""]
    #[doc = "@param x Pointer to variable to hold target X position."]
    #[doc = "@param y Pointer to variable to hold target Y position."]
    #[doc = "@return \\c 1 if target is visible, 0 if not."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "INT16 target_mode_display(void)"]
    #[doc = "{"]
    #[doc = "int target_visible = 0;\t// target currently drawn"]
    #[doc = "INT16 tx;\t\t// new target position"]
    #[doc = "INT16 ty;"]
    #[doc = ""]
    #[doc = "INT16 otx=MISSING;    // current target position"]
    #[doc = "INT16 oty=MISSING;"]
    #[doc = ""]
    #[doc = "unsigned key;\t\t// local key pressed"]
    #[doc = "int i;"]
    #[doc = "int result = NO_REPLY;"]
    #[doc = ""]
    #[doc = "while(eyelink_current_mode() & IN_TARGET_MODE)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected()) return -1;"]
    #[doc = "key = getkey();"]
    #[doc = "if(key)"]
    #[doc = "{"]
    #[doc = "switch(key)"]
    #[doc = "{"]
    #[doc = "case TERMINATE_KEY:       // breakout key code"]
    #[doc = "clear_cal_display();"]
    #[doc = "return TERMINATE_KEY;"]
    #[doc = "case 32:\t         \t// Spacebar: accept fixation"]
    #[doc = "eyelink_accept_trigger();"]
    #[doc = "break;"]
    #[doc = "case 0: \t\t// No key"]
    #[doc = "case JUNK_KEY: \t// No key"]
    #[doc = "break;"]
    #[doc = "case ESC_KEY: if(eyelink_is_connected()==-1) goto exit;"]
    #[doc = "default:          // Echo to tracker for remote control"]
    #[doc = "if(allow_local_control)"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "result = eyelink_cal_result();"]
    #[doc = "if(result != NO_REPLY) break;"]
    #[doc = ""]
    #[doc = "i = eyelink_target_check(&tx, &ty);"]
    #[doc = "if( (target_visible && i==0) || tx!=otx || ty!=oty)"]
    #[doc = "{"]
    #[doc = "erase_cal_target();"]
    #[doc = "target_visible = 0;"]
    #[doc = "}"]
    #[doc = "if(!target_visible && i)"]
    #[doc = "{"]
    #[doc = "draw_cal_target(tx, ty);"]
    #[doc = ""]
    #[doc = "target_visible = 1;"]
    #[doc = "otx = tx;\t\t// record position for future tests"]
    #[doc = "oty = ty;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "exit:"]
    #[doc = ""]
    #[doc = "if(target_visible)"]
    #[doc = "erase_cal_target();   // erase target on exit"]
    #[doc = ""]
    #[doc = "clear_cal_display();"]
    #[doc = "return result;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_apply_driftcorr(), \\c eyelink_current_mode()"]
    #[doc = "and \\c eyelink_driftcorr_start()"]
    pub fn eyelink_target_check(x: *mut INT16, y: *mut INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Returns the current target position and state.  Same as eyelink_target_check() except this function returns data in floating point values."]
    #[doc = ""]
    #[doc = "@param x Pointer to variable to hold target X position."]
    #[doc = "@param y Pointer to variable to hold target Y position."]
    #[doc = "@return \\c 1 if target is visible, 0 if not."]
    pub fn eyelink_target_checkf(x: *mut f32, y: *mut f32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Triggers the EyeLink tracker to accept a fixation on a target, similar to the 'Enter'"]
    #[doc = "key or spacebar on the tracker."]
    #[doc = ""]
    #[doc = "@return \\c NO_REPLY if drift correction not completed yet.\\n"]
    #[doc = "<tt>OK_RESULT (0)</tt> if success.\\n"]
    #[doc = "<tt>ABORT_REPLY (27)</tt> if 'ESC' key aborted operation.\\n"]
    #[doc = "\\c -1 if operation failed.\\n"]
    #[doc = "\\c 1 if poor calibration or excessive validation error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_driftcorr_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_apply_driftcorr(), \\c eyelink_current_mode(), \\c eyelink_driftcorr_start()"]
    #[doc = "and \\c eyelink_target_check()"]
    pub fn eyelink_accept_trigger() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Sets the position of the drift correction target, and switches the tracker to"]
    #[doc = "drift-correction mode.  Should be followed by a call to \\c eyelink_wait_for_mode_ready()."]
    #[doc = ""]
    #[doc = "@param x X position of the target."]
    #[doc = "@param y Y position of the target."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "unsigned key;"]
    #[doc = "int result = 0;"]
    #[doc = "int x, y; // position of the drift correction target"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "eyecmd_printf(\"heuristic_filter = ON\");"]
    #[doc = "..."]
    #[doc = "while(getkey()) {};  // dump the keys"]
    #[doc = ""]
    #[doc = "eyelink_driftcorr_start(x, y); // start the drift correction"]
    #[doc = "do {"]
    #[doc = "result = eyelink_cal_result();"]
    #[doc = ""]
    #[doc = "key = getkey();"]
    #[doc = "switch(key)"]
    #[doc = "{"]
    #[doc = "case TERMINATE_KEY:  // breakout code"]
    #[doc = "return TERMINATE_KEY;"]
    #[doc = "case 0: \t\t// no key"]
    #[doc = "case JUNK_KEY: \t// no key"]
    #[doc = "break;"]
    #[doc = "case ESC_KEY:       // ESC key: we flag abort from our end"]
    #[doc = "result = 27;"]
    #[doc = "break;"]
    #[doc = "case 32: \t\t// Spacebar: we trigger ourselves"]
    #[doc = "eyelink_accept_trigger();"]
    #[doc = "break;"]
    #[doc = "default:"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "} while(result == NO_REPLY);"]
    #[doc = ""]
    #[doc = "if (result != 27 && result != -1)"]
    #[doc = "eyelink_apply_driftcorr();"]
    #[doc = "else"]
    #[doc = "; // Other code for handling"]
    #[doc = ""]
    #[doc = "return result;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger() and \\c eyelink_send_keybutton()"]
    pub fn eyelink_driftcorr_start(x: INT16, y: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Sets the position of the drift correction target, and switches the tracker to"]
    #[doc = "drift-correction mode.  Should be followed by a call to \\c eyelink_wait_for_mode_ready()."]
    #[doc = "Same as eyelink_driftcorr_start() except the x,y parameters take floating point values."]
    #[doc = ""]
    #[doc = "@param x X position of the target."]
    #[doc = "@param y Y position of the target."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "unsigned key;"]
    #[doc = "int result = 0;"]
    #[doc = "int x, y; // position of the drift correction target"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "eyecmd_printf(\"heuristic_filter = ON\");"]
    #[doc = "..."]
    #[doc = "while(getkey()) {};  // dump the keys"]
    #[doc = ""]
    #[doc = "eyelink_driftcorr_start(x, y); // start the drift correction"]
    #[doc = "do {"]
    #[doc = "result = eyelink_cal_result();"]
    #[doc = ""]
    #[doc = "key = getkey();"]
    #[doc = "switch(key)"]
    #[doc = "{"]
    #[doc = "case TERMINATE_KEY:  // breakout code"]
    #[doc = "return TERMINATE_KEY;"]
    #[doc = "case 0: \t\t// no key"]
    #[doc = "case JUNK_KEY: \t// no key"]
    #[doc = "break;"]
    #[doc = "case ESC_KEY:       // ESC key: we flag abort from our end"]
    #[doc = "result = 27;"]
    #[doc = "break;"]
    #[doc = "case 32: \t\t// Spacebar: we trigger ourselves"]
    #[doc = "eyelink_accept_trigger();"]
    #[doc = "break;"]
    #[doc = "default:"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "} while(result == NO_REPLY);"]
    #[doc = ""]
    #[doc = "if (result != 27 && result != -1)"]
    #[doc = "eyelink_apply_driftcorr();"]
    #[doc = "else"]
    #[doc = "; // Other code for handling"]
    #[doc = ""]
    #[doc = "return result;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger() and \\c eyelink_send_keybutton()"]
    pub fn eyelink_driftcorr_startf(x: f32, y: f32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Checks for a numeric result code returned by calibration, validation, or drift correction."]
    #[doc = ""]
    #[doc = "@return \\c NO_REPLY if drift correction not completed yet.\\n"]
    #[doc = "<tt>OK_RESULT (0)</tt> if success.\\n"]
    #[doc = "<tt>ABORT_REPLY (27)</tt> if 'ESC' key aborted operation.\\n"]
    #[doc = "\\c -1 if operation failed.\\n"]
    #[doc = "\\c 1 if poor calibration or excessive validation error.\\n"]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_driftcorr_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_apply_driftcorr(), \\c eyelink_cal_message() and"]
    #[doc = "\\c eyelink_driftcorr_start()"]
    pub fn eyelink_cal_result() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Applies the results of the last drift correction.  This is not done automatically after a"]
    #[doc = "drift correction, allowing the message returned by \\c eyelink_cal_message() to be examined first."]
    #[doc = ""]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_driftcorr_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_cal_result(), \\c eyelink_current_mode(), \\c eyelink_driftcorr_start()"]
    #[doc = "and \\c eyelink_target_check()"]
    pub fn eyelink_apply_driftcorr() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Returns text associated with result of last calibration, validation, or drift correction."]
    #[doc = "This usually specifies errors or other statistics."]
    #[doc = ""]
    #[doc = "@param msg Buffer to return back the message."]
    #[doc = "@return \\c 0 if no message since last command sent, else length of string."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "char message[256];"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{   // Check link often so we can exit if tracker stopped"]
    #[doc = "if(!eyelink_is_connected()) return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "error = do_drift_correct(SCRWIDTH/2, SCRHEIGHT/2, 1, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27) break;"]
    #[doc = "}"]
    #[doc = "eyelink_cal_message(message);"]
    #[doc = "eyemsg_printf(message);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t1896559 DRIFTCORRECT R RIGHT at 320,40  OFFSET 0.11 deg.  -1.0,-4.0 pix."]
    #[doc = "MSG\t1896560 drift_correction: 0.11 -1.00 -4.00"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_apply_driftcorr() and \\c eyelink_cal_result()"]
    pub fn eyelink_cal_message(msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "This function tests the current tracker mode, and returns a set of flags based of"]
    #[doc = "what the mode is doing.  The most useful flag using the EXPTSPPT toolkit is \\c IN_USER_MENU"]
    #[doc = "to test if the EyeLink Abort menu has been activated."]
    #[doc = ""]
    #[doc = "@return Set of bitflags that mark mode function:"]
    #[doc = "\\c IN_DISCONNECT_MODE if disconnected."]
    #[doc = "\\c IN_IDLE_MODE if off-line (Idle mode)."]
    #[doc = "\\c IN_SETUP_MODE if in Setup-menu related mode."]
    #[doc = "\\c IN_RECORD_MODE if tracking is in progress."]
    #[doc = "\\c IN_PLAYBACK_MODE if currently playing back data."]
    #[doc = "\\c IN_TARGET_MODE if in mode that requires a fixation target."]
    #[doc = "\\c IN_DRIFTCORR_MODE if in drift-correction."]
    #[doc = "\\c IN_IMAGE_MODE if displaying grayscale camera image."]
    #[doc = "\\c IN_USER_MENU if displaying Abort or user-defined menu."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Example: See \\c echo_key()"]
    #[doc = ""]
    #[doc = "\\sa \\c echo_key(), \\c eyelink_tracker_mode() and \\c eyelink_user_menu_selection()"]
    pub fn eyelink_current_mode() -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "Returns raw EyeLink mode numbers, defined in eyelink.h as EL_xxxx definitions."]
    #[doc = ""]
    #[doc = "@return Raw EyeLink mode, \\c -1 if link disconnected"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "void track_mode_loop(void)"]
    #[doc = "{"]
    #[doc = "int oldmode = -1;"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "int mode = eyelink_tracker_mode();"]
    #[doc = "unsigned key = getkey();"]
    #[doc = ""]
    #[doc = "if(key==27 || break_pressed() || !eyelink_is_connected())"]
    #[doc = "return;"]
    #[doc = "else if(key) // Echo to tracker"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = ""]
    #[doc = "if(mode == oldmode)"]
    #[doc = "continue;"]
    #[doc = "switch(mode)"]
    #[doc = "{"]
    #[doc = "case EL_RECORD_MODE:     // Recording mode"]
    #[doc = "break;"]
    #[doc = "case EL_IMAGE_MODE:      // Image mode"]
    #[doc = "break;"]
    #[doc = "case EL_SETUP_MENU_MODE: // Setup menu mode"]
    #[doc = "break;"]
    #[doc = "case EL_CALIBRATE_MODE:  // Calibration, validation, DC mode"]
    #[doc = "case EL_VALIDATE_MODE:"]
    #[doc = "case EL_DRIFT_CORR_MODE:"]
    #[doc = "break;"]
    #[doc = "case EL_OPTIONS_MENU_MODE: // Option menu mode"]
    #[doc = "break;"]
    #[doc = "default:"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "oldmode = mode;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_current_mode() and \\c eyelink_is_connected()"]
    pub fn eyelink_tracker_mode() -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "After a mode-change command is given to the EyeLink tracker, an additional"]
    #[doc = "5 to 30 milliseconds may be needed to complete mode setup.  Call this function"]
    #[doc = "after mode change functions."]
    #[doc = ""]
    #[doc = "@remarks If it does not return \\c 0, assume a tracker error has occurred."]
    #[doc = "@param maxwait Maximum milliseconds to wait for the mode to change."]
    #[doc = "@return \\c 0 if mode switching is done, else still waiting."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_data_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_start() and \\c set_offline_mode()"]
    pub fn eyelink_wait_for_mode_ready(maxwait: UINT32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "Checks for a user-menu selection, clears response for next call."]
    #[doc = ""]
    #[doc = "@return \\c 0 if no selection made since last call, else code of selection."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "i = eyelink_current_mode();"]
    #[doc = "if(i & IN_USER_MENU)     // handle user menu selections"]
    #[doc = "{"]
    #[doc = "switch(eyelink_user_menu_selection()"]
    #[doc = "{"]
    #[doc = "case 1:     // SETUP selected"]
    #[doc = "break;"]
    #[doc = "case 2:     // REPEAT trial"]
    #[doc = "return REPEAT_TRIAL;"]
    #[doc = "case 3:\t// SKIP trial"]
    #[doc = "return SKIP_TRIAL;"]
    #[doc = "case 4:\t// Abort experiment"]
    #[doc = "eyelink_abort();// this cleans up by erasing menu"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = "default:\t// no selection: continue"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_current_mode()"]
    pub fn eyelink_user_menu_selection() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Returns the divisor used to convert integer eye data to floating point data."]
    #[doc = ""]
    #[doc = "@return Divisor (usually 10)."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "UINT32 start_time;"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"screen_write_prescale = 10\");"]
    #[doc = ""]
    #[doc = "start_time = current_msec();"]
    #[doc = "while(current_msec() < start + 1000)"]
    #[doc = "if (eyelink_command_result() == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Position scalar %d\","]
    #[doc = "eyelink_position_prescaler());"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_position_prescaler() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Prepares link buffers to receive new data.  If \\c &lt;clear&gt; is nonzero, removes old data from buffer."]
    #[doc = ""]
    #[doc = "@param clear If clear is non-zero, any buffer data is discarded."]
    #[doc = "@return Always returns \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_in_data_block()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_status() and \\c eyelink_in_data_block()"]
    pub fn eyelink_reset_data(clear: INT16) -> INT16;
}
extern "C" {
    pub fn eyelink_data_status() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "Checks to see if framing events read from queue indicate that the data"]
    #[doc = "is in a block containing  samples, events, or both."]
    #[doc = ""]
    #[doc = "@remarks The first item in queue may not be a block start even, so this should"]
    #[doc = "be used in a loop while discarding items using \\c eyelink_get_next_data(NULL)."]
    #[doc = "NOTE: this function did not work reliably in versions of the SLL before"]
    #[doc = "v2.0 (did not detect end of blocks)."]
    #[doc = "@param samples If non-zero, check if in a block with samples."]
    #[doc = "@param events If non-zero, check if in a block with events."]
    #[doc = "@return \\c 0 if no data of either masked type is being sent."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_broadcast_open())"]
    #[doc = "{"]
    #[doc = "printf(\"Cannot open broadcast connection to tracker\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "eyelink_reset_data(1);"]
    #[doc = ""]
    #[doc = "eyelink_data_switch(RECORD_LINK_SAMPLES | RECORD_LINK_EVENTS);"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "if(escape_pressed() || break_pressed()) return;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);"]
    #[doc = "if(i == 0) continue;"]
    #[doc = ""]
    #[doc = "if(eyelink_in_data_block(1, 1))"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_status() and \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_in_data_block(samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "Reads and discards events in data queue until in a recording block.  Waits for up to"]
    #[doc = "\\c  &lt;timeout&gt; milliseconds for a block containing samples, events, or both to be"]
    #[doc = "opened.  Items in the queue are discarded until the block start events are found and"]
    #[doc = "processed.  This function will fail if both samples and events are selected but only"]
    #[doc = "one of link samples and events were enabled by \\c start_recording()."]
    #[doc = ""]
    #[doc = "@remarks This function did not work in versions previous to 2.0."]
    #[doc = "@param maxwait Time in milliseconds to wait."]
    #[doc = "@param samples If non-zero, check if in a block with samples."]
    #[doc = "@param events If non-zero, check if in a block with events."]
    #[doc = "@return \\c 0 if time expired without any data of masked types available."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(start_recording(1,1,1,1)!= 0)"]
    #[doc = "return -1;          // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "begin_realtime_mode(100);"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No link samples received!\");"]
    #[doc = "return TRIAL_ERROR;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = "switch(eye_used) // select eye, add annotation to EDF file"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:  // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_wait_for_block_start(maxwait: UINT32, samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Fetches next data item from link buffer.  Usually called with \\c &lt;buf&gt; = \\c NULL,"]
    #[doc = "and returns the data item type.  If the item is not wanted, simply ignore it."]
    #[doc = "Otherwise, call \\c eyelink_get_float_data() to read it into a buffer."]
    #[doc = ""]
    #[doc = "@param buf If \\c NULL, saves data, else copies integer data into buffer."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ALLF_DATA evt;        // buffer to hold sample and event data"]
    #[doc = "int eye_used = -1;    // indicates which eye's data to display"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = ""]
    #[doc = "switch(eye_used)"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:   // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "i = eyelink_get_next_data(NULL);"]
    #[doc = "if(i == FIXUPDATE)"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);"]
    #[doc = "if(evt.fe.eye == eye_used)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Fixupdate: avg_x %8.2f, y %8.2f, dur %d\","]
    #[doc = "evt.fe.gavx, evt.fe.gavy, evt.fe.entime-evt.fe.sttime);"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t30244970 Fixupdate: avg_x   863.10, y   244.10, dur 48"]
    #[doc = "MSG\t30245018 Fixupdate: avg_x   863.10, y   245.60, dur 48"]
    #[doc = "MSG\t30245070 Fixupdate: avg_x   863.10, y   247.30, dur 48"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_newest_float_sample()"]
    #[doc = "and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_next_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets an integer (unconverted) copy of the last/newest link data (sample or event)"]
    #[doc = "seen by \\c eyelink_get_next_data()."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer (\\c ISAMPLE, \\c IEVENT, or \\c ALL_DATA type)."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "ALLF_DATA evt;        // buffer to hold sample and event data"]
    #[doc = "int eye_used = -1;    // indicates which eye's data to display"]
    #[doc = "int i;"]
    #[doc = "UINT32 prev_event_time = -1;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);  // Checks for data from link"]
    #[doc = "if(i == ENDFIX)\t  // only process ENDFIX events"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);  // get a copy of the ENDFIX event"]
    #[doc = "if(evt.fe.eye == eye_used)\t// only process data from desired eye?"]
    #[doc = "eyemsg_printf(\"NEXT Event: %ld %ld\", evt.fe.sttime,"]
    #[doc = "evt.fe.entime);"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "i = eyelink_get_last_data(&evt);"]
    #[doc = "if (i == ENDFIX && evt.fe.eye == eye_used"]
    #[doc = "&& evt.fe.entime != prev_event_time)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"LAST Event: %ld %ld\", evt.fe.sttime, evt.fe.entime);"]
    #[doc = "prev_event_time = evt.fe.entime;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "SFIX L   7812616"]
    #[doc = "SFIX R   7812616"]
    #[doc = "EFIX L   7812616\t7813232\t620\t  124.7\t  274.0\t     50"]
    #[doc = "EFIX R   7812616\t7813232\t620\t  118.2\t  262.4\t     50"]
    #[doc = "SSACC L  7813236"]
    #[doc = "SSACC R  7813236"]
    #[doc = "MSG\t7813254 NEXT Event: 7812616 7813232"]
    #[doc = "MSG\t7813254 LAST Event: 7812616 7813232"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_next_data() and \\c eyelink_newest_float_sample()"]
    pub fn eyelink_get_last_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets an integer (unconverted) copy of the last/newest link data (sample or event)"]
    #[doc = "seen by \\c eyelink_get_next_data()."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer (\\c ISAMPLE, \\c ALL_DATA type)."]
    #[doc = "@return \\c 0 if no data, else \\c SAMPLE_TYPE."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "ISAMPLE isample;"]
    #[doc = "float x, y;\t\t // gaze position"]
    #[doc = ""]
    #[doc = "if(eyelink_newest_sample(NULL)>0)  // check for new sample update"]
    #[doc = "{"]
    #[doc = "eyelink_newest_sample(&isample);"]
    #[doc = ""]
    #[doc = "if (x!=MISSING_DATA)"]
    #[doc = "x = ((float) isample.gx[eye_used])/((float) eyelink_position_prescaler());    // yes: get gaze position from sample"]
    #[doc = "else"]
    #[doc = "x = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "if (y!=MISSING_DATA)"]
    #[doc = "y = ((float) isample.gy[eye_used])/((float) eyelink_position_prescaler());"]
    #[doc = "else"]
    #[doc = "y = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_get_sample() and \\c eyelink_newest_float_sample()"]
    pub fn eyelink_newest_sample(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Reads the last item fetched by \\c eyelink_get_next_data() into a buffer.  The event is"]
    #[doc = "converted to a floating-point format (\\c FSAMPLE or \\c FEVENT).  This can handle both samples"]
    #[doc = "and events.  The buffer type can be \\c ALLF_DATA for both samples and events, \\c FSAMPLE for"]
    #[doc = "a sample, or a specific event buffer."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer for floating-point data: type is \\c ALLF_DATA or \\c FSAMPLE."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_get_next_data()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_last_data(), \\c eyelink_get_next_data(), \\c eyelink_newest_float_sample()"]
    #[doc = "\\c eyelink_newest_double_sample() \\c eyelink_get_double_data() and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_float_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Reads the last item fetched by \\c eyelink_get_next_data() into a buffer.  The event is"]
    #[doc = "converted to a floating-point format with floating point time (\\c DSAMPLE or \\c DEVENT)."]
    #[doc = "This can handle both samples and events.  The buffer type can be \\c ALLD_DATA for both"]
    #[doc = "samples and events, \\c DSAMPLE for a sample, or a specific event buffer."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer for floating-point data: type is \\c ALLD_DATA or \\c DSAMPLE."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_get_next_data()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_last_data(), \\c eyelink_get_next_data(), \\c eyelink_newest_float_sample()"]
    #[doc = "\\c eyelink_newest_double_sample() \\c eyelink_get_float_data() and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_double_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Check if a new sample has arrived from the link.  This is the latest sample, not the"]
    #[doc = "oldest sample that is read by \\c eyelink_get_next_data(), and is intended to drive gaze"]
    #[doc = "cursors and gaze-contingent displays."]
    #[doc = "Typically the function is called with a \\c NULL buffer pointer, to test if new data has"]
    #[doc = "arrived.  If a value of \\c 1 is returned, the function is called with a \\c FSAMPLE buffer to"]
    #[doc = "get the new sample."]
    #[doc = ""]
    #[doc = "@param buf Pointer to sample buffer type \\c FSAMPLE.  If \\c NULL, just checks new-sample status."]
    #[doc = "@return \\c -1 if no samples, \\c 0 if no new data, \\c 1 if new sample."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "Example 1:"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ALLF_DATA evt;         // buffer to hold sample and event data"]
    #[doc = "int eye_used = 0;      // indicates which eye's data to display"]
    #[doc = "float x, y;\t\t// gaze position"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,0);"]
    #[doc = "if(error != 0) return error;   // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = ""]
    #[doc = "switch(eye_used)"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:   // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "while (1)"]
    #[doc = "{"]
    #[doc = "if(eyelink_newest_float_sample(NULL)>0)"]
    #[doc = "{"]
    #[doc = "eyelink_newest_float_sample(&evt);"]
    #[doc = ""]
    #[doc = "x = evt.fs.gx[eye_used];"]
    #[doc = "y = evt.fs.gy[eye_used];"]
    #[doc = ""]
    #[doc = "if(x!=MISSING_DATA && y!=MISSING_DATA && evt.fs.pa[eye_used]>0)"]
    #[doc = "eyemsg_printf(\"Sample: %ld %8.2f %8.2f\","]
    #[doc = "evt.fs.time, x, y);"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "<pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t23701980 EYE_USED 0 LEFT"]
    #[doc = "MSG\t23703426 Sample: 23703424   412.90   217.90"]
    #[doc = "MSG\t23703430 Sample: 23703426   433.20   216.20"]
    #[doc = "MSG\t23703430 Sample: 23703428   453.40   214.40"]
    #[doc = "MSG\t23703434 Sample: 23703430   473.60   212.60"]
    #[doc = "MSG\t23703434 Sample: 23703432   493.80   210.80"]
    #[doc = "MSG\t23703438 Sample: 23703434   514.00   209.00"]
    #[doc = "MSG\t23703438 Sample: 23703436   534.20   207.10"]
    #[doc = "MSG\t23703442 Sample: 23703438   554.30   205.20"]
    #[doc = "MSG\t23703442 Sample: 23703440   574.40   203.30"]
    #[doc = "MSG\t23703446 Sample: 23703442   594.50   201.30"]
    #[doc = "MSG\t23703446 Sample: 23703444   614.60   199.30"]
    #[doc = "MSG\t23703450 Sample: 23703446   634.70   197.20"]
    #[doc = "MSG\t23703450 Sample: 23703448   634.70   197.20"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "Example 2:"]
    #[doc = "eyecmd_printf(\"file_sample_data = LEFT,RIGHT,GAZE,AREA,HTARGET,GAZERES,STATUS,INPUT\");"]
    #[doc = "eyecmd_printf(\"link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,HTARGET,STATUS,INPUT\");"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if(eyelink_newest_float_sample(NULL)>0)"]
    #[doc = "{"]
    #[doc = "eyelink_newest_float_sample(&evt);   // get the sample"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"remote data %d %d %d %x\", evt.fs.hdata[0], evt.fs.hdata[1], evt.fs.hdata[2], evt.fs.hdata[3]);"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_get_sample() \\c eyelink_newest_double_sample() and \\c eyelink_newest_sample()"]
    pub fn eyelink_newest_float_sample(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Check if a new sample has arrived from the link.  This is the latest sample, not the"]
    #[doc = "oldest sample that is read by \\c eyelink_get_next_data(), and is intended to drive gaze"]
    #[doc = "cursors and gaze-contingent displays."]
    #[doc = "Typically the function is called with a \\c NULL buffer pointer, to test if new data has"]
    #[doc = "arrived.  If a value of \\c 1 is returned, the function is called with a \\c DSAMPLE buffer to"]
    #[doc = "get the new sample."]
    #[doc = ""]
    #[doc = "@param buf Pointer to sample buffer type \\c DSAMPLE.  If \\c NULL, just checks new-sample status."]
    #[doc = "@return \\c -1 if no samples, \\c 0 if no new data, \\c 1 if new sample."]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_get_sample() \\c eyelink_newest_float_sample() and \\c eyelink_newest_sample()"]
    pub fn eyelink_newest_double_sample(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "After calling \\c eyelink_wait_for_block_start(), or after at least one sample or"]
    #[doc = "eye event has been read, can be used to check which eyes data is available for."]
    #[doc = ""]
    #[doc = "@return One of these constants, defined in EYE_DATA.H:"]
    #[doc = "\\c LEFT_EYE if left eye data."]
    #[doc = "\\c RIGHT_EYE if right eye data."]
    #[doc = "\\c BINOCULAR if both left and right eye data."]
    #[doc = "\\c -1 if no eye data is available."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int eye_used = 0;      // indicates which eye's data to display"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = ""]
    #[doc = "switch(eye_used)"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:   // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t22157314 EYE_USED 0 LEFT"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_eye_available() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets sample data content flag (\\c 0 if not in sample block)."]
    pub fn eyelink_sample_data_flags() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Returns the event data content flags."]
    #[doc = ""]
    #[doc = "@remarks This will be \\c 0 if the data being read from queue is not in a block with events."]
    #[doc = "@return Event data content flags:"]
    #[doc = "\\c EVENT_VELOCITY if has velocity data."]
    #[doc = "\\c EVENT_PUPILSIZE if has pupil size data."]
    #[doc = "\\c EVENT_GAZERES if has gaze resolution."]
    #[doc = "\\c EVENT_STATUS if has status flags."]
    #[doc = "\\c EVENT_GAZEXY if has gaze xy position."]
    #[doc = "\\c EVENT_HREFXY if has head-ref xy position."]
    #[doc = "\\c EVENT_PUPILXY if has pupil xy position."]
    #[doc = "\\c FIX_AVG_ONLY if only avg. data to fixation events."]
    #[doc = "\\c START_TIME_ONLY if only start-time in start events."]
    #[doc = "\\c PARSEDBY_GAZE if how events were generated."]
    #[doc = "\\c PARSEDBY_HREF."]
    #[doc = "\\c PARSEDBY_PUPIL."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = "int error;"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,0);"]
    #[doc = "if(error != 0) return error;   // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_data(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No link samples received!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "emsg_printf(\"Event data%d Event type %d\","]
    #[doc = "eyelink_event_data_flags(), eyelink_event_type_flags());"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t2689937 Event data 26316 Event type 29760"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_event_type_flags()"]
    pub fn eyelink_event_data_flags() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "After at least one button or eye event has been read, can be used to check what type of"]
    #[doc = "events will be available."]
    #[doc = ""]
    #[doc = "@return A set of bit flags:"]
    #[doc = "\\c LEFTEYE_EVENTS if has left eye events."]
    #[doc = "\\c RIGHTEYE_EVENTS if has right eye events."]
    #[doc = "\\c BLINK_EVENTS if has blink events."]
    #[doc = "\\c FIXATION_EVENTS if has fixation events."]
    #[doc = "\\c FIXUPDATE_EVENTS if has fixation updates."]
    #[doc = "\\c SACCADE_EVENTS if has saccade events."]
    #[doc = "\\c MESSAGE_EVENTS if has message events."]
    #[doc = "\\c BUTTON_EVENTS if has button events."]
    #[doc = "\\c INPUT_EVENTS if has input port events."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_event_data_flags()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_event_data_flags()"]
    pub fn eyelink_event_type_flags() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Counts total items in queue: samples, events, or both."]
    #[doc = ""]
    #[doc = "@param samples If non-zero count the samples."]
    #[doc = "@param events If non-zero count the events."]
    #[doc = "@return Total number of samples and events is in the queue."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "int check_sample_event_status(int link_samples, int link_events)"]
    #[doc = "{"]
    #[doc = "UINT32 t = current_time();"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "while(current_time() < t + 300)"]
    #[doc = "{"]
    #[doc = "int arrived = 1;"]
    #[doc = "if((i=check_recording())!=0) return i;"]
    #[doc = ""]
    #[doc = "if(link_samples)"]
    #[doc = "if(eyelink_data_count(1,0)==0)"]
    #[doc = "arrived = 0;"]
    #[doc = ""]
    #[doc = "if(link_events)"]
    #[doc = "if(eyelink_data_count(0,1)==0)"]
    #[doc = "arrived = 0;"]
    #[doc = ""]
    #[doc = "if(arrived) return 0;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "<pre>"]
    pub fn eyelink_data_count(samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Waits for data to be received from the eye tracker.  Can wait for an event, a sample, or"]
    #[doc = "either.  Typically used after record start to check if data is being sent."]
    #[doc = ""]
    #[doc = "@param maxwait Time in milliseconds to wait for data."]
    #[doc = "@param samples If \\c 1, return when first sample available."]
    #[doc = "@param events If \\c 1, return when first event available."]
    #[doc = "@return \\c 1 if data is available. \\c 0 if timed out."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = "int error;"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,0);"]
    #[doc = "if(error != 0) return error;   // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_data(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No link samples received!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_wait_for_data(maxwait: UINT32, samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets an integer (unconverted) sample from end of queue, discards any events encountered."]
    #[doc = ""]
    #[doc = "@param sample Pointer to buffer (\\c ISAMPLE or \\c ALL_DATA type)."]
    #[doc = "@return \\c 0 if no data. \\c 1 if data retrieved."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ISAMPLE   isample; // INTEGER SAMPLE DATA"]
    #[doc = "int eye_used = 0;  // indicates which eye's data to display"]
    #[doc = "float x, y;\t\t   // gaze position"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "end_trial();"]
    #[doc = "return TRIAL_ERROR;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = "switch(eye_used) // select eye, add annotation to EDF file"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR: // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "i = eyelink_get_sample(&isample);"]
    #[doc = "if(i)"]
    #[doc = "{"]
    #[doc = "if (x!=MISSING_DATA)"]
    #[doc = "x = ((float) isample.gx[eye_used])/"]
    #[doc = "((float) eyelink_position_prescaler());"]
    #[doc = "else"]
    #[doc = "x = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "if (y!=MISSING_DATA)"]
    #[doc = "y = ((float) isample.gy[eye_used])/"]
    #[doc = "((float) eyelink_position_prescaler());"]
    #[doc = "else"]
    #[doc = "y = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Sample: %ld %6.2f %6.2f\", isample.time, x, y);"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t14839670 Sample: 14839666 539.20 372.60"]
    #[doc = "MSG\t14839670 Sample: 14839668 539.20 372.60"]
    #[doc = "MSG\t14839674 Sample: 14839670 539.20 372.60"]
    #[doc = "MSG\t14839674 Sample: 14839672 539.20 372.60"]
    #[doc = "MSG\t14839678 Sample: 14839674 547.90 367.60"]
    #[doc = "MSG\t14839678 Sample: 14839676 556.60 362.50"]
    #[doc = "MSG\t14839682 Sample: 14839678 565.30 357.40"]
    #[doc = "MSG\t14839682 Sample: 14839680 574.10 352.30"]
    #[doc = "MSG\t14839686 Sample: 14839682 582.80 347.20"]
    #[doc = "MSG\t14839686 Sample: 14839684 591.50 342.00"]
    #[doc = "MSG\t14839690 Sample: 14839686 600.30 336.80"]
    #[doc = "MSG\t14839690 Sample: 14839688 609.00 331.60"]
    #[doc = "MSG\t14839694 Sample: 14839690 617.80 326.40"]
    #[doc = "MSG\t14839694 Sample: 14839692 626.60 321.20"]
    #[doc = "MSG\t14839698 Sample: 14839694 635.30 315.90"]
    #[doc = "MSG\t14839698 Sample: 14839696 644.10 310.70"]
    #[doc = "MSG\t14839702 Sample: 14839698 652.90 305.40"]
    #[doc = "MSG\t14839702 Sample: 14839700 661.70 300.00"]
    #[doc = "MSG\t14839706 Sample: 14839702 670.50 294.70"]
    #[doc = "MSG\t14839706 Sample: 14839704 679.30 289.40"]
    #[doc = "MSG\t14839710 Sample: 14839706 688.10 284.00"]
    #[doc = "MSG\t14839710 Sample: 14839708 696.90 278.60"]
    #[doc = "MSG\t14839714 Sample: 14839710 705.80 273.20"]
    #[doc = "MSG\t14839714 Sample: 14839712 714.60 267.70"]
    #[doc = "MSG\t14839718 Sample: 14839714 723.40 262.30"]
    #[doc = "MSG\t14839718 Sample: 14839716 732.30 256.80"]
    #[doc = "MSG\t14839722 Sample: 14839718 741.20 251.30"]
    #[doc = "MSG\t14839722 Sample: 14839720 750.00 245.80"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_newest_float_sample() and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_sample(sample: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = ""]
    #[doc = "Sets what data from tracker will be accepted and placed in queue."]
    #[doc = ""]
    #[doc = "@remarks This does not start the tracker recording, and so can be used with"]
    #[doc = "\\c eyelink_broadcast_open().  It also does not clear old data from the"]
    #[doc = "queue.  The data is set with a bitwise OR of these flags:"]
    #[doc = "\\c RECORD_LINK_SAMPLES\t- send samples on link."]
    #[doc = "\\c RECORD_LINK_EVENTS\t- send events on link."]
    #[doc = "@param flags Bitwise OR flags."]
    #[doc = "@return \\c 0 if OK else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_in_data_block()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_in_data_block()"]
    pub fn eyelink_data_switch(flags: UINT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Switches tracker to Record mode, enables data types for recording to EDF file or sending to"]
    #[doc = "link.  These types are set with a bitwise OR of these flags:"]
    #[doc = "\\arg <tt>RECORD_FILE_SAMPLES (1)</tt> - only active if file open."]
    #[doc = "\\arg <tt>RECORD_FILE_EVENTS (2)</tt> - only active if file open."]
    #[doc = "\\arg <tt>RECORD_LINK_SAMPLES (4)</tt> - accept samples from link."]
    #[doc = "\\arg <tt>RECORD_LINK_EVENTS (8)</tt> - accept events from link."]
    #[doc = ""]
    #[doc = "@remarks If \\c &lt;lock&gt; is nonzero, the recording may only be terminated through"]
    #[doc = "\\c stop_recording() or \\c eyelink_data_stop(), or by the Abort menu"]
    #[doc = "(\\91Ctrl\\92 \\92Alt\\92 \\92A\\92 keys on the eye tracker).  If zero, the tracker 'ESC'"]
    #[doc = "key may be used to halt recording."]
    #[doc = "@param flags Bitwise OR of flags to control what data is recorded.  If \\c 0, recording will be stopped."]
    #[doc = "@param lock If nonzero, prevents 'ESC' key from ending recording."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "INT16 file_samples,  file_events, link_samples, link_events;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected()) \treturn ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "i = eyelink_data_start((file_samples?RECORD_FILE_SAMPLES:0) |"]
    #[doc = "(file_events?RECORD_FILE_EVENTS:0)   |"]
    #[doc = "(link_samples?RECORD_LINK_SAMPLES:0) |"]
    #[doc = "(link_events?RECORD_LINK_EVENTS:0) , 1);"]
    #[doc = ""]
    #[doc = "if(i) return i;"]
    #[doc = ""]
    #[doc = "i = eyelink_wait_for_mode_ready(500);"]
    #[doc = "if(i==0) return TRIAL_ERROR;"]
    #[doc = ""]
    #[doc = "if((i = check_recording())!=0)"]
    #[doc = "return i;"]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "eyelink_data_stop();"]
    #[doc = "eyelink_wait_for_mode_ready(500);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_stop(), \\c start_recording() and \\c stop_recording()"]
    pub fn eyelink_data_start(flags: UINT16, lock: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Places tracker in idle (off-line) mode, does not flush data from queue."]
    #[doc = ""]
    #[doc = "@remarks Should be followed by a call to \\c eyelink_wait_for_mode_ready()."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_data_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_start() and \\c eyelink_wait_for_mode_ready()"]
    pub fn eyelink_data_stop() -> INT16;
}
extern "C" {
    #[doc = " @ingroup playback"]
    #[doc = "Flushes data from queue and starts data playback.  An EDF file must be open and have at"]
    #[doc = "least one recorded trial.  Use \\c eyelink_wait_for_data() to wait for data: this will time"]
    #[doc = "out if the playback failed.  Playback begins from start of file or from just after the"]
    #[doc = "end of the next-but-last recording block.  Link data is determined by file contents,"]
    #[doc = "not by link sample and event settings."]
    #[doc = ""]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "set_offline_mode();           // set up eye tracker for playback"]
    #[doc = "eyelink_playback_start();     // start data playback"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(2000, 1, 1))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: playback data did not start!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "while(1)   // Loop while data available"]
    #[doc = "{"]
    #[doc = "if(escape_pressed() || break_pressed() ||"]
    #[doc = "eyelink_last_button_press(NULL))"]
    #[doc = "{"]
    #[doc = "eyelink_playback_stop(); // stop playback"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);   // check for new data item"]
    #[doc = "if(i==0)\t                       // 0: no new data"]
    #[doc = "{   // Checks if playback has completed"]
    #[doc = "if((eyelink_current_mode() & IN_PLAYBACK_MODE)==0) break;"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyelink_playback_stop();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_playback_stop() and \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_playback_start() -> INT16;
}
extern "C" {
    #[doc = " @ingroup playback"]
    #[doc = "Stops playback if in progress.  Flushes any data in queue."]
    #[doc = ""]
    #[doc = "@return \\c 0 if mode switched, else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_playback_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_playback_start() and \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_playback_stop() -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Request an image of \\c &lt;type&gt; with size less than or eqaul to \\c &lt;xsize&gt;"]
    #[doc = "and \\c &lt;ysize&gt;."]
    #[doc = ""]
    #[doc = "@return \\c 0 if sent OK, else send error code."]
    pub fn eyelink_request_image(type_: INT16, xsize: INT16, ysize: INT16) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Test image-reception status."]
    #[doc = "@return \\c 0 if not receiving, \\c -1 if aborted, \\c 1 if receiving."]
    pub fn eyelink_image_status() -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Forces image transmissin to halt."]
    pub fn eyelink_abort_image();
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Get data at start of new image."]
    #[doc = "@return \\c -1 if aborted/not in receive, \\c 0 if old palette, \\c 1 if new palette."]
    #[doc = "ptrs to size: may be NULL"]
    pub fn eyelink_image_data(xsize: *mut INT16, ysize: *mut INT16, type_: *mut INT16) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Gets unpacked line data."]
    #[doc = "@return \\c -1 if error/not rx, else line number."]
    pub fn eyelink_get_line(buf: *mut ::std::os::raw::c_void) -> INT16;
}
#[doc = " @internal"]
#[doc = ""]
#[doc = "image data and palette structure uses brightness ramp plus special colors"]
#[doc = "to compress and make remapping easier \tfits in old palette's 48-byte area"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMAGE_PALDATA {
    pub palette_id: byte,
    pub ncolors: byte,
    pub camera: byte,
    pub threshold: byte,
    pub flags: UINT16,
    pub image_number: UINT16,
    pub extra: [byte; 10usize],
    pub rfirst_color: byte,
    pub rfirst_brite: byte,
    pub rlast_color: byte,
    pub rlast_brite: byte,
    pub nspecial: INT16,
    pub spcolors: [IMAGE_PALDATA__bindgen_ty_1; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMAGE_PALDATA__bindgen_ty_1 {
    pub index: byte,
    pub r: byte,
    pub g: byte,
    pub b: byte,
}
#[test]
fn bindgen_test_layout_IMAGE_PALDATA__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_PALDATA__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IMAGE_PALDATA__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_PALDATA__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(IMAGE_PALDATA__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).r as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).g as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).b as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
}
#[test]
fn bindgen_test_layout_IMAGE_PALDATA() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_PALDATA>(),
        48usize,
        concat!("Size of: ", stringify!(IMAGE_PALDATA))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_PALDATA>(),
        2usize,
        concat!("Alignment of ", stringify!(IMAGE_PALDATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).palette_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(palette_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).ncolors as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).camera as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(camera)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).threshold as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).image_number as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(image_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).extra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rfirst_color as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rfirst_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rfirst_brite as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rfirst_brite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rlast_color as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rlast_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rlast_brite as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rlast_brite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).nspecial as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(nspecial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).spcolors as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(spcolors)
        )
    );
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Get palette: always ramp definition."]
    #[doc = "@return \\c -1 if no image in progress, \\c 0 if old, \\c 1 if new palette."]
    #[doc = ""]
    #[doc = "non-palette data in *pal may change even if 0 returned."]
    pub fn eyelink_get_palette(pal: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Reads any queued key or button events from tracker."]
    #[doc = ""]
    #[doc = "@remarks Any of the parameters(mods/state/kcode/time) can be null to ignore."]
    #[doc = "@param mods Pointer to variable to hold button number or key modifier (Shift, Alt and Ctrl key states)."]
    #[doc = "@param state Pointer to variable to hold key or button change (\\c KB_PRESS, \\c KB_RELEASE, or \\c KB_REPEAT)."]
    #[doc = "@param kcode Pointer to variable to hold key scan code."]
    #[doc = "@param time Pointer to a variable to hold tracker time of the key or button change."]
    #[doc = "@return Key character is key press/release/repeat, <tt>KB_BUTTON (0xFF00)</tt> if button press or release. \\c 0 if none."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT16 \tkey;"]
    #[doc = "INT16 \tstate;"]
    #[doc = ""]
    #[doc = "key = eyelink_read_keybutton(NULL, &state, NULL, NULL);"]
    #[doc = ""]
    #[doc = "if (key && state == KB_PRESS && key != KB_BUTTON)"]
    #[doc = "{"]
    #[doc = "if(key < 256 && isprint(key))"]
    #[doc = "eyemsg_printf(\"KEY '%c'\", key);"]
    #[doc = "else"]
    #[doc = "eyemsg_printf(\"WAITKEY 0x%04X\", key);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_send_keybutton()"]
    pub fn eyelink_read_keybutton(
        mods: *mut INT16,
        state: *mut INT16,
        kcode: *mut UINT16,
        time: *mut UINT32,
    ) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Sends a key or button event to tracker.  Only key events are handled for remote control."]
    #[doc = ""]
    #[doc = "@param code Key character, or <tt>KB_BUTTON (0xFF00)</tt> if sending button event."]
    #[doc = "@param mods Button number, or key modifier (Shift, Alt and Ctrl key states)."]
    #[doc = "@param state Key or button change (\\c KB_PRESS or \\c KB_RELEASE)."]
    #[doc = "@return \\c 0 if OK, else send link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "UINT16 echo_key(void)"]
    #[doc = "{"]
    #[doc = "UINT16 k = getkey();"]
    #[doc = ""]
    #[doc = "if(k!=0 && k!=1)"]
    #[doc = "eyelink_send_keybutton(k, 0, KB_PRESS);"]
    #[doc = "return k;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_read_keybutton()"]
    pub fn eyelink_send_keybutton(code: UINT16, mods: UINT16, state: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Returns a flag word with bits set to indicate which tracker buttons are currently pressed."]
    #[doc = "This is button 1 for the LSB, up to button 16 for the MSB."]
    #[doc = ""]
    #[doc = "@remarks Buttons above 8 are not realized on the EyeLink tracker."]
    #[doc = "@return Flag bits for buttons currently pressed."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int   state =0;"]
    #[doc = "int \tprev_state = 0;"]
    #[doc = "UINT32 start_time = current_time();"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected()"]
    #[doc = "&& current_time() > start_time + 5000)"]
    #[doc = "{"]
    #[doc = "state = eyelink_button_states();"]
    #[doc = "if (state != prev_state)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Button 1:%s 2:%s 3:%s 4:%s 5:%s\","]
    #[doc = "state & 0x01 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x02) >> 1 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x04) >> 2 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x08) >> 3 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x10) >> 4 ? \"Pressed\" : \"Released\");"]
    #[doc = ""]
    #[doc = "prev_state = state;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "BUTTON\t4144034\t1\t1"]
    #[doc = "MSG\t4144035 Button 1:Pressed 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4144266\t1\t0"]
    #[doc = "MSG\t4144267 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4144650\t2\t1"]
    #[doc = "MSG\t4144651 Button 1:Released 2:Pressed 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4144898\t2\t0"]
    #[doc = "MSG\t4144899 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4145260\t3\t1"]
    #[doc = "MSG\t4145261 Button 1:Released 2:Released 3:Pressed 4:Released 5:Released"]
    #[doc = "BUTTON\t4145492\t3\t0"]
    #[doc = "MSG\t4145493 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4145834\t4\t1"]
    #[doc = "MSG\t4145835 Button 1:Released 2:Released 3:Released 4:Pressed 5:Released"]
    #[doc = "BUTTON\t4146106\t4\t0"]
    #[doc = "MSG\t4146107 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4146498\t5\t1"]
    #[doc = "MSG\t4146499 Button 1:Released 2:Released 3:Released 4:Released 5:Pressed"]
    #[doc = "BUTTON\t4146778\t5\t0"]
    #[doc = "MSG\t4146779 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_last_button_press()"]
    pub fn eyelink_button_states() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Returns a flag word with bits set to indicate which tracker buttons are currently pressed."]
    #[doc = "This is button 1 for the LSB, up to button 16 for the MSB.  Same as eyelink_button_states()"]
    #[doc = "except, optionally time of the button states can be acquired."]
    #[doc = ""]
    #[doc = "@param[out] time pointer to return time of the button states."]
    #[doc = "@return Flag bits for buttons currently pressed."]
    #[doc = "\\sa \\c eyelink_send_keybutton()"]
    pub fn eyelink_last_button_states(time: *mut UINT32) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Reads the number of the last button detected by the EyeLink tracker.  This is \\c 0"]
    #[doc = "if no buttons were pressed since the last call, or since the buttons were flushed."]
    #[doc = "If a pointer to a variable is supplied the eye-tracker timestamp of the button may"]
    #[doc = "be read.  This could be used to see if a new button has been pressed since the last"]
    #[doc = "read.  If multiple buttons were pressed since the last call, only the last button"]
    #[doc = "is reported."]
    #[doc = ""]
    #[doc = "@param time Far pointer to a variable to hold tracker time of last button press."]
    #[doc = "Usually left as \\c NULL to ignore time."]
    #[doc = "@return Button last pressed, \\c 0 if no button pressed since last read, or call to \\c eyelink_flush_keybuttons()."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int   button;"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "button = eyelink_last_button_press(NULL);"]
    #[doc = ""]
    #[doc = "if(button != 0 && button != 6 && button != 7)"]
    #[doc = "{"]
    #[doc = "if (button == 5)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"ENDBUTTON %d\", button);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "else"]
    #[doc = "eyemsg_printf(\"BUTTON PRESSED %d\", button);"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "BUTTON\t19753748\t2\t1"]
    #[doc = "MSG\t19753749 BUTTON PRESSED 2"]
    #[doc = "BUTTON\t19754018\t2\t0"]
    #[doc = "BUTTON\t19755595\t5\t1"]
    #[doc = "MSG\t19755595 ENDBUTTON 5"]
    #[doc = "BUTTON\t19755808\t5\t0"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_flush_keybuttons(), \\c eyelink_button_states(), \\c eyelink_read_keybutton()"]
    #[doc = "and \\c eyelink_send_keybutton()"]
    pub fn eyelink_last_button_press(time: *mut UINT32) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Causes the EyeLink tracker and the EyeLink library to flush any stored button or key"]
    #[doc = "events.  This should be used before a trial to get rid of old button responses."]
    #[doc = "The \\c &lt;enable_buttons&gt; argument controls whether the EyeLink library will store"]
    #[doc = "button press and release events.  It always stores tracker key events.  Even if"]
    #[doc = "disabled, the last button pressed and button flag bits are updated."]
    #[doc = ""]
    #[doc = "@param enable_buttons Set to \\c 0 to monitor last button press only, \\c 1 to queue button events."]
    #[doc = "@return Always \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "UINT32 wait_time = 5000;"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "wait_time += current_msec();"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "if(getkey()==27 || !eyelink_is_connected())"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "i = eyelink_last_button_press(NULL);"]
    #[doc = "if(i)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"WAITBUTTON %d\", i);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if(current_time() > wait_time)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"WAITBUTTON TIMEOUT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "BUTTON\t19585661\t5\t1"]
    #[doc = "MSG\t19585662 WAITBUTTON 5"]
    #[doc = "BUTTON\t19586005\t5\t0"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_button_states(), \\c eyelink_last_button_press(), \\c eyelink_read_keybutton()"]
    #[doc = "and \\c eyelink_send_keybutton()"]
    pub fn eyelink_flush_keybuttons(enable_buttons: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Request send of file \"src\". If \"\", gets last data file."]
    #[doc = "@return \\c 0 if OK, else send error."]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_request_file_read(src: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Get next block of file.  If \\c &lt;offset&gt; is not \\c NULL, will be filled"]
    #[doc = "with block-start offset in file."]
    #[doc = ""]
    #[doc = "@return negative if error, \\c NO_REPLY if waiting for packet, else block size (0..512)."]
    #[doc = "size is < 512 (can be 0) if at EOF."]
    #[doc = ""]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_get_file_block(buf: *mut ::std::os::raw::c_void, offset: *mut INT32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Ask for next block of file, reads from \\c &lt;offset&gt;."]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_request_file_block(offset: UINT32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Aborts send of file."]
    #[doc = "@return \\c 0 if OK, else send error."]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_end_file_transfer() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "After connection, determines if the connected tracker is an EyeLink I or II."]
    #[doc = ""]
    #[doc = "@remarks For the EyeLink II tracker, it can optionally retrieve the tracker software version."]
    #[doc = "@param c \\c NULL, or pointer to a string (at least 40 characters) to hold the version string."]
    #[doc = "This will be \"EYELINK I\" or \"EYELINK II x.xx\", where \"x.xx\" is the software version."]
    #[doc = "@return \\c 0 if not connected, \\c 1 for EyeLink I, \\c 2 for EyeLink II \\c 3 for EyeLink 1000."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int i;"]
    #[doc = "char version_info[256];"]
    #[doc = ""]
    #[doc = "i = eyelink_get_tracker_version(version_info);"]
    #[doc = "eyemsg_printf(\"EyeLink %d version %s\", i, version_info);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t500850 EyeLink 2 version EYELINK II 1.10"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_get_tracker_version(c: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "\\deprecated Use \\c eyelink_mode_data() instead."]
    pub fn eyelink2_mode_data(
        sample_rate: *mut INT16,
        crmode: *mut INT16,
        file_filter: *mut INT16,
        link_filter: *mut INT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "After calling \\c eyelink_wait_for_block_start(), or after at least one sample or eye event has"]
    #[doc = "been read, returns EyeLink II extended mode data."]
    #[doc = ""]
    #[doc = "@param sample_rate \\c NULL, or pointer to variable to be filled with samples per second."]
    #[doc = "@param crmode \\c NULL, or pointer to variable to be filled with CR mode flag (\\c 0 if pupil-only mode,"]
    #[doc = "else pupil-CR mode)."]
    #[doc = "@param file_filter \\c NULL, or pointer to variable to be filled with filter level to be applied to"]
    #[doc = "file samples (\\c 0 = off, \\c 1 = std, \\c 2 = double filter)."]
    #[doc = "@param link_filter \\c NULL, or pointer to variable to be filled with filter level to be applied to"]
    #[doc = "link and analog output samples (\\c 0 = off, \\c 1 = std, \\c 2 = double filter)."]
    #[doc = "@return If no data available -1 else 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#inlcude <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "int is_eyelink2;"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(2000, 1, 1))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No sample or event been detected!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "is_eyelink2 = (2 == eyelink_get_tracker_version(NULL));"]
    #[doc = ""]
    #[doc = "if(is_eyelink2 && !eyelink2_mode_data(&sample_rate, &crmode, NULL, NULL))"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Sample rate: %d\", sample_rate);"]
    #[doc = "eyemsg_printf(\"Tracking mode: %s\", crmode?\"CR\":\"Pupil only\");"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t1151024 Sample rate: 250"]
    #[doc = "MSG\t1151024 Tracking mode: CR"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_mode_data(
        sample_rate: *mut INT16,
        crmode: *mut INT16,
        file_filter: *mut INT16,
        link_filter: *mut INT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Send bitmap data packet to tracker."]
    #[doc = "@remark This function is strictly internal. If you need to send bitmap to the tracker,"]
    #[doc = "use el_bitmap_to_backdrop(), gdi_bitmap_to_backdrop() or sdl_bitmap_to_backdrop()."]
    #[doc = "@param data pointer of the data to be sent."]
    #[doc = "@param size size of the data to be sent."]
    #[doc = "@param seq \\c 1 for first packet, increases thereafter."]
    pub fn eyelink_bitmap_packet(
        data: *mut ::std::os::raw::c_void,
        size: UINT16,
        seq: UINT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Get bitmap ack count."]
    #[doc = "Negative: special code or sequence number to restart at."]
    #[doc = "Reading resets count to 0."]
    #[doc = "@remark This function is strictly internal. If you need to send bitmap to the tracker,"]
    #[doc = "use el_bitmap_to_backdrop(), gdi_bitmap_to_backdrop() or sdl_bitmap_to_backdrop()."]
    pub fn eyelink_bitmap_ack_count() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = ""]
    #[doc = "Address used for non-connected time requests and message sends. the \"proper\""]
    #[doc = "way to do this is with the \"node\" type of functions but we allow a \"back door\""]
    #[doc = "to simplify higher level support functions.  This is also the address used"]
    #[doc = "under Windows for looking for tracker (an IP broadcast is used on all"]
    #[doc = "other platforms). There is a bug in the Windows networking, causing broadcasts"]
    #[doc = "sent on all cards to have the IP source addres of only the first card. This"]
    #[doc = "means the tracker sends its connection reply to the wrong address. So the exact"]
    #[doc = "address or a subnet broadcast address (i.e. 100.1.1.255 for a subnet mask of"]
    #[doc = "255.255.255.0) needs to be set to that of the tracker."]
    pub fn eyelink_set_tracker_node(node: *mut byte);
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the current tracker time (in micro seconds) since the tracker application started."]
    #[doc = ""]
    #[doc = "@return Each of these functions returns the current tracker time (in microseconds)"]
    #[doc = "since tracker initialization."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "int i;"]
    #[doc = "ALLF_DATA evt;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);   // Checks for new data item"]
    #[doc = "switch(i)"]
    #[doc = "{"]
    #[doc = "case SAMPLE_TYPE:"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);"]
    #[doc = "if(eyelink_tracker_double_usec()/1000000 >(evt.time +2) )"]
    #[doc = "printf(\"Oops it took longer than 2 milliseconds for the data to get"]
    #[doc = "here.\\n\");"]
    #[doc = "}"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_tracker_msec(), \\c current_time(), \\c eyelink_msec_offset() and"]
    #[doc = "\\c eyelink_double_usec_offset()"]
    #[doc = ""]
    pub fn eyelink_tracker_double_usec() -> f64;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the current tracker time (in milliseconds) since the tracker application started."]
    #[doc = ""]
    #[doc = "@return Each of these functions returns the current tracker time (in microseconds)"]
    #[doc = "since tracker initialization."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "int i;"]
    #[doc = "ALLF_DATA evt;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);   // Checks for new data item"]
    #[doc = "switch(i)"]
    #[doc = "{"]
    #[doc = "case SAMPLE_TYPE:"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);"]
    #[doc = "if(eyelink_tracker_msec()/1000 >(evt.time +2) )"]
    #[doc = "printf(\"Oops it took longer than 2 milliseconds for the data to get"]
    #[doc = "here.\\n\");"]
    #[doc = "}"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c current_time(), \\c eyelink_msec_offset(), \\c eyelink_double_usec_offset() and"]
    #[doc = "\\c eyelink_tracker_double_usec()"]
    pub fn eyelink_tracker_msec() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the time difference between the tracker time and display pc time."]
    #[doc = ""]
    #[doc = "@return Returns the time difference between the tracker time and display pc"]
    #[doc = "time in microseconds."]
    #[doc = ""]
    #[doc = "\\sa \\c current_time() and \\c eyelink_tracker_msec()"]
    pub fn eyelink_double_usec_offset() -> f64;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the time difference between the tracker time and display pc time."]
    #[doc = ""]
    #[doc = "@return Returns the time difference between the tracker time and display pc time."]
    #[doc = ""]
    #[doc = "\\sa \\c current_time(), \\c eyelink_tracker_msec() and \\c eyelink_tracker_double_usec()"]
    pub fn eyelink_msec_offset() -> UINT32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DISPLAYINFO {
    #[doc = "< left of display"]
    pub left: INT32,
    #[doc = "< top of display"]
    pub top: INT32,
    #[doc = "< right of display"]
    pub right: INT32,
    #[doc = "< bottom of display"]
    pub bottom: INT32,
    #[doc = "< width of display"]
    pub width: INT32,
    #[doc = "< height of display"]
    pub height: INT32,
    #[doc = "< bits per pixel"]
    pub bits: INT32,
    #[doc = "< total entries in palette (\\c 0 if not indexed display mode)"]
    pub palsize: INT32,
    #[doc = "< number of static entries in palette"]
    #[doc = "( \\c 0 if not indexed display mode)"]
    pub palrsvd: INT32,
    #[doc = "< pages supported"]
    pub pages: INT32,
    #[doc = "< refresh rate in Hz"]
    pub refresh: f32,
    #[doc = "< \\c 0 if Windows 95, \\c 1 if Windows NT"]
    pub winnt: INT32,
}
#[test]
fn bindgen_test_layout_DISPLAYINFO() {
    assert_eq!(
        ::std::mem::size_of::<DISPLAYINFO>(),
        48usize,
        concat!("Size of: ", stringify!(DISPLAYINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPLAYINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(DISPLAYINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).bits as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).palsize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(palsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).palrsvd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(palrsvd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).pages as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).refresh as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).winnt as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(winnt)
        )
    );
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Initializes the EyeLink library, and opens a connection to the EyeLink tracker."]
    #[doc = ""]
    #[doc = "@remarks By setting \\c &lt;mode&gt; to be \\c 1, the connection can be simulated for debugging"]
    #[doc = "purposes.  Only timing operations and simple tests should be done in simulation"]
    #[doc = "mode, and the Windows TCP/IP system must be installed.  This function is"]
    #[doc = "intended for networks where a single tracker is connected to the network."]
    #[doc = "@param mode Mode of connection:"]
    #[doc = "\\arg \\c 0, opens a connection with the eye tracker;"]
    #[doc = "\\arg \\c 1, will create a dummy connection for simulation;"]
    #[doc = "\\arg \\c -1, initializes the DLL but does not open a connection."]
    #[doc = "@return \\c 0 if success, else error code"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if (set_eyelink_address(\"100.1.1.7\"))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "close_eyelink_connection();      // disconnect from tracker"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c close_eyelink_connection(), \\c close_eyelink_system(), \\c eyelink_broadcast_open(),"]
    #[doc = "\\c eyelink_dummy_open(), \\c eyelink_open() and \\c eyelink_open_node()"]
    pub fn open_eyelink_connection(mode: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Closes any connection to the eye tracker, and closes the link."]
    #[doc = ""]
    #[doc = "@remarks NEW (v2.1):  Broadcast connections can be closed, but not to affect the eye tracker. If"]
    #[doc = "a non-broadcast (primary) connection is closed, all broadcast connections to the"]
    #[doc = "tracker are also closed."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c open_eyelink_connection()"]
    #[doc = ""]
    #[doc = "\\sa \\c open_eyelink_connection() and \\c eyelink_close()"]
    pub fn close_eyelink_connection();
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sets the IP address used for connection to the EyeLink tracker.  This is set to \"100.1.1.1\" in the DLL,"]
    #[doc = "but may need to be changed for some network configurations.  This must be set before attempting to open"]
    #[doc = "a connection to the tracker."]
    #[doc = ""]
    #[doc = "@remarks A \"broadcast\" address (\"255.255.255.255\") may be used if the tracker address is not known -"]
    #[doc = "this will work only if a single Ethernet card is installed, or if DLL version 2.1 or higher,"]
    #[doc = "and the latest tracker software versions (EyeLink I v2.1 or higher, and EyeLink II v1.1 or"]
    #[doc = "higher) are installed."]
    #[doc = "@param addr Pointer to a string containing a \"dotted\" 4-digit IP address."]
    #[doc = "@return \\c 0 if success, \\c -1 if could not parse address string."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "set_eyelink_address(\"100.1.1.1\");"]
    #[doc = ""]
    #[doc = "if (eyelink_open())"]
    #[doc = "return -1;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_open(), \\c eyelink_open_node(), \\c text_to_elinkaddr()"]
    pub fn set_eyelink_address(addr: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "Changes the multitasking proirity of current application"]
    #[doc = "Using THREAD_PRIORITY_ABOVE_NORMAL may reduce latency"]
    #[doc = "Reset priority with THREAD_PRIORITY_NORMAL"]
    #[doc = "Too high priority will stop the link from functioning!"]
    #[doc = "@deprecated  This function is depricated. It is left for compatibility reasons."]
    #[doc = "The implementation does nothing."]
    pub fn set_application_priority(priority: INT32) -> INT32;
}
extern "C" {
    #[doc = " allows messages to operate in loops"]
    #[doc = " returns nonzero if app terminated"]
    #[doc = " eats key events, places on key queue for getkey()"]
    #[doc = " getkey() and echo_key() also call this function"]
    #[doc = ""]
    #[doc = " calling this in loops allows Windows to process messages"]
    #[doc = " returns nonzero if application terminated (ALT-F4 sent to window)"]
    #[doc = " set <dialog_hook> to handle of modeless dialog"]
    #[doc = " in order to properly handle its messages as well"]
    #[doc = "Almost all experiments must run in a deterministic fashion, executing sequentially and in"]
    #[doc = "loops instead of the traditional Windows event-processing model.  However, Windows messages"]
    #[doc = "must still be dispatched for keyboard input and other events.  Calling \\c getkey() will dispatch"]
    #[doc = "messages and return keys.  The \\c message_pump() function also dispatches messages, but does"]
    #[doc = "not read the keys.  It can also handle messages for a modeless dialog box."]
    #[doc = ""]
    #[doc = "@return \\c 0 normally, \\c 1 if ALT-F4 or CTRL-C pressed, or if \\c terminal_break() called.  Any loops"]
    #[doc = "should exit in this case."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "The following two programs works together to show the use of \\c message_pump() function. In this"]
    #[doc = "case, writes a message to EDF file when the left mouse button is pressed."]
    #[doc = ""]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "message_pump(NULL);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "switch (message)"]
    #[doc = "{"]
    #[doc = "case WM_KEYDOWN:"]
    #[doc = "case WM_CHAR:"]
    #[doc = "process_key_messages(hwnd, message, wparam, lparam);"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "case WM_LBUTTONDOWN:"]
    #[doc = "eyemsg_printf(\"Left button is down\");"]
    #[doc = "break;"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t11661891 SYNCTIME 1"]
    #[doc = "MSG\t11662745 left button is down"]
    #[doc = "MSG\t11663048 left button is down"]
    #[doc = "BUTTON\t11665520\t4\t1"]
    #[doc = "MSG\t11665521 ENDBUTTON 4"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c pump_delay()"]
    pub fn message_pump() -> INT16;
}
extern "C" {
    #[doc = " @ingroup pump"]
    #[doc = "Similar to \\c message_pump(), but only processes keypresses."]
    #[doc = "This may help reduce latency."]
    pub fn key_message_pump() -> INT16;
}
extern "C" {
    #[doc = " Similar to msec_delay(), but allows Widows message process"]
    #[doc = " only allows message processing if delay > 20 msec"]
    #[doc = " does not process dialog box messages"]
    #[doc = "During calls to \\c msec_delay(), Windows is not able to handle messages.  One result of this is"]
    #[doc = "that windows may not appear.  This is the preferred delay function when accurate timing is"]
    #[doc = "not needed.  It calls \\c message_pump() until the last 20 milliseconds of the delay, allowing"]
    #[doc = "Windows to function properly.  In rare cases, the delay may be longer than expected.  It does"]
    #[doc = "not process modeless dialog box messages."]
    #[doc = ""]
    #[doc = "@param delay Number of milliseconds to delay."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "static void end_trial(void)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "end_realtime_mode();"]
    #[doc = "pump_delay(100);"]
    #[doc = ""]
    #[doc = "stop_recording();"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c msec_delay() and \\c message_pump()"]
    pub fn pump_delay(delay: UINT32);
}
extern "C" {
    #[doc = " Initializes and empties local key queue"]
    #[doc = "Initializes the key queue used by \\c getkey().  This should be called at the start of your"]
    #[doc = "program.  It may be called at any time to get rid any of old keys from the queue."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if (set_eyelink_address(\"100.1.1.7\"))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "flush_getkey_queue();   // initialize getkey() system"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "close_eyelink_connection();      // disconnect from tracker"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c read_getkey_queue()"]
    pub fn flush_getkey_queue();
}
extern "C" {
    #[doc = " Similar to getkey(), but doesnt call message pump"]
    #[doc = " Use to build message pump for your own window"]
    #[doc = "Reads keys from the key queue.  It is similar to \\c getkey(), but does not process Windows"]
    #[doc = "messages.  This can be used to build key-message handlers in languages other than C."]
    #[doc = ""]
    #[doc = "@remarks These functions are intended to support languages other than C or C++."]
    #[doc = "@return \\c 0 if no key pressed.\\n"]
    #[doc = "<tt> JUNK_KEY (1)</tt> if untranslatable key.\\n"]
    #[doc = "<tt>TERMINATE_KEY (0x7FFF)</tt> if CTRL-C is pressed, \\c terminal_break() was called,  or"]
    #[doc = "the program has been terminated with ALT-F4.\\n"]
    #[doc = "else, code of key if any key pressed."]
    #[doc = ""]
    #[doc = "\\sa \\c flush_getkey_queue()"]
    pub fn read_getkey_queue() -> UINT16;
}
extern "C" {
    #[doc = " Calls getkey(), also sends keys to tracker for remote control               *"]
    #[doc = " User implementation allows filtering of keys before sending                 *"]
    #[doc = " returns same codes as getkey()                                              *"]
    #[doc = "Checks for Windows keystroke events and dispatches messages; similar to \\c getkey(), but"]
    #[doc = "also sends keystroke to tracker."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, this call will not work in realtime mode at all,"]
    #[doc = "and will take several seconds to respond if graphics are being drawn"]
    #[doc = "continuously.  This function works well in realtime mode under Windows 2000."]
    #[doc = "@return \\c 0 if no key pressed, else key code.\\n"]
    #[doc = "\\c TERMINATE_KEY if CTRL-C held down or program has been terminated."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybutton();"]
    #[doc = "while(getkey());"]
    #[doc = ""]
    #[doc = "while(eyelink_current_mode() & IN_SETUP_MODE)"]
    #[doc = "{"]
    #[doc = "int i = eyelink_current_mode();"]
    #[doc = ""]
    #[doc = "if(i & IN_TARGET_MODE)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "else if(i & IN_IMAGE_MODE)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "echo_key();"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_read_keybutton(), \\c eyelink_send_keybutton() and \\c getkey()"]
    pub fn echo_key() -> UINT16;
}
extern "C" {
    #[doc = " EYELINK tracker (MS-DOS) key scan equivalent"]
    #[doc = " Processes Windows messages, records key events"]
    #[doc = " Returns 0 if no key pressed"]
    #[doc = " returns 1-255 for non-extended keys"]
    #[doc = " returns 0x##00 for extended keys (##=hex code)"]
    #[doc = "A routine for checking for Windows keystroke events, and dispatching Windows messages."]
    #[doc = "If no key is pressed or waiting, it returns \\c 0.  For a standard ASCII key, a value from"]
    #[doc = "\\c 31 to \\c 127 is returned.  For extended keys, a special key value is returned.  If the"]
    #[doc = "program has been terminated by ALT-F4 or a call to \\c terminal_break(), or the \"Ctrl\" and"]
    #[doc = "\"C\" keys are held down, the value \\c TERMINATE_KEY is returned.  The value <tt>JUNK_KEY (1)</tt>"]
    #[doc = "is returned if a non-translatable key is pressed."]
    #[doc = "@remarks Warning: This function processes and dispatches any waiting messages.  This"]
    #[doc = "will allow Windows to perform disk access and negates the purpose of"]
    #[doc = "realtime mode.  Usually these delays will be only a few milliseconds, but"]
    #[doc = "delays over 20 milliseconds have been observed.  You may wish to call"]
    #[doc = "\\c escape_pressed() or \\c break_pressed() in recording loops instead of \\c getkey()"]
    #[doc = "if timing is critical, for example in a gaze-contingent display.  Under"]
    #[doc = "Windows XP and later, for single core system, these calls will not work in realtime mode at all (although"]
    #[doc = "these do work under Windows 2000).  Under Windows 95/98/Me, realtime"]
    #[doc = "performance is impossible even with this strategy.\\n"]
    #[doc = "Some useful keys are defined in core_expt.h, as:\\n"]
    #[doc = "\\arg \\c CURS_UP    \t\t\\c 0x4800"]
    #[doc = "\\arg \\c CURS_DOWN  \t\t\\c 0x5000"]
    #[doc = "\\arg \\c CURS_LEFT  \t\t\\c 0x4B00"]
    #[doc = "\\arg \\c CURS_RIGHT \t\t\\c 0x4D00"]
    #[doc = "\\arg \\c ESC_KEY   \t\t\\c 0x001B"]
    #[doc = "\\arg \\c ENTER_KEY \t\t\\c 0x000D"]
    #[doc = "\\arg \\c TERMINATE_KEY \t\\c 0x7FFF"]
    #[doc = "\\arg \\c JUNK_KEY \t\t\\c 0x0001"]
    #[doc = "@return \\c 0 if no key pressed, else key code.\\n"]
    #[doc = "\\c TERMINATE_KEY if CTRL-C held down or program has been terminated."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "UINT32  delay_time = 5000L;  // Set the maximum wait time"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "delay_time += current_msec();"]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(current_time() > delay_time)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"WAITKEY TIMEOUT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "key = getkey();"]
    #[doc = "if(key) // If key press occurs"]
    #[doc = "{"]
    #[doc = "if(key < 256 && isprint(key))"]
    #[doc = "eyemsg_printf(\"WAITKEY '%c'\", key);"]
    #[doc = "else"]
    #[doc = "eyemsg_printf(\"WAITKEY 0x%04X\", key);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c break_pressed(), \\c echo_key(), \\c escape_pressed(), \\c eyelink_flush_keybuttons()"]
    #[doc = "and \\c eyelink_send_keybutton()"]
    pub fn getkey() -> UINT16;
}
extern "C" {
    #[doc = "@ingroup keyinput"]
    #[doc = "Same as getkey except it returns the modifier and the key pressed."]
    #[doc = "It returns a 32 bit unsigned integer. The first 16 bits are reserved for the modifier and the"]
    #[doc = "last 16 bits are reserved for the key values. If there are no modifiers present,"]
    #[doc = "the return value of this is the same as getkey()."]
    #[doc = "If non null pointer passed in for unicode, the translated key value will be set if a key is preent."]
    pub fn getkey_with_mod(unicode: *mut UINT16) -> UINT32;
}
extern "C" {
    #[doc = " link command formatting                                                     *"]
    #[doc = " use just like printf()                                                      *"]
    #[doc = " returns command result                                                      *"]
    #[doc = " allows 500 msec. for command to finish                                      *"]
    #[doc = "The EyeLink tracker accepts text commands through the link.  These commands may be used"]
    #[doc = "to configure the system, open data files, and so on."]
    #[doc = ""]
    #[doc = "@remarks The function waits up to 500 msec. for a success or failure code to be returned"]
    #[doc = "from the tracker, then returns the error code \\c NO_REPLY.  If you need more"]
    #[doc = "time, use \\c eyelink_timed_command() instead."]
    #[doc = "@param fmt Similar to printf(), format string plus arguments."]
    #[doc = "@return \\c 0 if successfully executed, else error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT32 t = current_msec();"]
    #[doc = "int i, j;"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"draw_box %d %d %d %d  7\", 100, 100, 300, 400);"]
    #[doc = ""]
    #[doc = "while(current_msec()-t < 1000)"]
    #[doc = "{"]
    #[doc = "i = eyelink_command_result();"]
    #[doc = "j = eyelink_last_message(buf);"]
    #[doc = ""]
    #[doc = "if (i == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Command executed successfully: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "else if (i!=NO_REPLY)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Error in executing command: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t5312110 Command executed successfully: OK"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyemsg_printf(), \\c eyelink_send_command() and \\c eyelink_timed_command()"]
    #[doc = ""]
    pub fn eyecmd_printf(fmt: *const ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " link message formatting                                                     *"]
    #[doc = " use just like printf()                                                      *"]
    #[doc = " returns any send error                                                      *"]
    #[doc = "This sends a text message to the EyeLink tracker, which timestamps it and writes it to"]
    #[doc = "the EDF data file.  Messages are useful for recording trial conditions, subject responses,"]
    #[doc = "or the time of important events.  This function is used with the same formatting methods"]
    #[doc = "as printf(), allowing numbers to be included.  Avoid end-of-line characters (\"\\n\") at"]
    #[doc = "end of messages."]
    #[doc = ""]
    #[doc = "@param fmt Similar to printf(), format string plus arguments."]
    #[doc = "@return \\c 0 if successfully sent to tracker, else error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "char program_name[100] = \"Windows Sample Experiment 2.0\";"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"RECORDED BY %s\", program_name);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t2248248 RECORDED BY Windows Sample Experiment 2.0"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyecmd_printf()"]
    pub fn eyemsg_printf(fmt: *const ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "This allows us to send messages to the Eyelink tracker to be logged into"]
    #[doc = "the data file with a time offset.  Use it just like printf() to format the message text."]
    #[doc = ""]
    #[doc = "@param exectime time offset that reflects in the message's time stamp"]
    #[doc = "@param fmt printf format string"]
    #[doc = "@return \\c 0 if OK, else error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0) !=0)"]
    #[doc = "return 0;"]
    #[doc = "open_data_file(\"msgtest.edf\");"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"hello\");"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf_ex(-100,\"hello1\");"]
    #[doc = "msec_delay(100);"]
    #[doc = ""]
    #[doc = "eyemsg_printf_ex(100,\"hello2\");"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf(\"hello3\");"]
    #[doc = "msec_delay(100);"]
    #[doc = "close_data_file();"]
    #[doc = "receive_data_file(\"\",\".\",1);"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = "As you can see in the edf file data generated by the above code, both"]
    #[doc = "Message1 and Message2 has the same time stamp and message3 and message4 has the"]
    #[doc = "same time stamp."]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "MSG     8004932 Message1"]
    #[doc = "MSG     8004932 Message2"]
    #[doc = "MSG     8005232 Message3"]
    #[doc = "MSG     8005232 Message4"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn eyemsg_printf_ex(exectime: UINT32, fmt: *const ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " Start recording with data types requested                                   *"]
    #[doc = " Check that all requested link data is arriving                              *"]
    #[doc = " return 0 if OK, else trial exit code                                        *"]
    #[doc = "Starts the EyeLink tracker recording, sets up link for data reception if enabled."]
    #[doc = ""]
    #[doc = "@remarks Recording may take 10 to 30 milliseconds to begin from this command.  The function"]
    #[doc = "also waits until at least one of all requested link data types have been received."]
    #[doc = "If the return value is not zero, return the result as the trial result code."]
    #[doc = "@param file_samples If \\c 1, writes samples to EDF file.  If \\c 0, disables sample recording."]
    #[doc = "@param file_events If \\c 1, writes events to EDF file.  If \\c 0, disables event recording."]
    #[doc = "@param link_samples If \\c 1, sends samples through link.  If \\c 0, disables link sample access."]
    #[doc = "@param link_events If \\c 1, sends events through link.  If \\c 0, disables link event access."]
    #[doc = "@return \\c 0 if successful, else trial return code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,0,0);"]
    #[doc = "if(error != 0)  return error;"]
    #[doc = ""]
    #[doc = "begin_realtime_mode(100);"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if((error=check_recording())!=0) return error;"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "end_realtime_mode();"]
    #[doc = "pump_delay(100);"]
    #[doc = "stop_recording();"]
    #[doc = ""]
    #[doc = "while(getkey());          // dump any accumulated key presses"]
    #[doc = ""]
    #[doc = "return check_record_exit();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c check_record_exit(), \\c check_recording(), \\c eyelink_data_start() and \\c stop_recording()"]
    pub fn start_recording(
        file_samples: INT16,
        file_events: INT16,
        link_samples: INT16,
        link_events: INT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " Check if we are recording: if not, report an error                          *"]
    #[doc = " Also calls record_abort_hide() if recording aborted                         *"]
    #[doc = " Returns 0 if recording in progress                                          *"]
    #[doc = " Returns ABORT_EXPT if link disconnected                                     *"]
    #[doc = " Handles recors abort menu if trial interrupted                              *"]
    #[doc = " Returns TRIAL_ERROR if other non-recording state                            *"]
    #[doc = " Typical use is                                                              *"]
    #[doc = "   if((error=check_recording())!=0) return error;                            *"]
    #[doc = "Check if we are recording: if not, report an error.  Call this function while recording."]
    #[doc = "It will return \\c 0 if recording is still in progress, or an error code if not.  It will"]
    #[doc = "also handle the EyeLink Abort menu by calling \\c record_abort_handler().  Any errors returned"]
    #[doc = "by this function should be returned by the trial function.  On error, this will disable"]
    #[doc = "realtime mode and restore the heuristic."]
    #[doc = ""]
    #[doc = "@return <tt>TRIAL_OK (0)</tt> if no error.\\n"]
    #[doc = "<tt>REPEAT_TRIAL, SKIP_TRIAL, ABORT_EXPT, TRIAL_ERROR</tt> if recording aborted."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c start_recording()"]
    #[doc = ""]
    #[doc = "\\sa \\c check_record_exit(), \\c eyelink_abort(), \\c start_recording() and \\c stop_recording()"]
    pub fn check_recording() -> INT16;
}
extern "C" {
    #[doc = " halt recording, return when tracker finished mode switch"]
    #[doc = "Stops recording, resets EyeLink data mode."]
    #[doc = ""]
    #[doc = "@remarks Call 50 to 100 msec after an event occurs that ends the trial.  This function"]
    #[doc = "waits for mode switch before returning."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c start_recording()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_stop(), \\c set_offline_mode() and \\c start_recording()"]
    pub fn stop_recording();
}
extern "C" {
    #[doc = " enter tracker idle mode, wait  till finished mode switch                    *"]
    #[doc = "Places EyeLink tracker in off-line (idle) mode."]
    #[doc = "Wait till the tracker has finished the mode transition."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "set_offline_mode();"]
    #[doc = "eyecmd_printf(\"close_data_file\");    // close data file"]
    #[doc = "eyelink_close(1);         // disconnect from tracker"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "close_eyelink_system();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_abort()"]
    pub fn set_offline_mode();
}
extern "C" {
    #[doc = " call at end of trial, return result                                         *"]
    #[doc = " check if we are in Abort menu after recording stopped                       *"]
    #[doc = " returns trial exit code                                                     *"]
    #[doc = "Checks if we are in Abort menu after recording stopped and returns trial exit code. Call this"]
    #[doc = "function on leaving a trial.  It checks if the EyeLink tracker is displaying the Abort menu, and"]
    #[doc = "handles it if required.  The return value from this function should be returned as the trial"]
    #[doc = "result code."]
    #[doc = ""]
    #[doc = "@return \\c TRIAL_OK if no error.\\n"]
    #[doc = "<tt>REPEAT_TRIAL, SKIP_TRIAL, ABORT_EXPT</tt> if Abort menu activated."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c start_recording()"]
    #[doc = ""]
    #[doc = "\\sa \\c check_recording(), \\c eyelink_abort(), \\c start_recording() and \\c stop_recording()"]
    pub fn check_record_exit() -> INT16;
}
extern "C" {
    #[doc = "CALIBRATION, DRIFT CORRECTION CONTROL"]
    #[doc = " Call this to stop calibration/drift correction in progress"]
    #[doc = " This could be called from a Windows message handler"]
    #[doc = "This function should be called from an message or event handler if an ongoing call to"]
    #[doc = "\\c do_drift_correct() or \\c do_tracker_setup() should return immediately."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "switch (message)"]
    #[doc = "{"]
    #[doc = "case WM_KEYDOWN:"]
    #[doc = "case WM_CHAR:"]
    #[doc = "{"]
    #[doc = "UINT16 key = process_key_messages(hwnd, message, wparam, lparam);"]
    #[doc = "eyemsg_printf(\"key %d\", key);"]
    #[doc = ""]
    #[doc = "if (key == 0x5100 && (eyelink_current_mode() & IN_SETUP_MODE))"]
    #[doc = "exit_calibration();"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup(), \\c do_drift_correct() and \\c eyelink_current_mode()"]
    pub fn exit_calibration();
}
extern "C" {
    #[doc = " Starts tracker into Setup Menu.                                             *"]
    #[doc = " From this the operator can do camera setup, calibrations, etc.              *"]
    #[doc = " Pressing ESC on the tracker exits.                                          *"]
    #[doc = " Leaving the setup menu on the tracker (ESC) key) also exits.                *"]
    #[doc = " RETURNS: 0 if OK, 27 if aborted, TERMINATE_KEY if pressed                   *"]
    #[doc = "Switches the EyeLink tracker to the Setup menu, from which camera setup, calibration,"]
    #[doc = "validation, drift correction, and configuration may be performed. Pressing the 'ESC' key on"]
    #[doc = "the tracker keyboard will exit the Setup menu and return from this function.  Calling"]
    #[doc = "\\c exit_calibration() from an event handler will cause any call to \\c do_tracker_setup() in"]
    #[doc = "progress to return immediately."]
    #[doc = ""]
    #[doc = "@return Always \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "COLORREF target_foreground_color = RGB(0,0,0);"]
    #[doc = "COLORREF target_background_color = RGB(255,255,255);"]
    #[doc = "int i = SCRWIDTH/60;     // Selects best size for calibration target"]
    #[doc = "int j = SCRWIDTH/300;    // Selects size for focal spot in target"]
    #[doc = "if(j < 2) j = 2;"]
    #[doc = ""]
    #[doc = "set_target_size(i, j);"]
    #[doc = ""]
    #[doc = "set_calibration_colors(target_foreground_color, target_background_color);"]
    #[doc = ""]
    #[doc = "set_cal_sounds(\"\", \"\", \"\");"]
    #[doc = "set_dcorr_sounds(\"\", \"off\", \"off\");"]
    #[doc = ""]
    #[doc = "do_tracker_setup();"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_drift_correct(), \\c set_cal_sounds(), \\c set_calibration_colors() and \\c set_target_size()"]
    pub fn do_tracker_setup() -> INT16;
}
extern "C" {
    #[doc = "PERFORM DRIFT CORRECTION ON TRACKER"]
    #[doc = " Performs a drift correction, with target at (x,y).                          *"]
    #[doc = " If operator aborts with ESC, we assume there's a setup                      *"]
    #[doc = " problem and go to the setup menu (which may clear the                       *"]
    #[doc = " display).  Redraw display if needed and repeat the                          *"]
    #[doc = " call to  do_drift_correct() in this case.                                   *"]
    #[doc = " ARGS: x, y: position of target                                              *"]
    #[doc = "       draw: draws target if 1, 0 if you draw target first                   *"]
    #[doc = "       allow_setup: 0 disables ESC key setup mode entry                      *"]
    #[doc = " RETURNS: 0 if OK, 27 if Setup was called, TERMINATE_KEY if pressed          *"]
    #[doc = "Performs a drift correction before a trial."]
    #[doc = ""]
    #[doc = "@remarks When the 'ESC' key is pressed during drift correction, \\c &lt;allow_setup&gt; determines"]
    #[doc = "the result.  If \\c 1, the EyeLink Setup menu is accessed. This will always clear"]
    #[doc = "the display, so redrawing of hidden stimuli may be required.  Otherwise, the drift"]
    #[doc = "correction is aborted. Calling \\c exit_calibration() from an event handler will cause"]
    #[doc = "any call to \\c do_drift_correct() in progress to return immediately.  In all cases,"]
    #[doc = "the return code will be \\c 27 (\\c ESC_KEY)."]
    #[doc = "@param x X Position of drift correction target."]
    #[doc = "@param y Y Position of drift correction target."]
    #[doc = "@param draw If \\c 1, the drift correction will clear the screen to the target background color,"]
    #[doc = "draw the target, and clear the screen again when the drift correction is done."]
    #[doc = "If \\c 0, the fixation target must be drawn by the user."]
    #[doc = "@param allow_setup If \\c 1, accesses Setup menu before returning, else aborts drift correction."]
    #[doc = "@return \\c 0 if successful, \\c 27 if 'ESC' key was pressed to enter Setup menu or abort."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int target_shown = 0;"]
    #[doc = "int draw_own_target = 1;"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "if (draw_own_target && !target_shown)"]
    #[doc = "{"]
    #[doc = "target_shown = 1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "error = do_drift_correct(SCRWIDTH/2, SCRHEIGHT/2,"]
    #[doc = "draw_own_target, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27)"]
    #[doc = "break;"]
    #[doc = "else"]
    #[doc = "target_shown = 0;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup() and \\c set_dcorr_sounds()"]
    pub fn do_drift_correct(x: INT16, y: INT16, draw: INT16, allow_setup: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Performs a drift correction before a trial. Same as do_drift_correct() except, this takes the x,y values as float."]
    #[doc = ""]
    #[doc = "@remarks When the 'ESC' key is pressed during drift correction, \\c &lt;allow_setup&gt; determines"]
    #[doc = "the result.  If \\c 1, the EyeLink Setup menu is accessed. This will always clear"]
    #[doc = "the display, so redrawing of hidden stimuli may be required.  Otherwise, the drift"]
    #[doc = "correction is aborted. Calling \\c exit_calibration() from an event handler will cause"]
    #[doc = "any call to \\c do_drift_correct() in progress to return immediately.  In all cases,"]
    #[doc = "the return code will be \\c 27 (\\c ESC_KEY)."]
    #[doc = "@param x X Position of drift correction target."]
    #[doc = "@param y Y Position of drift correction target."]
    #[doc = "@param draw If \\c 1, the drift correction will clear the screen to the target background color,"]
    #[doc = "draw the target, and clear the screen again when the drift correction is done."]
    #[doc = "If \\c 0, the fixation target must be drawn by the user."]
    #[doc = "@param allow_setup If \\c 1, accesses Setup menu before returning, else aborts drift correction."]
    #[doc = "@return \\c 0 if successful, \\c 27 if 'ESC' key was pressed to enter Setup menu or abort."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int target_shown = 0;"]
    #[doc = "int draw_own_target = 1;"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "if (draw_own_target && !target_shown)"]
    #[doc = "{"]
    #[doc = "target_shown = 1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "error = do_drift_correctf(SCRWIDTH/2, SCRHEIGHT/2,"]
    #[doc = "draw_own_target, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27)"]
    #[doc = "break;"]
    #[doc = "else"]
    #[doc = "target_shown = 0;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup() and \\c set_dcorr_sounds()"]
    pub fn do_drift_correctf(x: f32, y: f32, draw: INT16, allow_setup: INT16) -> INT16;
}
extern "C" {
    #[doc = " (USED BY do_tracker_setup(), YOU DO NOT NEED TO CALL normally               *"]
    #[doc = " Called for you by do_tracker_setup() and do_drift_correct()                 *                 *"]
    #[doc = "This function needs some \"helper\" graphics to clear the scren and draw the"]
    #[doc = "fixation targets.  Since C graphics are compiler-dependent, these are found"]
    #[doc = "in other C source files."]
    #[doc = ""]
    #[doc = "While tracker is in any mode with fixation targets."]
    #[doc = "Reproduce targets tracker needs."]
    #[doc = "(if local_trigger) Local Spacebar acts as trigger."]
    #[doc = "(if local_control)  Local keys echoes to tracker."]
    #[doc = "@return \\c 0 if OK, \\c 27 if aborted, \\c TERMINATE_KEY if pressed."]
    pub fn target_mode_display() -> INT16;
}
extern "C" {
    #[doc = " (USED BY do_tracker_setup(), YOU DO NOT NEED TO CALL   normally             *"]
    #[doc = "This handles display of the EyeLink camera images.  While in imaging mode,"]
    #[doc = "it contiuously requests and displays the current camera image.  It also"]
    #[doc = "displays the camera name and threshold setting.  Keys on the subject PC"]
    #[doc = "keyboard are sent to the tracker, so the experimenter can use it during"]
    #[doc = "setup.  It will exit when the tracker leaves imaging mode or disconnects."]
    #[doc = ""]
    #[doc = "@return \\c 0 if OK, \\c TERMINATE_KEY if pressed, \\c -1 if disconnect."]
    #[doc = "@remark This function not normally used externally.  If you need camera setup"]
    #[doc = "use do_tracker_setup() or if you need drift correction use do_drift_correct()"]
    pub fn image_mode_display() -> INT16;
}
extern "C" {
    #[doc = " displays general STOP-icon alert box"]
    #[doc = " text is formatted via printf-like arguments"]
    #[doc = "When an error occurs, a notification must be given to the user.  If no alert_printf_hook"]
    #[doc = "is set, this function uses the Windows MessageBox() function in windows. On other"]
    #[doc = "platforms printf is called."]
    #[doc = ""]
    #[doc = "@param fmt A printf() formatting string<...>:  any arguments required."]
    #[doc = ""]
    #[doc = "@remark The error message may no showup in certain display environment eg."]
    #[doc = "SDL with SDL_FULLSCREEN|SDL_HWSURFACE |  SDL_DOUBLEBUF"]
    pub fn alert_printf(fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " THIS ROUTINE MAY NEED TO BE CREATED FOR EACH PLATFORM                       *"]
    #[doc = " This call should be implemented for a standard programming interface        *"]
    #[doc = " Copies tracker file <src> to local file <dest>.                             *"]
    #[doc = " If specifying full file name, be sure to add \".edf\"                         *"]
    #[doc = " extensions for data files.                                                  *"]
    #[doc = " If <src> = \"\", tracker will send last opened data file.                     *"]
    #[doc = " If <dest> is NULL or \"\", creates local file with source file name.          *"]
    #[doc = " Else, creates file using <dest> as name.  If <dest_is_path> != 0            *"]
    #[doc = " uses source file name but adds <dest> as directory path.                    *"]
    #[doc = " returns: file size if OK, negative =  error code                            *"]
    #[doc = "This receives a data file from the EyeLink tracker PC."]
    #[doc = "\\param[in] src Name of eye tracker file (including extension).  If \"\" (empty string), asks"]
    #[doc = "tracker for name of last opened data file."]
    #[doc = "\\param[in] dest Name of local file to write to (including extension).  This must be a"]
    #[doc = "valid file name or directory name."]
    #[doc = "\\param[in] dest_is_path If nonzero, appends file name to &lt;dest&gt; as a directory path."]
    #[doc = "\\return \\c 0 if file transfer was cancelled.\\n"]
    #[doc = "Size of file if successful.\\n"]
    #[doc = "\\c -1 if file size is negative.\\n"]
    #[doc = "\\c -2 if cannot create local file.\\n"]
    #[doc = "\\c -3 if file transfer was cancelled.\\n"]
    #[doc = "\\c -4 if file transfer was aborted.\\n"]
    #[doc = "\\c -5 if error occurred while writing file.\\n"]
    #[doc = "\\c -6 if link was terminated.\\n"]
    #[doc = ""]
    #[doc = "\\b Example: See \\c open_data_file()"]
    #[doc = ""]
    #[doc = "\\sa \\c close_data_file() and \\c open_data_file()"]
    #[doc = ""]
    #[doc = "\\remark If linked against eyelink_exptkit20.lib or w32_dialogs.h is included,"]
    #[doc = "the behaviour of this function is receive_data_file_dialog()."]
    pub fn receive_data_file(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
    ) -> INT32;
}
extern "C" {
    #[doc = " exact same as receive_data_file. except the feedback parameters can be used"]
    #[doc = " for showing what is the full size of the edf file and howmuch is received so far."]
    #[doc = " this function is currently used internally only."]
    #[doc = "This receives a data file from the EyeLink tracker PC."]
    #[doc = "Exact same as \\c receive_data_file(). except the feedback parameters can be used"]
    #[doc = "for showing what is the full size of the edf file and how much is received so far."]
    #[doc = "This function is currently used internally only."]
    #[doc = ""]
    #[doc = "@param[in] src Name of eye tracker file (including extension).  If \"\" (empty string), asks"]
    #[doc = "tracker for name of last opened data file."]
    #[doc = "@param[in] dest Name of local file to write to (including extension).  This must be a"]
    #[doc = "valid file name or directory name."]
    #[doc = "@param[in] dest_is_path If nonzero, appends file name to &lt;dest&gt; as a directory path."]
    #[doc = "@param[in] progress A function pointer, that takes size and received size integers."]
    #[doc = "This allows, one to display progress bar on edf file transfer."]
    #[doc = "@return \\c 0 if file transfer was cancelled.\\n"]
    #[doc = "Size of file if successful.\\n"]
    #[doc = "\\c -1 if file size is negative.\\n"]
    #[doc = "\\c -2 if cannot create local file."]
    #[doc = "\\c -3 if file transfer was cancelled"]
    #[doc = "\\c -4 if file transfer was aborted"]
    #[doc = "\\c -5 if error occurred while writing file"]
    #[doc = "\\c -6 if link was terminated"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\sa \\c receive_data_file, \\c close_data_file() and \\c open_data_file()"]
    pub fn receive_data_file_feedback(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
        progress: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_uint, received: ::std::os::raw::c_uint),
        >,
    ) -> INT32;
}
extern "C" {
    pub fn receive_data_file_feedback_v2(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
        progress: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_uint, received: ::std::os::raw::c_uint),
        >,
    ) -> INT32;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "This function sends a file to the Eyelink tracker. Source destination file name"]
    #[doc = "should be given. Using this function, an image or video can be uploaded from the display"]
    #[doc = "PC to the host Tracker PC. The image can later be used as a Gaze Cursor Backdrop via a call"]
    #[doc = "to eyelink_send_command()."]
    #[doc = ""]
    #[doc = "@param src           Name of local file (including extension)."]
    #[doc = "@param dest          Name of eye tracker file to write to (including extension)."]
    #[doc = "@param dest_is_path  If nonzero, appends file name to &lt;dest&gt; as a directory path."]
    #[doc = "@param progress      A function pointer, that takes size and received size integers."]
    #[doc = "This allows, one to display progress bar on file transfer."]
    #[doc = ""]
    #[doc = "@return Returns \\c size of file if transferred file size is equal to the real file size. \\n"]
    #[doc = "\\c -1 if fail to connect tracker ftpd.\\n"]
    #[doc = "\\c -2 if fail to open file.\\n"]
    #[doc = "\\c -4 if fail to receive reply from tracker ftpd. \\n"]
    #[doc = "\\c -5 if transferred file size is unequal to the real file size."]
    pub fn send_data_file_feedback(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
        progress: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_uint, received: ::std::os::raw::c_uint),
        >,
    ) -> INT32;
}
extern "C" {
    #[doc = " These functions were added as future revisions of EyeLink"]
    #[doc = " might require significant time to open and close EDF files"]
    #[doc = " Opens EDF file on tracker hard disk"]
    #[doc = "Opens an EDF file, closes any existing file."]
    #[doc = ""]
    #[doc = "@param name Name of data file,which can only use letters(uppercase and lowercase),"]
    #[doc = "numbers(0-9),and underscore(appears from 2nd place). Name extension"]
    #[doc = "can only be edf."]
    #[doc = "@return Returns \\c 0 if success, else error code."]
    pub fn open_data_file(name: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " Closes EDF file on tracker hard disk"]
    #[doc = "Closes any open EDF file."]
    #[doc = ""]
    #[doc = "@return Returns \\c 0 if success, else error code."]
    pub fn close_data_file() -> INT16;
}
extern "C" {
    #[doc = " @ingroup keyinput"]
    #[doc = "This function tests if the 'ESC' key is held down, and is usually used to break out of"]
    #[doc = "nested loops.  This does not allow processing of Windows messages, unlike \\c getkey()."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, this call will not work in realtime mode at all,"]
    #[doc = "and will take several seconds to respond if graphics are being drawn"]
    #[doc = "continuously.  This function works well in realtime mode under Windows 2000."]
    #[doc = "@return \\c 1 if 'ESC' key held down; \\c 0 if not."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c break_pressed()"]
    #[doc = ""]
    #[doc = "\\sa \\c break_pressed(), \\c getkey() and \\c echo_key()"]
    pub fn escape_pressed() -> INT16;
}
extern "C" {
    #[doc = " @ingroup keyinput"]
    #[doc = "Tests if the program is being interrupted.  You should break out of loops immediately if"]
    #[doc = "this function does not return \\c 0, if \\c getkey() return \\c TERMINATE_KEY, or if"]
    #[doc = "\\c eyelink_is_connected() returns \\c 0."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, this call will not work in realtime mode at all, and"]
    #[doc = "will take several seconds to respond if graphics are being drawn continuously."]
    #[doc = "This function works well in realtime mode under Windows 2000."]
    #[doc = "@return \\c 1 if CTRL-C is pressed, \\c terminal_break() was called,  or the program has been"]
    #[doc = "terminated with ALT-F4; \\c 0 otherwise."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if((error=check_recording())!=0) return error;"]
    #[doc = ""]
    #[doc = "if(break_pressed())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "if(escape_pressed())"]
    #[doc = "return SKIP_TRIAL;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c echo_key(), \\c escape_pressed() and \\c getkey()"]
    pub fn break_pressed() -> INT16;
}
extern "C" {
    #[doc = " ASYNCHRONOUS BREAKOUTS *********/"]
    #[doc = " Because Windows is multi-tasking, some other event (i.e. a timer event or"]
    #[doc = " ALT-TAB) may affect your application during loops or calibration."]
    #[doc = " Your event handlers can call these functions to stop ongoing operations"]
    #[doc = ""]
    #[doc = " call from Windows event handlers when application must exit"]
    #[doc = " forces calibration or drift correction to exit with result=27"]
    #[doc = " when <assert> is nonzero,  will caused break_pressed() to test true"]
    #[doc = " continuously, also causes getkey() to return TERMINATE_KEY"]
    #[doc = " If <assert> is 0, will restore break_pressed() and getkey() to normal"]
    #[doc = "This function can be called in an event handler to signal that the program is terminating."]
    #[doc = "Calling this function with an argument of \\c 1 will cause \\c break_pressed() to return \\c 1, and"]
    #[doc = "\\c getkey() to return \\c TERMINATE_KEY.  These functions can be re-enabled by calling"]
    #[doc = "\\c terminal_break() with an argument of \\c 0."]
    #[doc = ""]
    #[doc = "@param assert \\c 1 to signal a program break, \\c 0 to reset break."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "switch (message)"]
    #[doc = "{"]
    #[doc = "case WM_CLOSE:        // If ALT-F4 pressed, force program to close"]
    #[doc = "PostQuitMessage(0);"]
    #[doc = "terminal_break(1);// break out of loops"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "case WM_DESTROY:      // Window being closed by ALT-F4"]
    #[doc = "PostQuitMessage( 0 );"]
    #[doc = "..."]
    #[doc = "terminal_break(1);// break out of loops"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "case WM_QUIT:         // Needs to break out of any loops"]
    #[doc = "terminal_break(1);"]
    #[doc = "break;"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c break_pressed() and \\c getkey()"]
    pub fn terminal_break(assert: INT16);
}
extern "C" {
    pub fn application_terminated() -> INT16;
}
extern "C" {
    #[doc = " Sets up for realtime execution (minimum delays)"]
    #[doc = " This may take some time (assume up to 100 msec)"]
    #[doc = " <delay> sets min time so delay may be useful"]
    #[doc = " Effects vary by operating system"]
    #[doc = " Keyboard, mouse, and sound may be disabled in some OS"]
    #[doc = " Has little effect in Win9x/ME"]
    #[doc = "Sets the application priority and cleans up pending Windows activity to place the"]
    #[doc = "application in realtime mode.  This could take up to 100 milliseconds, depending on"]
    #[doc = "the operation system, to set the application priority.  Use the \\c &lt;delay&gt; value to set"]
    #[doc = "the minimum time this function takes, so that this function can act as a useful delay."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, on single core machines, this call will lock out all"]
    #[doc = "keyboard input.  The Task Manager will take about 30 seconds to respond to"]
    #[doc = "CTRL-ALT-DEL, so press this once and be patient.  The keyboard functions well"]
    #[doc = "in realtime mode under Windows 2000.  This function has little or no effect under"]
    #[doc = "Windows 95/98/Me. Keyboard, mouse, and sound may be disabled in some OS."]
    #[doc = ""]
    #[doc = "@remarks Under Windowns Xp the application need to run under administrator credentials to"]
    #[doc = "get the realtime priorities."]
    #[doc = ""]
    #[doc = "@remarks  Under Windows Vista and later, the application need to be run as \"Run as Administrator\""]
    #[doc = "to get realtime priorities."]
    #[doc = ""]
    #[doc = "@remarks  Under Linux, the application need to be run as root to get realtime priorities."]
    #[doc = ""]
    #[doc = "@param delay Minimum delay in milliseconds (should be about 100)."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int error;"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,1);"]
    #[doc = "if(error != 0)  return error;     // return error code if failed"]
    #[doc = ""]
    #[doc = "begin_realtime_mode(100);"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "end_realtime_mode();"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c end_realtime_mode()"]
    pub fn begin_realtime_mode(delay: UINT32);
}
extern "C" {
    #[doc = " Exits realtime execution mode"]
    #[doc = " Typically just lowers priority"]
    #[doc = "Returns the application to a priority slightly above normal, to end realtime mode.  This"]
    #[doc = "function should execute rapidly, but there is the possibility that Windows will allow"]
    #[doc = "other tasks to run after this call, causing delays of 1-20 milliseconds."]
    #[doc = ""]
    #[doc = "@remarks Warning:  This function has little or no effect under Windows 95/98/Me."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c begin_realtime_mode()"]
    #[doc = ""]
    #[doc = "\\sa \\c begin_realtime_mode()"]
    pub fn end_realtime_mode();
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "Raise application priority."]
    #[doc = "May interfere with other applications."]
    pub fn set_high_priority();
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "Sets application priority to system normal"]
    pub fn set_normal_priority();
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "returns whether the current mode is real-time."]
    #[doc = ""]
    #[doc = "@return \\c 1 if in realtime mode, else \\c 0."]
    pub fn in_realtime_mode() -> INT32;
}
extern "C" {
    pub fn eyelink_enable_extended_realtime();
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents an RGB color."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EYECOLOR {
    #[doc = "< Red"]
    pub r: byte,
    #[doc = "< Green"]
    pub g: byte,
    #[doc = "< Blue"]
    pub b: byte,
    pub unused: byte,
}
#[test]
fn bindgen_test_layout_EYECOLOR() {
    assert_eq!(
        ::std::mem::size_of::<EYECOLOR>(),
        4usize,
        concat!("Size of: ", stringify!(EYECOLOR))
    );
    assert_eq!(
        ::std::mem::align_of::<EYECOLOR>(),
        1usize,
        concat!("Alignment of ", stringify!(EYECOLOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).unused as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(unused)
        )
    );
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents a palette index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EYEPALETTE {
    #[doc = "< Number of colors in the palette"]
    pub ncolors: ::std::os::raw::c_int,
    #[doc = "< Actual colors"]
    pub colors: *mut EYECOLOR,
}
#[test]
fn bindgen_test_layout_EYEPALETTE() {
    assert_eq!(
        ::std::mem::size_of::<EYEPALETTE>(),
        16usize,
        concat!("Size of: ", stringify!(EYEPALETTE))
    );
    assert_eq!(
        ::std::mem::align_of::<EYEPALETTE>(),
        8usize,
        concat!("Alignment of ", stringify!(EYEPALETTE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPALETTE>())).ncolors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPALETTE),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPALETTE>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPALETTE),
            "::",
            stringify!(colors)
        )
    );
}
impl Default for EYEPALETTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents pixel format of an image or surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EYEPIXELFORMAT {
    pub colorkey: byte,
    pub Rmask: INT32,
    pub Gmask: INT32,
    pub Bmask: INT32,
    pub Amask: INT32,
    pub palette: *mut EYEPALETTE,
}
#[test]
fn bindgen_test_layout_EYEPIXELFORMAT() {
    assert_eq!(
        ::std::mem::size_of::<EYEPIXELFORMAT>(),
        32usize,
        concat!("Size of: ", stringify!(EYEPIXELFORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<EYEPIXELFORMAT>(),
        8usize,
        concat!("Alignment of ", stringify!(EYEPIXELFORMAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).colorkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(colorkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Rmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Gmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Bmask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Amask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).palette as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(palette)
        )
    );
}
impl Default for EYEPIXELFORMAT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents a bitmap image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EYEBITMAP {
    #[doc = "< width of the image"]
    pub w: INT32,
    #[doc = "< height of the image"]
    pub h: INT32,
    #[doc = "< pitch of image lines. This can be 0. if this is 0, then ((depth+7)/8)*width is used"]
    pub pitch: INT32,
    #[doc = "< Depth of the image. possible values are 8,15,16,24,32"]
    pub depth: INT32,
    #[doc = "< uncompressed pixel data"]
    pub pixels: *mut ::std::os::raw::c_void,
    #[doc = "< pixel format of the image."]
    pub format: *mut EYEPIXELFORMAT,
}
#[test]
fn bindgen_test_layout_EYEBITMAP() {
    assert_eq!(
        ::std::mem::size_of::<EYEBITMAP>(),
        32usize,
        concat!("Size of: ", stringify!(EYEBITMAP))
    );
    assert_eq!(
        ::std::mem::align_of::<EYEBITMAP>(),
        8usize,
        concat!("Alignment of ", stringify!(EYEBITMAP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).depth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).pixels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(format)
        )
    );
}
impl Default for EYEBITMAP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IMAGETYPE_JPEG: IMAGETYPE = 0;
pub const IMAGETYPE_PNG: IMAGETYPE = 1;
pub const IMAGETYPE_GIF: IMAGETYPE = 2;
pub const IMAGETYPE_BMP: IMAGETYPE = 3;
pub const IMAGETYPE_XPM: IMAGETYPE = 4;
#[doc = "@ingroup display"]
pub type IMAGETYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @ingroup error_reporting"]
    #[doc = "Returns error description for given function with error id."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "int rv = open_eyelink_connection(0);"]
    #[doc = "if(rv)"]
    #[doc = "{"]
    #[doc = "char *errmsg = eyelink_get_error(rv,\"open_eyelink_connection\");"]
    #[doc = "printf(\"Error: %s \\n\", errmsg); // report the error"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = "@param[in] id Error id"]
    #[doc = "@param[in] function_name Name of the function that generated the error id."]
    pub fn eyelink_get_error(
        id: ::std::os::raw::c_int,
        function_name: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@}"]
    #[doc = "Splice 'path' to 'fname', store in 'ffname'."]
    #[doc = "Tries to create valid concatenation."]
    #[doc = "If 'fname' starts with '\\', just adds drive from 'path'."]
    #[doc = "If 'fname' contains drive specifier, it is not changed."]
    pub fn splice_fname(
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        ffname: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Checks file name for legality."]
    #[doc = "Attempts to ensure cross-platform for viewer."]
    #[doc = "No spaces allowed as this interferes with messages."]
    #[doc = "Assume viewer will translate forward/backward slash."]
    #[doc = "Windows: don't allow <>:\"/\\|"]
    #[doc = "Also, device names, such as aux, con, lpt1, and prn are not allowed in windows."]
    #[doc = "forward slashes is missed."]
    pub fn check_filename_characters(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Checks if file and/or path exists."]
    #[doc = "@returns \\c 0 if does not exist, \\c 1 if exists, \\c -1 if cannot overwrite."]
    pub fn file_exists(path: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Checks if path exists."]
    #[doc = "Will create directory if 'create'."]
    #[doc = "Creates directory from last name in 'path', unless ends with '\\' or 'is_dir' nonzero."]
    #[doc = "Otherwise, last item is assumed to be filename and is dropped."]
    #[doc = ""]
    #[doc = "@return \\c 0 if exists, \\c 1 if created, \\c -1 if failed."]
    pub fn create_path(
        path: *mut ::std::os::raw::c_char,
        create: INT16,
        is_dir: INT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "This function saves the entire bitmap as a .BMP, .JPG, .PNG, or .TIF file, and"]
    #[doc = "transfers the image to tracker as backdrop for gaze cursors."]
    #[doc = ""]
    #[doc = "@param hbm Bitmap to save or transfer or both."]
    #[doc = "@param xs X position."]
    #[doc = "@param ys Y position."]
    #[doc = "@param width Width."]
    #[doc = "@param height Height."]
    #[doc = "@param fname File name to save as. The extension decides the format of the file."]
    #[doc = "@param path The directory to which the file will be written."]
    #[doc = "@param sv_options If the file exists, it replaces the file unless SV_NOREPLACE is specified."]
    #[doc = "@param xd X positon."]
    #[doc = "@param yd Y positon."]
    #[doc = "@param xferoptions Transfer options set with bitwise OR of the following"]
    #[doc = "constants, determines how bitmap is processed:"]
    #[doc = "\\arg \\c BX_AVERAGE Averaging combined pixels"]
    #[doc = "\\arg \\c BX_DARKEN  Choosing darkest and keep thin dark lines."]
    #[doc = "\\arg \\c BX_LIGHTEN Choosing darkest and keep thin white lines and control how"]
    #[doc = "bitmap size is reduced to fit tracker display."]
    #[doc = "\\arg \\c BX_MAXCONTRAST Maximizes contrast for clearest image."]
    #[doc = "\\arg \\c BX_NODITHER Disables the dithering of the image."]
    #[doc = "\\arg \\c BX_GREYSCALE Converts the image to grayscale (grayscale works"]
    #[doc = "best for EyeLink I, text, etc.)."]
    #[doc = ""]
    #[doc = "\\sa el_bitmap_to_backdrop(), el_bitmap_save(), sdl_bitmap_to_backdrop(),"]
    #[doc = "sdl_bitmap_save(),sdl_bitmap_save_and_backdrop, gdi_bitmap_to_backdrop(),"]
    #[doc = "gdi_bitmap_save(),gdi_bitmap_save_and_backdrop, bitmap_save(),"]
    #[doc = "and bitmap_to_backdrop() for more information."]
    #[doc = ""]
    #[doc = "@remark This function relies on the writeImageHook set by call to set_write_image_hook()"]
    #[doc = "to write the images in different formats. By default, if eyelink_core_graphics library is used,"]
    #[doc = "gd library is used to write the images and if eyelink_gdi_graphics is used FreeImage library is used"]
    #[doc = "to write the images. If neither one of them is used, call to this function does not write the images unless,"]
    #[doc = "set_write_image_hook() is used to set the writeImageHook."]
    #[doc = ""]
    #[doc = "@remark This function should not be called when timing is critical, as this might take very long to return."]
    #[doc = ""]
    pub fn el_bitmap_save_and_backdrop(
        hbm: *mut EYEBITMAP,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        sv_options: INT16,
        xd: INT16,
        yd: INT16,
        xferoptions: UINT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "This function transfers the bitmap to the tracker PC as backdrop for gaze"]
    #[doc = "cursors."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "@param hbm Bitmap to save or transfer or both."]
    #[doc = "@param xs X position."]
    #[doc = "@param ys Y position."]
    #[doc = "@param width Width."]
    #[doc = "@param height Height."]
    #[doc = "@param xd X positon."]
    #[doc = "@param yd Y positon."]
    #[doc = "@param xferoptions Transfer options set with bitwise OR of the following"]
    #[doc = "constants, determines how bitmap is processed:"]
    #[doc = "\\arg \\c BX_AVERAGE Averaging combined pixels"]
    #[doc = "\\arg \\c BX_DARKEN  Choosing darkest and keep thin dark lines."]
    #[doc = "\\arg \\c BX_LIGHTEN Choosing darkest and keep thin white lines and control how"]
    #[doc = "bitmap size is reduced to fit tracker display."]
    #[doc = "\\arg \\c BX_MAXCONTRAST Maximizes contrast for clearest image."]
    #[doc = "\\arg \\c BX_NODITHER Disables the dithering of the image."]
    #[doc = "\\arg \\c BX_GREYSCALE Converts the image to grayscale (grayscale works"]
    #[doc = "best for EyeLink I, text, etc.)."]
    #[doc = ""]
    #[doc = "\\sa sdl_bitmap_to_backdrop(), el_bitmap_save_and_backdrop(),"]
    #[doc = "sdl_bitmap_save_and_backdrop(), gdi_bitmap_to_backdrop(),"]
    #[doc = "gdi_bitmap_save_and_backdrop(),\tand bitmap_to_backdrop() for more information."]
    #[doc = ""]
    #[doc = "@remark This function should not be called when timing is critical, as this might take very long to return."]
    pub fn el_bitmap_to_backdrop(
        hbm: *mut EYEBITMAP,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        xd: INT16,
        yd: INT16,
        xferoptions: UINT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "This function saves the entire bitmap or selected part of a bitmap in an"]
    #[doc = "image file (with an extension of .png, .bmp, .jpg, or .tif). It creates"]
    #[doc = "the specified file if this file does not exist."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "@param hbm Bitmap to save or transfer or both."]
    #[doc = "@param xs X position."]
    #[doc = "@param ys Y position."]
    #[doc = "@param width Width."]
    #[doc = "@param height Height."]
    #[doc = "@param fname File name to save as. The extension decides the format of the file."]
    #[doc = "@param path The directory to which the file will be written."]
    #[doc = "@param sv_options If the file exists, it replaces the file unless SV_NOREPLACE is specified."]
    #[doc = ""]
    #[doc = "@remark This function relies on the writeImageHook set by call to set_write_image_hook()"]
    #[doc = "to write the images in different formats. By default, if eyelink_core_graphics library is used,"]
    #[doc = "gd library is used to write the images and if eyelink_gdi_graphics is used FreeImage library is used"]
    #[doc = "to write the images. If neither one of them is used, call to this function does not write the images unless,"]
    #[doc = "set_write_image_hook() is used to set the writeImageHook."]
    #[doc = ""]
    #[doc = "@remark This function should not be called when timing is critical, as this might take very long to return."]
    pub fn el_bitmap_save(
        hbm: *mut EYEBITMAP,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        sv_options: INT16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @ingroup display"]
#[doc = "\\brief Keyboard input event structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KeyInput {
    #[doc = "< The value of type should have value of KEYINPUT_EVENT"]
    pub type_: byte,
    #[doc = "< KEYDOWN = 1 or KEYUP    = 0"]
    pub state: byte,
    #[doc = "< keys"]
    pub key: UINT16,
    #[doc = "< modifier"]
    pub modifier: UINT16,
    #[doc = "< unicode character value of the key"]
    pub unicode: UINT16,
}
#[test]
fn bindgen_test_layout_KeyInput() {
    assert_eq!(
        ::std::mem::size_of::<KeyInput>(),
        8usize,
        concat!("Size of: ", stringify!(KeyInput))
    );
    assert_eq!(
        ::std::mem::align_of::<KeyInput>(),
        2usize,
        concat!("Alignment of ", stringify!(KeyInput))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).state as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).key as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).modifier as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).unicode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(unicode)
        )
    );
}
#[doc = " @ingroup display"]
#[doc = "\\brief Mouse motion event structure (For future)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MouseMotionEvent {
    #[doc = "< MOUSE_MOTION_INPUT_EVENT"]
    pub type_: byte,
    #[doc = "< The mouse device index"]
    pub which: byte,
    #[doc = "< The current button state"]
    pub state: byte,
    #[doc = "< The X/Y coordinates of the mouse"]
    pub x: UINT16,
    #[doc = "< The X/Y coordinates of the mouse"]
    pub y: UINT16,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: UINT16,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: UINT16,
}
#[test]
fn bindgen_test_layout_MouseMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<MouseMotionEvent>(),
        12usize,
        concat!("Size of: ", stringify!(MouseMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<MouseMotionEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(MouseMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).state as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).xrel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).yrel as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = " @ingroup display"]
#[doc = "\\brief Mouse button event structure (For future)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MouseButtonEvent {
    #[doc = "< MOUSE_BUTTON_INPUT_EVENT"]
    pub type_: byte,
    #[doc = "< The mouse device index"]
    pub which: byte,
    #[doc = "< The mouse button index"]
    pub button: byte,
    #[doc = "< BUTTONDOWN = 0 or BUTTONUP    = 1"]
    pub state: byte,
    #[doc = "< The X/Y coordinates of the mouse at press time"]
    pub x: UINT16,
    #[doc = "< The X/Y coordinates of the mouse at press time"]
    pub y: UINT16,
}
#[test]
fn bindgen_test_layout_MouseButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<MouseButtonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(MouseButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<MouseButtonEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(MouseButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).button as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).state as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "@ingroup display"]
#[doc = "\\brief Union of all input types."]
#[doc = ""]
#[doc = "A union that is used by the callback function get_input_key_hook,"]
#[doc = "to collect input data.  At the moment, it is meant to collect only"]
#[doc = "keyboard inputs. In the future this may be used to support mouse inputs as well."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union InputEvent {
    pub type_: byte,
    pub key: KeyInput,
    pub motion: MouseMotionEvent,
    pub button: MouseButtonEvent,
    _bindgen_union_align: [u16; 6usize],
}
#[test]
fn bindgen_test_layout_InputEvent() {
    assert_eq!(
        ::std::mem::size_of::<InputEvent>(),
        12usize,
        concat!("Size of: ", stringify!(InputEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<InputEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(InputEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).button as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(button)
        )
    );
}
impl Default for InputEvent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup display"]
#[doc = "\\brief Structure used set and get callback functions"]
#[doc = ""]
#[doc = "Structure used set and get callback functions so that the calibration"]
#[doc = "graphics can be drawn."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HOOKFCNS {
    #[doc = "This function is called to setup calibration/validation display."]
    #[doc = "This function called before any calibration routines are called."]
    pub setup_cal_display_hook: ::std::option::Option<unsafe extern "C" fn() -> INT16>,
    #[doc = "This is called to release any resources that are not required beyond calibration."]
    #[doc = "Beyond this call, no calibration functions will be called."]
    pub exit_cal_display_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is called if abort of record. It is used to hide display from subject."]
    pub record_abort_hide_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is responsible for initializing any resources that are"]
    #[doc = "required for camera setup."]
    #[doc = ""]
    #[doc = "@param width width of the source image to expect."]
    #[doc = "@param height height of the source image to expect."]
    #[doc = "@return -1 if failed,  0 otherwise."]
    pub setup_image_display_hook:
        ::std::option::Option<unsafe extern "C" fn(width: INT16, height: INT16) -> INT16>,
    #[doc = "This function is called to update any image title change."]
    #[doc = "@param threshold if -1 the entire tile is in the title string"]
    #[doc = "otherwise, the threshold of the current image."]
    #[doc = "@param title     if threshold is -1, the title contains the whole title"]
    #[doc = "for the image. Otherwise only the camera name is given."]
    pub image_title_hook: ::std::option::Option<
        unsafe extern "C" fn(threshold: INT16, cam_name: *mut ::std::os::raw::c_char),
    >,
    #[doc = "This function is called to supply the image line by line from top to bottom."]
    #[doc = ""]
    #[doc = "@param width  width of the picture. Essentially, number of bytes in \\c pixels."]
    #[doc = "@param line   current line of the image"]
    #[doc = "@param totlines total number of lines in the image. This will always equal the height of the image."]
    #[doc = "@param pixels pixel data."]
    #[doc = ""]
    #[doc = "Eg. Say we want to extract pixel at position (20,20) and print it out as rgb values."]
    #[doc = ""]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "if(line == 20) // y = 20"]
    #[doc = "{"]
    #[doc = "byte pix = pixels[19];"]
    #[doc = "printf(\"RGB %d %d %d\\n\",r[pix],g[pix],b[pix]);"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = "@remark certain display draw the image up side down. eg. GDI."]
    pub draw_image_line_hook: ::std::option::Option<
        unsafe extern "C" fn(width: INT16, line: INT16, totlines: INT16, pixels: *mut byte),
    >,
    #[doc = "This function is called after setup_image_display and before the first call to"]
    #[doc = "draw_image_line. This is responsible to setup the palettes to display the camera"]
    #[doc = "image."]
    #[doc = ""]
    #[doc = "@param ncolors number of colors in the palette."]
    #[doc = "@param r       red component of rgb."]
    #[doc = "@param g       blue component of rgb."]
    #[doc = "@param b       green component of rgb."]
    pub set_image_palette_hook: ::std::option::Option<
        unsafe extern "C" fn(ncolors: INT16, r: *mut byte, g: *mut byte, b: *mut byte),
    >,
    #[doc = "This is called to notify that all camera setup things are complete.  Any"]
    #[doc = "resources that are allocated in setup_image_display can be released in this"]
    #[doc = "function."]
    pub exit_image_display_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "Called to clear the calibration display."]
    pub clear_cal_display_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is responsible for erasing the target that was drawn"]
    #[doc = "by the last call to draw_cal_target."]
    pub erase_cal_target_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is responsible for the drawing of the target for calibration,validation"]
    #[doc = "and drift correct at the given coordinate."]
    #[doc = "@param x x coordinate of the target."]
    #[doc = "@param y y coordinate of the target."]
    #[doc = "@remark The x and y are relative to what is sent to the tracker for the command screen_pixel_coords."]
    pub draw_cal_target_hook: ::std::option::Option<unsafe extern "C" fn(x: INT16, y: INT16)>,
    #[doc = "This function is called to signal new target."]
    pub cal_target_beep_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is called to signal end of calibration."]
    #[doc = "@param error if non zero, then the calibration has error."]
    pub cal_done_beep_hook: ::std::option::Option<unsafe extern "C" fn(error: INT16)>,
    #[doc = "This function is called to singnal the end of drift correct."]
    #[doc = "@param error if non zero, then the drift correction failed."]
    pub dc_done_beep_hook: ::std::option::Option<unsafe extern "C" fn(error: INT16)>,
    #[doc = "This function is called to signal a new drift correct target."]
    pub dc_target_beep_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This is called to check for keyboard input."]
    #[doc = "In this function:"]
    #[doc = "\\arg check if there are any input events"]
    #[doc = "\\arg if there are input events, fill key_input and return 1."]
    #[doc = "otherwise return 0. If 1 is returned this will be called"]
    #[doc = "again to check for more events."]
    #[doc = ""]
    #[doc = "@param[out] key_input  fill in the InputEvent structure to return"]
    #[doc = "key,modifier values."]
    #[doc = "@return if there is a key, return 1 otherwise return 0."]
    #[doc = ""]
    #[doc = "@remark Special keys and modifiers should match the following code."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Special \\b keys:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "#define F1_KEY    0x3B00"]
    #[doc = "#define F2_KEY    0x3C00"]
    #[doc = "#define F3_KEY    0x3D00"]
    #[doc = "#define F4_KEY    0x3E00"]
    #[doc = "#define F5_KEY    0x3F00"]
    #[doc = "#define F6_KEY    0x4000"]
    #[doc = "#define F7_KEY    0x4100"]
    #[doc = "#define F8_KEY    0x4200"]
    #[doc = "#define F9_KEY    0x4300"]
    #[doc = "#define F10_KEY   0x4400"]
    #[doc = ""]
    #[doc = "#define PAGE_UP    0x4900"]
    #[doc = "#define PAGE_DOWN  0x5100"]
    #[doc = "#define CURS_UP    0x4800"]
    #[doc = "#define CURS_DOWN  0x5000"]
    #[doc = "#define CURS_LEFT  0x4B00"]
    #[doc = "#define CURS_RIGHT 0x4D00"]
    #[doc = ""]
    #[doc = "#define ESC_KEY   0x001B"]
    #[doc = "#define ENTER_KEY 0x000D"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "Modifier: If you are using SDL you do not need to modify the modifier value as they match the value."]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "#define ELKMOD_NONE   0x0000"]
    #[doc = "#define ELKMOD_LSHIFT 0x0001"]
    #[doc = "#define ELKMOD_RSHIFT 0x0002"]
    #[doc = "#define ELKMOD_LCTRL  0x0040"]
    #[doc = "#define ELKMOD_RCTRL  0x0080"]
    #[doc = "#define ELKMOD_LALT   0x0100"]
    #[doc = "#define ELKMOD_RALT   0x0200"]
    #[doc = "#define ELKMOD_LMETA  0x0400"]
    #[doc = "#define ELKMOD_RMETA  0x0800,"]
    #[doc = "#define ELKMOD_NUM    0x1000"]
    #[doc = "#define ELKMOD_CAPS   0x2000"]
    #[doc = "#define ELKMOD_MODE   0x4000"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub get_input_key_hook: ::std::option::Option<
        unsafe extern "C" fn(event: *mut InputEvent) -> ::std::os::raw::c_short,
    >,
    #[doc = "This function is called whenever alert_printf is called.  In windows, if no"]
    #[doc = "callback is set calls MessageBox function. In other platforms, if no call back is set"]
    #[doc = "prints out to console."]
    pub alert_printf_hook:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
}
#[test]
fn bindgen_test_layout_HOOKFCNS() {
    assert_eq!(
        ::std::mem::size_of::<HOOKFCNS>(),
        136usize,
        concat!("Size of: ", stringify!(HOOKFCNS))
    );
    assert_eq!(
        ::std::mem::align_of::<HOOKFCNS>(),
        8usize,
        concat!("Alignment of ", stringify!(HOOKFCNS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).setup_cal_display_hook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(setup_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).exit_cal_display_hook as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(exit_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).record_abort_hide_hook as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(record_abort_hide_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS>())).setup_image_display_hook as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(setup_image_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).image_title_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(image_title_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).draw_image_line_hook as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(draw_image_line_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).set_image_palette_hook as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(set_image_palette_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS>())).exit_image_display_hook as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(exit_image_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).clear_cal_display_hook as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(clear_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).erase_cal_target_hook as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(erase_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).draw_cal_target_hook as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(draw_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).cal_target_beep_hook as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(cal_target_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).cal_done_beep_hook as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(cal_done_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).dc_done_beep_hook as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(dc_done_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).dc_target_beep_hook as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(dc_target_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).get_input_key_hook as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(get_input_key_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).alert_printf_hook as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(alert_printf_hook)
        )
    );
}
#[doc = " Drift Correct Done error beep"]
pub const _EL_CAL_BEEP_EL_DC_DONE_ERR_BEEP: _EL_CAL_BEEP = -2;
#[doc = " Calibration Done error beep"]
pub const _EL_CAL_BEEP_EL_CAL_DONE_ERR_BEEP: _EL_CAL_BEEP = -1;
#[doc = " Calibration Done correct beep"]
pub const _EL_CAL_BEEP_EL_CAL_DONE_GOOD_BEEP: _EL_CAL_BEEP = 0;
#[doc = " Calibration target present beep"]
pub const _EL_CAL_BEEP_EL_CAL_TARG_BEEP: _EL_CAL_BEEP = 1;
#[doc = " Drift Correct Done correct beep"]
pub const _EL_CAL_BEEP_EL_DC_DONE_GOOD_BEEP: _EL_CAL_BEEP = 2;
#[doc = " Drift Correct target present beep"]
pub const _EL_CAL_BEEP_EL_DC_TARG_BEEP: _EL_CAL_BEEP = 3;
#[doc = "@ingroup display"]
#[doc = "\\brief Enum used for calibration beeps"]
pub type _EL_CAL_BEEP = ::std::os::raw::c_int;
#[doc = "@ingroup display"]
#[doc = "\\brief Enum used for calibration beeps"]
pub use self::_EL_CAL_BEEP as EL_CAL_BEEP;
#[doc = "@ingroup display"]
#[doc = "\\brief Structure used set and get callback functions"]
#[doc = ""]
#[doc = "Structure used set and get callback functions so that the calibration"]
#[doc = "graphics can be drawn."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HOOKFCNS2 {
    #[doc = "Major version. At the moment the version number must be set to 1"]
    pub major: ::std::os::raw::c_int,
    #[doc = "Minor version. At the moment the version number must be set to 0"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "The value set here will be passed to every single call back functions"]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = "This function is called to setup calibration/validation display."]
    #[doc = "This function called before any calibration routines are called."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub setup_cal_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This is called to release any resources that are not required beyond calibration."]
    #[doc = "Beyond this call, no calibration functions will be called."]
    #[doc = "@return 0 upon success."]
    pub exit_cal_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This function is responsible for initializing any resources that are"]
    #[doc = "required for camera setup."]
    #[doc = ""]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param width width of the source image to expect."]
    #[doc = "@param height height of the source image to expect."]
    #[doc = "@return -1 if failed,  0 otherwise."]
    pub setup_image_display_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            width: INT16,
            height: INT16,
        ) -> INT16,
    >,
    #[doc = "This function is called to update any image title change."]
    #[doc = "@param threshold if -1 the entire tile is in the title string"]
    #[doc = "otherwise, the threshold of the current image."]
    #[doc = "@param title     if threshold is -1, the title contains the whole title"]
    #[doc = "for the image. Otherwise only the camera name is given."]
    #[doc = "@return 0 upon success."]
    pub image_title_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            title: *mut ::std::os::raw::c_char,
        ) -> INT16,
    >,
    #[doc = "This function is called to supply the image."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param width  width of the picture."]
    #[doc = "@param height height of the picture."]
    #[doc = "@param pixels pixels pointer to the pixel data. The size of the pixel data can be calculate by width*height*4."]
    #[doc = "The image comes in RGBA(network order) format."]
    #[doc = "@return 0 upon success."]
    pub draw_image: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            width: INT16,
            height: INT16,
            pixels: *mut byte,
        ) -> INT16,
    >,
    #[doc = "This is called to notify that all camera setup things are complete.  Any"]
    #[doc = "resources that are allocated in setup_image_display can be released in this"]
    #[doc = "function."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub exit_image_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "Called to clear the calibration display."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub clear_cal_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This function is responsible for erasing the target that was drawn"]
    #[doc = "by the last call to draw_cal_target."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub erase_cal_target_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This function is responsible for the drawing of the target for calibration,validation"]
    #[doc = "and drift correct at the given coordinate."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param x x coordinate of the target."]
    #[doc = "@param y y coordinate of the target."]
    #[doc = "@remark The x and y are relative to what is sent to the tracker for the command screen_pixel_coords."]
    #[doc = "@return 0 upon success."]
    pub draw_cal_target_hook: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, x: f32, y: f32) -> INT16,
    >,
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "This function is called to signal new target."]
    #[doc = "@return 0 upon success."]
    pub play_target_beep_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            beep_type: EL_CAL_BEEP,
        ) -> INT16,
    >,
    #[doc = "This is called to check for keyboard input."]
    #[doc = "In this function:"]
    #[doc = ""]
    #[doc = "\\arg check if there are any input events"]
    #[doc = "\\arg if there are input events, fill key_input and return 1."]
    #[doc = "otherwise return 0. If 1 is returned this will be called"]
    #[doc = "again to check for more events."]
    #[doc = ""]
    #[doc = "@param[in] userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param[out] key_input  fill in the InputEvent structure to return"]
    #[doc = "key,modifier values."]
    #[doc = "@return if there is a key, return 1 otherwise return 0. return -1 if there is an error."]
    #[doc = ""]
    #[doc = "@remark Special keys and modifiers should match the following code."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Special \\b keys:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "#define F1_KEY    0x3B00"]
    #[doc = "#define F2_KEY    0x3C00"]
    #[doc = "#define F3_KEY    0x3D00"]
    #[doc = "#define F4_KEY    0x3E00"]
    #[doc = "#define F5_KEY    0x3F00"]
    #[doc = "#define F6_KEY    0x4000"]
    #[doc = "#define F7_KEY    0x4100"]
    #[doc = "#define F8_KEY    0x4200"]
    #[doc = "#define F9_KEY    0x4300"]
    #[doc = "#define F10_KEY   0x4400"]
    #[doc = ""]
    #[doc = "#define PAGE_UP    0x4900"]
    #[doc = "#define PAGE_DOWN  0x5100"]
    #[doc = "#define CURS_UP    0x4800"]
    #[doc = "#define CURS_DOWN  0x5000"]
    #[doc = "#define CURS_LEFT  0x4B00"]
    #[doc = "#define CURS_RIGHT 0x4D00"]
    #[doc = ""]
    #[doc = "#define ESC_KEY   0x001B"]
    #[doc = "#define ENTER_KEY 0x000D"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "Modifier: If you are using SDL you do not need to modify the"]
    #[doc = "modifier value as they match the value."]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "#define ELKMOD_NONE   0x0000"]
    #[doc = "#define ELKMOD_LSHIFT 0x0001"]
    #[doc = "#define ELKMOD_RSHIFT 0x0002"]
    #[doc = "#define ELKMOD_LCTRL  0x0040"]
    #[doc = "#define ELKMOD_RCTRL  0x0080"]
    #[doc = "#define ELKMOD_LALT   0x0100"]
    #[doc = "#define ELKMOD_RALT   0x0200"]
    #[doc = "#define ELKMOD_LMETA  0x0400"]
    #[doc = "#define ELKMOD_RMETA  0x0800,"]
    #[doc = "#define ELKMOD_NUM    0x1000"]
    #[doc = "#define ELKMOD_CAPS   0x2000"]
    #[doc = "#define ELKMOD_MODE   0x4000"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub get_input_key_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            event: *mut InputEvent,
        ) -> INT16,
    >,
    #[doc = "This function is called whenever alert_printf is called.  In windows, if no"]
    #[doc = "callback is set calls MessageBox function. In other platforms, if no call back is set"]
    #[doc = "prints out to console."]
    pub alert_printf_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            msg: *const ::std::os::raw::c_char,
        ) -> INT16,
    >,
    pub reserved1: ::std::os::raw::c_int,
    pub reserved2: ::std::os::raw::c_int,
    pub reserved3: ::std::os::raw::c_int,
    pub reserved4: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HOOKFCNS2() {
    assert_eq!(
        ::std::mem::size_of::<HOOKFCNS2>(),
        128usize,
        concat!("Size of: ", stringify!(HOOKFCNS2))
    );
    assert_eq!(
        ::std::mem::align_of::<HOOKFCNS2>(),
        8usize,
        concat!("Alignment of ", stringify!(HOOKFCNS2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).userData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(userData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).setup_cal_display_hook as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(setup_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).exit_cal_display_hook as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(exit_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).setup_image_display_hook as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(setup_image_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).image_title_hook as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(image_title_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).draw_image as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(draw_image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).exit_image_display_hook as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(exit_image_display_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).clear_cal_display_hook as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(clear_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).erase_cal_target_hook as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(erase_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).draw_cal_target_hook as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(draw_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).play_target_beep_hook as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(play_target_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).get_input_key_hook as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(get_input_key_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).alert_printf_hook as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(alert_printf_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved1 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved3 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved4 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved4)
        )
    );
}
impl Default for HOOKFCNS2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Primary function to setup display graphics hook functions."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "INT16 ELCALLTYPE init_expt_graphics(HWND hwnd, DISPLAYINFO *info)"]
    #[doc = "{"]
    #[doc = "HOOKFCNS fcns;"]
    #[doc = "memset(&fcns,0,sizeof(fcns));"]
    #[doc = "fcns.setup_cal_display_hook = setup_cal_display;"]
    #[doc = "fcns.exit_cal_display_hook  = exit_cal_display;"]
    #[doc = "fcns.record_abort_hide_hook = record_abort_hide;"]
    #[doc = "fcns.setup_image_display_hook = setup_image_display;"]
    #[doc = "fcns.image_title_hook       = image_title;"]
    #[doc = "fcns.draw_image_line_hook   = draw_image_line;"]
    #[doc = "fcns.set_image_palette_hook = set_image_palette;"]
    #[doc = "fcns.exit_image_display_hook= exit_image_display;"]
    #[doc = "fcns.clear_cal_display_hook = clear_cal_display;"]
    #[doc = "fcns.erase_cal_target_hook  = erase_cal_target;"]
    #[doc = "fcns.draw_cal_target_hook   = draw_cal_target;"]
    #[doc = "fcns.cal_target_beep_hook   = cal_target_beep;"]
    #[doc = "fcns.cal_done_beep_hook     = cal_done_beep;"]
    #[doc = "fcns.dc_done_beep_hook      = dc_done_beep;"]
    #[doc = "fcns.dc_target_beep_hook    = dc_target_beep;"]
    #[doc = "fcns.get_input_key_hook     = get_input_key;"]
    #[doc = "fcns.alert_printf_hook      = alert_printf_hook;"]
    #[doc = ""]
    #[doc = "setup_graphic_hook_functions(&fcns);"]
    #[doc = ""]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn setup_graphic_hook_functions(hooks: *mut HOOKFCNS);
}
extern "C" {
    pub fn get_all_hook_functions() -> *mut HOOKFCNS;
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Primary function to setup display graphics hook functions of the second revision of the interface."]
    #[doc = "One of the major difference between this and setup_graphic_hook_functions is, this has fewer functions to implement"]
    #[doc = "also, takes extra parameters like the major and minor versions for future enhancements."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "INT16 ELCALLTYPE init_expt_graphics(HWND hwnd, DISPLAYINFO *info)"]
    #[doc = "{"]
    #[doc = "HOOKFCNS2 fcns;"]
    #[doc = "memset(&fcns,0,sizeof(fcns));"]
    #[doc = "fcns.major = 1;"]
    #[doc = "fcns.minor = 0;"]
    #[doc = "fcns.userData = ts;"]
    #[doc = ""]
    #[doc = "fcns.draw_image   = draw_image;"]
    #[doc = "fcns.exit_image_display_hook= exit_image_display;"]
    #[doc = "fcns.setup_image_display_hook = setup_image_display;"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "fcns.setup_cal_display_hook = setup_cal_display;"]
    #[doc = "fcns.clear_cal_display_hook = clear_display;"]
    #[doc = "fcns.erase_cal_target_hook  = clear_display;"]
    #[doc = "fcns.draw_cal_target_hook   = draw_cal_target;"]
    #[doc = "fcns.image_title_hook       = image_title;"]
    #[doc = ""]
    #[doc = "fcns.get_input_key_hook     = get_input_key;"]
    #[doc = "fcns.alert_printf_hook      = alert_printf_hook;"]
    #[doc = "return setup_graphic_hook_functions_V2(&fcns);"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn setup_graphic_hook_functions_V2(hooks: *mut HOOKFCNS2) -> INT16;
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Returns a pointer to  HOOKFCNS2, with values that are set by"]
    #[doc = "setup_graphic_hook_functions_V2()."]
    #[doc = ""]
    #[doc = "This function with combination of setup_graphic_hook_functions"]
    #[doc = "can be used to over-ride an existing hook function."]
    pub fn get_all_hook_functions_V2() -> *mut HOOKFCNS2;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "Use this function to set function pointer, so that the call to"]
    #[doc = "el_bitmap_save and el_bitmap_save_and_backdrop will use the passed in"]
    #[doc = "function to write the image to disk."]
    pub fn set_write_image_hook(
        hookfn: ::std::option::Option<
            unsafe extern "C" fn(
                outfilename: *mut ::std::os::raw::c_char,
                format: ::std::os::raw::c_int,
                bitmap: *mut EYEBITMAP,
            ) -> ::std::os::raw::c_int,
        >,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_peep_input_event(
        event: *mut InputEvent,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_get_input_event(
        event: *mut InputEvent,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_peep_last_input_event(
        event: *mut InputEvent,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_flush_input_event();
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Function to initialize the gaze to href and href to gaze mapping."]
    #[doc = "This function should be called before calling \\c eyelink_href_to_gaze()"]
    #[doc = "or \\c eyelink_gaze_to_href()."]
    #[doc = "@param left Left pixel value (normally 0)."]
    #[doc = "@param top Top pixel value (normally 0)."]
    #[doc = "@param right Right pixel value (width of the display)."]
    #[doc = "@param bottom Bottom pixel value (height of the display)."]
    #[doc = "@return \\c -1 if the tracker does not support the commands,"]
    #[doc = "href_point_eye"]
    #[doc = "set_href_point"]
    pub fn eyelink_initialize_mapping(left: f32, top: f32, right: f32, bottom: f32) -> INT32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Apply href->gaze to point (xp, yp). This function requires HREFPT data in"]
    #[doc = "FSAMPLE. The function \\c eyelink_initialize_mapping() should be called"]
    #[doc = "before calling this function."]
    #[doc = "@param xp X point to apply href->gaze."]
    #[doc = "@param yp Y point to apply href->gaze."]
    #[doc = "@param sample Sample."]
    #[doc = "@return \\c 0 if OK, \\c -1 if there is a math error, \\c -2 if the tracker"]
    #[doc = "does not support this operation."]
    pub fn eyelink_href_to_gaze(xp: *mut f32, yp: *mut f32, sample: *mut FSAMPLE) -> INT32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Apply gaze->href to point (xp, yp). This function requires HREFPT data in"]
    #[doc = "FSAMPLE. The function \\c eyelink_initialize_mapping() should be called"]
    #[doc = "before calling this function."]
    #[doc = "@param xp X point to apply gaze->href."]
    #[doc = "@param yp Y point to apply gaze->href."]
    #[doc = "@param sample Sample."]
    #[doc = "@return \\c 0 if OK, \\c -1 if there is a math error, \\c -2 if the tracker"]
    #[doc = "does not support this operation."]
    pub fn eyelink_gaze_to_href(xp: *mut f32, yp: *mut f32, sample: *mut FSAMPLE) -> INT32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Convenient function to calculate the href angle."]
    #[doc = "@param x1 Point 1 x."]
    #[doc = "@param y1 Point 1 y."]
    #[doc = "@param x2 Point 2 x."]
    #[doc = "@param y2 Point 2 y."]
    pub fn eyelink_href_angle(x1: f32, y1: f32, x2: f32, y2: f32) -> f32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Convenient function to calculate the href resolution."]
    #[doc = "@param x X value of point."]
    #[doc = "@param y Y value of point."]
    #[doc = "@param xres Pointer to return the x resolution."]
    #[doc = "@param yres Pointer to return the y resolution."]
    pub fn eyelink_href_resolution(x: f32, y: f32, xres: *mut f32, yres: *mut f32);
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "\\deprecated Use eyelink_draw_cross_hair() instead."]
    #[doc = ""]
    #[doc = "Value is image coord scaled so l,t=0, r,b=8192"]
    #[doc = "Values may be negative or beyond image limits"]
    #[doc = "Value is 0x8000 in X (or L) field if crosshair is not to be drawn"]
    #[doc = "Head camera: indexes 0..3 are markers"]
    #[doc = "Eye camera:"]
    #[doc = "Index 0 is pupil center"]
    #[doc = "Index 1 is CR center"]
    #[doc = "Index 2 is pupil-limit box left, top"]
    #[doc = "Index 3 is pupil-limit box right, bottom"]
    #[doc = "@param xhairs_on Set to indicate if xhairs enabled on display (may be \\c NULL)."]
    #[doc = "@param x array of 4 to be filled to return x data"]
    #[doc = "@param y array of 4 to be filled to return y data"]
    #[doc = "@return Channel number (\\c 1 = left, \\c 2 = head, \\c 3 = right)."]
    #[doc = ""]
    #[doc = ""]
    pub fn get_image_xhair_data(
        x: *mut INT16,
        y: *mut INT16,
        xhairs_on: *mut INT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_get_extra_raw_values(
        s: *mut FSAMPLE,
        rv: *mut FSAMPLE_RAW,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_get_extra_raw_values_v2(
        s: *mut FSAMPLE,
        eye: ::std::os::raw::c_int,
        rv: *mut FSAMPLE_RAW,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup velocity_acceleration"]
    #[doc = "Calculates left x velocity, left y velocity, right x velocity and right y velocity from queue of samples."]
    #[doc = "@param[in] slen Sample model to use for velocity calculation. Acceptable models"]
    #[doc = "are \\c FIVE_SAMPLE_MODEL, \\c NINE_SAMPLE_MODEL, \\c SEVENTEEN_SAMPLE_MODEL and"]
    #[doc = "\\c EL1000_TRACKER_MODEL."]
    #[doc = "@param[out] xvel Left and right x velocity."]
    #[doc = "Expects an array of 2 elements of floats. The array is filled with left and right"]
    #[doc = "velocity values.  Upon return of this function xvel[0] contains the left x velocity"]
    #[doc = "data and xvel[1] contains right x velocity data.  If velocity cannot be calculated"]
    #[doc = "for any reason(eg. insufficient samples, no data) MISSING_DATA is filled for the given"]
    #[doc = "velocity."]
    #[doc = "@param[out] yvel Left and right y velocity."]
    #[doc = "Expects an array of 2 elements of floats. The array is filled with left and right"]
    #[doc = "velocity values.  Upon return of this function yvel[0] contains the left y velocity"]
    #[doc = "data and xvel[1] contains right y velocity data.  If velocity cannot be calculated"]
    #[doc = "for any reason(eg. insufficient samples, no data) MISSING_DATA is filled for the given"]
    #[doc = "velocity."]
    #[doc = "@param[out] vel_sample Velocity for sample."]
    #[doc = "Expects a FSAMPLE structure to fill in the sample, the velocity is calculated for."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "#include <stdio.h>"]
    #[doc = "#include <core_expt.h>"]
    #[doc = ""]
    #[doc = "int main(int argc, char ** argv)"]
    #[doc = "{"]
    #[doc = "if(open_eyelink_connection(0)) // connect to tracker"]
    #[doc = "{"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"link_sample_data  = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS\"); // tell the tracker to stuff the sample with"]
    #[doc = "if(start_recording(0,0,1,0)) // start recording failed."]
    #[doc = "{"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(100, 1, 0)) // wait for block start"]
    #[doc = "{"]
    #[doc = "stop_recording();"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "else"]
    #[doc = "{"]
    #[doc = "UINT32 st = current_time();"]
    #[doc = "while(current_time()-st<10000) // record for 10 seconds"]
    #[doc = "{"]
    #[doc = "FSAMPLE fs;"]
    #[doc = "float xvel[2];"]
    #[doc = "float yvel[2];"]
    #[doc = "if(check_recording()!=0)"]
    #[doc = "{"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return -4; // recording aborted."]
    #[doc = "}"]
    #[doc = "eyelink_calculate_velocity_x_y(FIVE_SAMPLE_MODEL,xvel,yvel,&fs);"]
    #[doc = "printf(\"%lu %f %f %f %f\\n\",fs.time,xvel[0],yvel[0], xvel[1], yvel[1]);"]
    #[doc = "pump_delay(100); // we check the velocity every 100 ms."]
    #[doc = "}"]
    #[doc = "stop_recording();"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_calculate_velocity_x_y(
        slen: ::std::os::raw::c_int,
        xvel: *mut f32,
        yvel: *mut f32,
        vel_sample: *mut FSAMPLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup velocity_acceleration"]
    #[doc = "Calculates overall velocity for left and right eyes separately."]
    #[doc = "@param[in] slen Sample model to use for velocity calculation. Acceptable models"]
    #[doc = "are \\c FIVE_SAMPLE_MODEL, \\c NINE_SAMPLE_MODEL, \\c SEVENTEEN_SAMPLE_MODEL and"]
    #[doc = "\\c EL1000_TRACKER_MODEL."]
    #[doc = "@param[out] vel A float array of 2 to fill in the calculated results. Upon return of this function,"]
    #[doc = "vel[0] will contain overall velocity for left eye and vel[1] will contain overall velocity"]
    #[doc = "for right eye.  If velocity cannot be calculated for any reason(eg. insufficient"]
    #[doc = "samples, no data) MISSING_DATA is filled for the given velocity."]
    #[doc = "@param[out] vel_sample Velocity for sample."]
    #[doc = "Expects a FSAMPLE structure to fill in the sample, the velocity is calculated for."]
    pub fn eyelink_calculate_velocity(
        slen: ::std::os::raw::c_int,
        vel: *mut f32,
        vel_sample: *mut FSAMPLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup velocity_acceleration"]
    #[doc = "Calculates overall velocity and acceleration for left and right eyes separately."]
    #[doc = "@param[in] slen Sample model to use for velocity calculation. Acceptable models"]
    #[doc = "are \\c FIVE_SAMPLE_MODEL, \\c NINE_SAMPLE_MODEL, \\c SEVENTEEN_SAMPLE_MODEL and"]
    #[doc = "\\c EL1000_TRACKER_MODEL."]
    #[doc = "@param[out] vel A float array of 2 to fill in the calculated velocity results. Upon return of this function,"]
    #[doc = "vel[0] will contain overall velocity for left eye and vel[1] will contain overall velocity"]
    #[doc = "for right eye.  If velocity cannot be calculated for any reason(eg. insufficient"]
    #[doc = "samples, no data) MISSING_DATA is filled for the given velocity."]
    #[doc = "@param[out] acc A float array of 2 to fill in the calculated acceleration results. Upon return of this function,"]
    #[doc = "acc[0] will contain overall acceleration for left eye and acc[1] will contain overall acceleration"]
    #[doc = "for right eye.  If acceleration cannot be calculated for any reason(eg. insufficient"]
    #[doc = "samples, no data) MISSING_DATA is filled for the given acceleration."]
    #[doc = "@param[out] vel_sample Velocity for sample."]
    #[doc = "Expects a FSAMPLE structure to fill in the sample, the velocity is calculated for."]
    pub fn eyelink_calculate_overallvelocity_and_acceleration(
        slen: ::std::os::raw::c_int,
        vel: *mut f32,
        acc: *mut f32,
        vel_sample: *mut FSAMPLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup message_file"]
    #[doc = "Very similar to eyemsg_printf, with the following features:"]
    #[doc = "\\arg Optionally write the timestamped message to file instead of sending over the link to tracker."]
    #[doc = "\\arg Optional time of event."]
    #[doc = "@param t optional time of event (0 = NOW)"]
    #[doc = "@param fmt format messages"]
    pub fn timemsg_printf(t: UINT32, fmt: *mut ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " @ingroup message_file"]
    #[doc = "Creates message file, once open call to timemsg_printf(), will not send messages to tracker."]
    #[doc = "Messages are kept in a queue if the application is in realtime mode, and written to disk on"]
    #[doc = "non real-time mode except when close_message_file() is called while in real-time mode."]
    #[doc = "@param[in] fname Message file name"]
    pub fn open_message_file(fname: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup message_file"]
    #[doc = "Flush and close message file, opened by open_message_file."]
    pub fn close_message_file();
}
#[doc = "@}"]
pub type CrossHairInfo = _CrossHairInfo;
#[doc = " @ingroup display"]
#[doc = "\\brief Structure to hold cross hair information."]
#[doc = ""]
#[doc = "Structure to hold cross hair information that are needed to"]
#[doc = "draw the cross hair on camera images."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CrossHairInfo {
    #[doc = "< for the moment this should be set to 1."]
    pub majorVersion: ::std::os::raw::c_short,
    #[doc = "< for the moment this should be set to 0."]
    pub minorVersion: ::std::os::raw::c_short,
    #[doc = "Display width of the camera image. This need not to match the"]
    #[doc = "size given at setup_image_display_hook"]
    pub w: ::std::os::raw::c_int,
    #[doc = "Display height of the camera image. This need not to match"]
    #[doc = "the size given at setup_image_display_hook"]
    pub h: ::std::os::raw::c_int,
    #[doc = "Private data used by internals of  eyelink_draw_cross_hair."]
    #[doc = "This pointer should not be touched externally"]
    pub privatedata: *mut ::std::os::raw::c_void,
    #[doc = "Attribute to hold any user data. Any data set here"]
    #[doc = "untouched by eyelink_draw_cross_hair."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = "drawLine shoud draw a line from (x1,y1) -> (x2,y2)"]
    #[doc = "with the given color"]
    #[doc = "@param[in] x1"]
    pub drawLine: ::std::option::Option<
        unsafe extern "C" fn(
            dt: *mut CrossHairInfo,
            x1: ::std::os::raw::c_int,
            y1: ::std::os::raw::c_int,
            x2: ::std::os::raw::c_int,
            y2: ::std::os::raw::c_int,
            colorindex: ::std::os::raw::c_int,
        ),
    >,
    #[doc = "drawLozenge shoud draw circle if the width and height are equal. otherwise"]
    #[doc = "find the smallest width and draw semi-circles on the longest side at both ends and connect"]
    #[doc = "the semi circles with lines."]
    pub drawLozenge: ::std::option::Option<
        unsafe extern "C" fn(
            dt: *mut CrossHairInfo,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            colorindex: ::std::os::raw::c_int,
        ),
    >,
    #[doc = "getMouseState shoud fill values for (x,y) with current mouse position and the"]
    #[doc = "state = 1 if pressed. the x and y values are respective to top left hand corner of the image"]
    pub getMouseState: ::std::option::Option<
        unsafe extern "C" fn(
            dt: *mut CrossHairInfo,
            x: *mut ::std::os::raw::c_int,
            y: *mut ::std::os::raw::c_int,
            state: *mut ::std::os::raw::c_int,
        ),
    >,
    #[doc = "< for future use"]
    pub reserved1: ::std::os::raw::c_int,
    #[doc = "< for future use"]
    pub reserved2: ::std::os::raw::c_int,
    #[doc = "< for future use"]
    pub reserved3: ::std::os::raw::c_int,
    #[doc = "< for future use"]
    pub reserved4: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__CrossHairInfo() {
    assert_eq!(
        ::std::mem::size_of::<_CrossHairInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_CrossHairInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_CrossHairInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_CrossHairInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).majorVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(majorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).minorVersion as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(minorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).privatedata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(privatedata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).userdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).drawLine as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(drawLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).drawLozenge as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(drawLozenge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).getMouseState as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(getMouseState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved3 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved4 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved4)
        )
    );
}
impl Default for _CrossHairInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Convenient function to draw cross hair on camera image. It is very tedious to draw and maintain"]
    #[doc = "cross hair drawing. This is due to evolving eyelink camera image protocol and the introduction"]
    #[doc = "of newer trackers and still single library handle all eyelink trackers.  eyelink_draw_cross_hair"]
    #[doc = "fixes this issue by allowing the drawing function to draw to the device contexts and does all"]
    #[doc = "magic of extracting cursor info from the tracker."]
    #[doc = ""]
    #[doc = "eyelink_draw_cross_hair calls drawLine(), drawEllipse() and getMouseState() to draw the cross hair."]
    #[doc = "eyelink_draw_cross_hair expects both width(w) and height(h) are correct and the function pointers to"]
    #[doc = "drawLine, drawEllipse and getMouseState are not NULL."]
    #[doc = "@param[in] chi initialized CrossHairInfo structure."]
    pub fn eyelink_draw_cross_hair(chi: *mut CrossHairInfo) -> INT32;
}
extern "C" {
    #[doc = "Returns the eyelink_core library version number."]
    #[doc = "@param[out] c fills in the version number of th eyelink_core library."]
    pub fn eyelink_dll_version(c: *mut ::std::os::raw::c_char);
}
