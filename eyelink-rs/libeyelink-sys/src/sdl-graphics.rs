/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __LINUX__: u32 = 1;
pub const SDL_HAS_64BIT_TYPE: u32 = 1;
pub const SDL_BYTEORDER: u32 = 1234;
pub const HAVE_LIBC: u32 = 1;
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_CTYPE_H: u32 = 1;
pub const HAVE_MATH_H: u32 = 1;
pub const HAVE_ICONV_H: u32 = 1;
pub const HAVE_SIGNAL_H: u32 = 1;
pub const HAVE_MALLOC: u32 = 1;
pub const HAVE_CALLOC: u32 = 1;
pub const HAVE_REALLOC: u32 = 1;
pub const HAVE_FREE: u32 = 1;
pub const HAVE_ALLOCA: u32 = 1;
pub const HAVE_GETENV: u32 = 1;
pub const HAVE_PUTENV: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_QSORT: u32 = 1;
pub const HAVE_ABS: u32 = 1;
pub const HAVE_BCOPY: u32 = 1;
pub const HAVE_MEMSET: u32 = 1;
pub const HAVE_MEMCPY: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_MEMCMP: u32 = 1;
pub const HAVE_STRLEN: u32 = 1;
pub const HAVE_STRDUP: u32 = 1;
pub const HAVE_STRCHR: u32 = 1;
pub const HAVE_STRRCHR: u32 = 1;
pub const HAVE_STRSTR: u32 = 1;
pub const HAVE_STRTOL: u32 = 1;
pub const HAVE_STRTOUL: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRTOD: u32 = 1;
pub const HAVE_ATOI: u32 = 1;
pub const HAVE_ATOF: u32 = 1;
pub const HAVE_STRCMP: u32 = 1;
pub const HAVE_STRNCMP: u32 = 1;
pub const HAVE_STRCASECMP: u32 = 1;
pub const HAVE_STRNCASECMP: u32 = 1;
pub const HAVE_SSCANF: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE_ICONV: u32 = 1;
pub const HAVE_SIGACTION: u32 = 1;
pub const HAVE_SA_SIGACTION: u32 = 1;
pub const HAVE_SETJMP: u32 = 1;
pub const HAVE_NANOSLEEP: u32 = 1;
pub const HAVE_GETPAGESIZE: u32 = 1;
pub const HAVE_MPROTECT: u32 = 1;
pub const HAVE_SEM_TIMEDWAIT: u32 = 1;
pub const SDL_AUDIO_DRIVER_ALSA: u32 = 1;
pub const SDL_AUDIO_DRIVER_DISK: u32 = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_AUDIO_DRIVER_PULSE: u32 = 1;
pub const SDL_AUDIO_DRIVER_OSS: u32 = 1;
pub const SDL_CDROM_LINUX: u32 = 1;
pub const SDL_INPUT_LINUXEV: u32 = 1;
pub const SDL_JOYSTICK_LINUX: u32 = 1;
pub const SDL_LOADSO_DLOPEN: u32 = 1;
pub const SDL_THREAD_PTHREAD: u32 = 1;
pub const SDL_THREAD_PTHREAD_RECURSIVE_MUTEX: u32 = 1;
pub const SDL_TIMER_UNIX: u32 = 1;
pub const SDL_VIDEO_DRIVER_CACA: u32 = 1;
pub const SDL_VIDEO_DRIVER_DGA: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_VIDEO_DRIVER_FBCON: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_DGAMOUSE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_VIDMODE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINERAMA: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XME: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XV: u32 = 1;
pub const SDL_VIDEO_OPENGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_GLX: u32 = 1;
pub const SDL_VIDEO_DISABLE_SCREENSAVER: u32 = 1;
pub const SDL_ASSEMBLY_ROUTINES: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _CTYPE_H: u32 = 1;
pub const _ICONV_H: u32 = 1;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const SDL_MAX_TRACKS: u32 = 99;
pub const SDL_AUDIO_TRACK: u32 = 0;
pub const SDL_DATA_TRACK: u32 = 4;
pub const CD_FPS: u32 = 75;
pub const SDL_APPMOUSEFOCUS: u32 = 1;
pub const SDL_APPINPUTFOCUS: u32 = 2;
pub const SDL_APPACTIVE: u32 = 4;
pub const SDL_ALL_HOTKEYS: u32 = 4294967295;
pub const SDL_DEFAULT_REPEAT_DELAY: u32 = 500;
pub const SDL_DEFAULT_REPEAT_INTERVAL: u32 = 30;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_HWSURFACE: u32 = 1;
pub const SDL_ASYNCBLIT: u32 = 4;
pub const SDL_ANYFORMAT: u32 = 268435456;
pub const SDL_HWPALETTE: u32 = 536870912;
pub const SDL_DOUBLEBUF: u32 = 1073741824;
pub const SDL_FULLSCREEN: u32 = 2147483648;
pub const SDL_OPENGL: u32 = 2;
pub const SDL_OPENGLBLIT: u32 = 10;
pub const SDL_RESIZABLE: u32 = 16;
pub const SDL_NOFRAME: u32 = 32;
pub const SDL_HWACCEL: u32 = 256;
pub const SDL_SRCCOLORKEY: u32 = 4096;
pub const SDL_RLEACCELOK: u32 = 8192;
pub const SDL_RLEACCEL: u32 = 16384;
pub const SDL_SRCALPHA: u32 = 65536;
pub const SDL_PREALLOC: u32 = 16777216;
pub const SDL_YV12_OVERLAY: u32 = 842094169;
pub const SDL_IYUV_OVERLAY: u32 = 1448433993;
pub const SDL_YUY2_OVERLAY: u32 = 844715353;
pub const SDL_UYVY_OVERLAY: u32 = 1498831189;
pub const SDL_YVYU_OVERLAY: u32 = 1431918169;
pub const SDL_LOGPAL: u32 = 1;
pub const SDL_PHYSPAL: u32 = 2;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_WHEELUP: u32 = 4;
pub const SDL_BUTTON_WHEELDOWN: u32 = 5;
pub const SDL_BUTTON_X1: u32 = 6;
pub const SDL_BUTTON_X2: u32 = 7;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_ALLEVENTS: u32 = 4294967295;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_TIMESLICE: u32 = 10;
pub const TIMER_RESOLUTION: u32 = 10;
pub const SDL_MAJOR_VERSION: u32 = 1;
pub const SDL_MINOR_VERSION: u32 = 2;
pub const SDL_PATCHLEVEL: u32 = 15;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_CDROM: u32 = 256;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVENTTHREAD: u32 = 16777216;
pub const SDL_INIT_EVERYTHING: u32 = 65535;
pub const BYTEDEF: u32 = 1;
pub const MICRODEF: u32 = 1;
pub const MISSING_DATA: i32 = -32768;
pub const MISSING: i32 = -32768;
pub const INaN: i32 = -32768;
pub const LEFT_EYE: u32 = 0;
pub const RIGHT_EYE: u32 = 1;
pub const LEFTEYEI: u32 = 0;
pub const RIGHTEYEI: u32 = 1;
pub const LEFT: u32 = 0;
pub const RIGHT: u32 = 1;
pub const BINOCULAR: u32 = 2;
pub const SAMPLE_LEFT: u32 = 32768;
pub const SAMPLE_RIGHT: u32 = 16384;
pub const SAMPLE_TIMESTAMP: u32 = 8192;
pub const SAMPLE_PUPILXY: u32 = 4096;
pub const SAMPLE_HREFXY: u32 = 2048;
pub const SAMPLE_GAZEXY: u32 = 1024;
pub const SAMPLE_GAZERES: u32 = 512;
pub const SAMPLE_PUPILSIZE: u32 = 256;
pub const SAMPLE_STATUS: u32 = 128;
pub const SAMPLE_INPUTS: u32 = 64;
pub const SAMPLE_BUTTONS: u32 = 32;
pub const SAMPLE_HEADPOS: u32 = 16;
pub const SAMPLE_TAGGED: u32 = 8;
pub const SAMPLE_UTAGGED: u32 = 4;
pub const SAMPLE_ADD_OFFSET: u32 = 2;
pub const FSAMPLEDEF: u32 = 1;
pub const DSAMPLEDEF: u32 = 1;
pub const FSAMPLERAWDEF: u32 = 1;
pub const FEVENTDEF: u32 = 1;
pub const DEVENTDEF: u32 = 1;
pub const SAMPLE_TYPE: u32 = 200;
pub const STARTPARSE: u32 = 1;
pub const ENDPARSE: u32 = 2;
pub const BREAKPARSE: u32 = 10;
pub const STARTBLINK: u32 = 3;
pub const ENDBLINK: u32 = 4;
pub const STARTSACC: u32 = 5;
pub const ENDSACC: u32 = 6;
pub const STARTFIX: u32 = 7;
pub const ENDFIX: u32 = 8;
pub const FIXUPDATE: u32 = 9;
pub const STARTSAMPLES: u32 = 15;
pub const ENDSAMPLES: u32 = 16;
pub const STARTEVENTS: u32 = 17;
pub const ENDEVENTS: u32 = 18;
pub const MESSAGEEVENT: u32 = 24;
pub const BUTTONEVENT: u32 = 25;
pub const INPUTEVENT: u32 = 28;
pub const LOST_DATA_EVENT: u32 = 63;
pub const ISAMPLE_BUFFER: u32 = 200;
pub const IEVENT_BUFFER: u32 = 66;
pub const IOEVENT_BUFFER: u32 = 8;
pub const IMESSAGE_BUFFER: u32 = 250;
pub const CONTROL_BUFFER: u32 = 36;
pub const ILINKDATA_BUFFER: u32 = 36;
pub const READ_ENDTIME: u32 = 64;
pub const READ_GRES: u32 = 512;
pub const READ_SIZE: u32 = 128;
pub const READ_VEL: u32 = 256;
pub const READ_STATUS: u32 = 8192;
pub const READ_BEG: u32 = 1;
pub const READ_END: u32 = 2;
pub const READ_AVG: u32 = 4;
pub const READ_PUPILXY: u32 = 1024;
pub const READ_HREFXY: u32 = 2048;
pub const READ_GAZEXY: u32 = 4096;
pub const READ_BEGPOS: u32 = 8;
pub const READ_ENDPOS: u32 = 16;
pub const READ_AVGPOS: u32 = 32;
pub const FRIGHTEYE_EVENTS: u32 = 32768;
pub const FLEFTEYE_EVENTS: u32 = 16384;
pub const LEFTEYE_EVENTS: u32 = 32768;
pub const RIGHTEYE_EVENTS: u32 = 16384;
pub const BLINK_EVENTS: u32 = 8192;
pub const FIXATION_EVENTS: u32 = 4096;
pub const FIXUPDATE_EVENTS: u32 = 2048;
pub const SACCADE_EVENTS: u32 = 1024;
pub const MESSAGE_EVENTS: u32 = 512;
pub const BUTTON_EVENTS: u32 = 64;
pub const INPUT_EVENTS: u32 = 32;
pub const EVENT_VELOCITY: u32 = 32768;
pub const EVENT_PUPILSIZE: u32 = 16384;
pub const EVENT_GAZERES: u32 = 8192;
pub const EVENT_STATUS: u32 = 4096;
pub const EVENT_GAZEXY: u32 = 1024;
pub const EVENT_HREFXY: u32 = 512;
pub const EVENT_PUPILXY: u32 = 256;
pub const FIX_AVG_ONLY: u32 = 8;
pub const START_TIME_ONLY: u32 = 4;
pub const PARSEDBY_GAZE: u32 = 192;
pub const PARSEDBY_HREF: u32 = 128;
pub const PARSEDBY_PUPIL: u32 = 64;
pub const ILINKDATAVERSION: u32 = 2;
pub const ELNAMESIZE: u32 = 40;
pub const ELREMBUFSIZE: u32 = 420;
pub const ELINKADDRSIZE: u32 = 16;
pub const PUPIL_DIA_FLAG: u32 = 1;
pub const HAVE_SAMPLES_FLAG: u32 = 2;
pub const HAVE_EVENTS_FLAG: u32 = 4;
pub const HAVE_LEFT_FLAG: u32 = 32768;
pub const HAVE_RIGHT_FLAG: u32 = 16384;
pub const DROPPED_SAMPLE: u32 = 32768;
pub const DROPPED_EVENT: u32 = 16384;
pub const DROPPED_CONTROL: u32 = 8192;
pub const DFILE_IS_OPEN: u32 = 128;
pub const DFILE_EVENTS_ON: u32 = 64;
pub const DFILE_SAMPLES_ON: u32 = 32;
pub const DLINK_EVENTS_ON: u32 = 8;
pub const DLINK_SAMPLES_ON: u32 = 4;
pub const DRECORD_ACTIVE: u32 = 1;
pub const COMMAND_FULL_WARN: u32 = 1;
pub const MESSAGE_FULL_WARN: u32 = 2;
pub const LINK_FULL_WARN: u32 = 4;
pub const FULL_WARN: u32 = 15;
pub const LINK_CONNECTED: u32 = 16;
pub const LINK_BROADCAST: u32 = 32;
pub const LINK_IS_TCPIP: u32 = 64;
pub const LED_TOP_WARNING: u32 = 128;
pub const LED_BOT_WARNING: u32 = 64;
pub const LED_LEFT_WARNING: u32 = 32;
pub const LED_RIGHT_WARNING: u32 = 16;
pub const HEAD_POSITION_WARNING: u32 = 240;
pub const LED_EXTRA_WARNING: u32 = 8;
pub const LED_MISSING_WARNING: u32 = 4;
pub const HEAD_VELOCITY_WARNING: u32 = 1;
pub const CALIBRATION_AREA_WARNING: u32 = 2;
pub const MATH_ERROR_WARNING: u32 = 8192;
pub const INTERP_SAMPLE_WARNING: u32 = 4096;
pub const INTERP_PUPIL_WARNING: u32 = 32768;
pub const CR_WARNING: u32 = 3840;
pub const CR_LEFT_WARNING: u32 = 1280;
pub const CR_RIGHT_WARNING: u32 = 2560;
pub const CR_LOST_WARNING: u32 = 768;
pub const CR_LOST_LEFT_WARNING: u32 = 256;
pub const CR_LOST_RIGHT_WARNING: u32 = 512;
pub const CR_RECOV_WARNING: u32 = 3072;
pub const CR_RECOV_LEFT_WARNING: u32 = 1024;
pub const CR_RECOV_RIGHT_WARNING: u32 = 2048;
pub const HPOS_TOP_WARNING: u32 = 128;
pub const HPOS_BOT_WARNING: u32 = 64;
pub const HPOS_LEFT_WARNING: u32 = 32;
pub const HPOS_RIGHT_WARNING: u32 = 16;
pub const HPOS_WARNING: u32 = 240;
pub const HPOS_ANGLE_WARNING: u32 = 8;
pub const HPOS_MISSING_WARNING: u32 = 4;
pub const HPOS_DISTANCE_WARNING: u32 = 1;
pub const TFLAG_MISSING: u32 = 16384;
pub const TFLAG_ANGLE: u32 = 8192;
pub const TFLAG_NEAREYE: u32 = 4096;
pub const TFLAG_CLOSE: u32 = 2048;
pub const TFLAG_FAR: u32 = 1024;
pub const TFLAG_T_TSIDE: u32 = 128;
pub const TFLAG_T_BSIDE: u32 = 64;
pub const TFLAG_T_LSIDE: u32 = 32;
pub const TFLAG_T_RSIDE: u32 = 16;
pub const TFLAG_E_TSIDE: u32 = 8;
pub const TFLAG_E_BSIDE: u32 = 4;
pub const TFLAG_E_LSIDE: u32 = 2;
pub const TFLAG_E_RSIDE: u32 = 1;
pub const OK_RESULT: u32 = 0;
pub const NO_REPLY: u32 = 1000;
pub const LINK_TERMINATED_RESULT: i32 = -100;
pub const ABORT_RESULT: u32 = 27;
pub const UNEXPECTED_EOL_RESULT: i32 = -1;
pub const SYNTAX_ERROR_RESULT: i32 = -2;
pub const BAD_VALUE_RESULT: i32 = -3;
pub const EXTRA_CHARACTERS_RESULT: i32 = -4;
pub const LINK_SEND_MAX: u32 = 244;
pub const LINK_INITIALIZE_FAILED: i32 = -200;
pub const CONNECT_TIMEOUT_FAILED: i32 = -201;
pub const WRONG_LINK_VERSION: i32 = -202;
pub const TRACKER_BUSY: i32 = -203;
pub const IN_DISCONNECT_MODE: u32 = 16384;
pub const IN_UNKNOWN_MODE: u32 = 0;
pub const IN_IDLE_MODE: u32 = 1;
pub const IN_SETUP_MODE: u32 = 2;
pub const IN_RECORD_MODE: u32 = 4;
pub const IN_TARGET_MODE: u32 = 8;
pub const IN_DRIFTCORR_MODE: u32 = 16;
pub const IN_IMAGE_MODE: u32 = 32;
pub const IN_USER_MENU: u32 = 64;
pub const IN_PLAYBACK_MODE: u32 = 256;
pub const EL_IDLE_MODE: u32 = 1;
pub const EL_IMAGE_MODE: u32 = 2;
pub const EL_SETUP_MENU_MODE: u32 = 3;
pub const EL_USER_MENU_1: u32 = 5;
pub const EL_USER_MENU_2: u32 = 6;
pub const EL_USER_MENU_3: u32 = 7;
pub const EL_OPTIONS_MENU_MODE: u32 = 8;
pub const EL_OUTPUT_MENU_MODE: u32 = 9;
pub const EL_DEMO_MENU_MODE: u32 = 10;
pub const EL_CALIBRATE_MODE: u32 = 11;
pub const EL_VALIDATE_MODE: u32 = 12;
pub const EL_DRIFT_CORR_MODE: u32 = 13;
pub const EL_RECORD_MODE: u32 = 14;
pub const SCENECAM_ALIGN_MODE: u32 = 15;
pub const SCENECAM_DEPTH_MODE: u32 = 16;
pub const RECORD_FILE_SAMPLES: u32 = 1;
pub const RECORD_FILE_EVENTS: u32 = 2;
pub const RECORD_LINK_SAMPLES: u32 = 4;
pub const RECORD_LINK_EVENTS: u32 = 8;
pub const ELIMAGE_2: u32 = 0;
pub const ELIMAGE_16: u32 = 1;
pub const ELIMAGE_16P: u32 = 2;
pub const ELIMAGE_256: u32 = 3;
pub const ELIMAGE_128HV: u32 = 4;
pub const ELIMAGE_128HVX: u32 = 5;
pub const KB_PRESS: u32 = 10;
pub const KB_RELEASE: i32 = -1;
pub const KB_REPEAT: u32 = 1;
pub const NUM_LOCK_ON: u32 = 32;
pub const CAPS_LOCK_ON: u32 = 64;
pub const ALT_KEY_DOWN: u32 = 8;
pub const CTRL_KEY_DOWN: u32 = 4;
pub const SHIFT_KEY_DOWN: u32 = 3;
pub const KB_BUTTON: u32 = 65280;
pub const F1_KEY: u32 = 15104;
pub const F2_KEY: u32 = 15360;
pub const F3_KEY: u32 = 15616;
pub const F4_KEY: u32 = 15872;
pub const F5_KEY: u32 = 16128;
pub const F6_KEY: u32 = 16384;
pub const F7_KEY: u32 = 16640;
pub const F8_KEY: u32 = 16896;
pub const F9_KEY: u32 = 17152;
pub const F10_KEY: u32 = 17408;
pub const PAGE_UP: u32 = 18688;
pub const PAGE_DOWN: u32 = 20736;
pub const CURS_UP: u32 = 18432;
pub const CURS_DOWN: u32 = 20480;
pub const CURS_LEFT: u32 = 19200;
pub const CURS_RIGHT: u32 = 19712;
pub const ESC_KEY: u32 = 27;
pub const ENTER_KEY: u32 = 13;
pub const FILE_XFER_ABORTED: i32 = -110;
pub const FILE_CANT_OPEN: i32 = -111;
pub const FILE_NO_REPLY: i32 = -112;
pub const FILE_BAD_DATA: i32 = -113;
pub const FILEDATA_SIZE_FLAG: u32 = 999;
pub const FILE_BLOCK_SIZE: u32 = 512;
pub const ABORT_BX: i32 = -32000;
pub const PAUSE_BX: i32 = -32001;
pub const DONE_BX: i32 = -32002;
pub const JUNK_KEY: u32 = 1;
pub const TERMINATE_KEY: u32 = 32767;
pub const DONE_TRIAL: u32 = 0;
pub const TRIAL_OK: u32 = 0;
pub const REPEAT_TRIAL: u32 = 1;
pub const SKIP_TRIAL: u32 = 2;
pub const ABORT_EXPT: u32 = 3;
pub const TRIAL_ERROR: i32 = -1;
pub const BX_AVERAGE: u32 = 0;
pub const BX_DARKEN: u32 = 1;
pub const BX_LIGHTEN: u32 = 2;
pub const BX_MAXCONTRAST: u32 = 4;
pub const BX_NODITHER: u32 = 8;
pub const BX_GRAYSCALE: u32 = 16;
pub const BX_TXFILE: u32 = 32;
pub const BX_DOTRANSFER: u32 = 256;
pub const SV_NOREPLACE: u32 = 1;
pub const SV_MAKEPATH: u32 = 2;
pub const BAD_FILENAME: i32 = -2222;
pub const BAD_ARGUMENT: i32 = -2223;
pub const KEYINPUT_EVENT: u32 = 1;
pub const MOUSE_INPUT_EVENT: u32 = 4;
pub const MOUSE_MOTION_INPUT_EVENT: u32 = 5;
pub const MOUSE_BUTTON_INPUT_EVENT: u32 = 6;
pub const ELKMOD_NONE: u32 = 0;
pub const ELKMOD_LSHIFT: u32 = 1;
pub const ELKMOD_RSHIFT: u32 = 2;
pub const ELKMOD_LCTRL: u32 = 64;
pub const ELKMOD_RCTRL: u32 = 128;
pub const ELKMOD_LALT: u32 = 256;
pub const ELKMOD_RALT: u32 = 512;
pub const ELKMOD_LMETA: u32 = 1024;
pub const ELKMOD_RMETA: u32 = 2048;
pub const ELKMOD_NUM: u32 = 4096;
pub const ELKMOD_CAPS: u32 = 8192;
pub const ELKMOD_MODE: u32 = 16384;
pub const ELKEY_DOWN: u32 = 1;
pub const ELKEY_UP: u32 = 0;
pub const FIVE_SAMPLE_MODEL: u32 = 1;
pub const NINE_SAMPLE_MODEL: u32 = 2;
pub const SEVENTEEN_SAMPLE_MODEL: u32 = 3;
pub const EL1000_TRACKER_MODEL: u32 = 4;
pub const CR_HAIR_COLOR: u32 = 1;
pub const PUPIL_HAIR_COLOR: u32 = 2;
pub const PUPIL_BOX_COLOR: u32 = 3;
pub const SEARCH_LIMIT_BOX_COLOR: u32 = 4;
pub const MOUSE_CURSOR_COLOR: u32 = 5;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const _ISupper: ::std::os::raw::c_uint = 256;
pub const _ISlower: ::std::os::raw::c_uint = 512;
pub const _ISalpha: ::std::os::raw::c_uint = 1024;
pub const _ISdigit: ::std::os::raw::c_uint = 2048;
pub const _ISxdigit: ::std::os::raw::c_uint = 4096;
pub const _ISspace: ::std::os::raw::c_uint = 8192;
pub const _ISprint: ::std::os::raw::c_uint = 16384;
pub const _ISgraph: ::std::os::raw::c_uint = 32768;
pub const _ISblank: ::std::os::raw::c_uint = 1;
pub const _IScntrl: ::std::os::raw::c_uint = 2;
pub const _ISpunct: ::std::os::raw::c_uint = 4;
pub const _ISalnum: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
pub type iconv_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn iconv_open(
        __tocode: *const ::std::os::raw::c_char,
        __fromcode: *const ::std::os::raw::c_char,
    ) -> iconv_t;
}
extern "C" {
    pub fn iconv(
        __cd: iconv_t,
        __inbuf: *mut *mut ::std::os::raw::c_char,
        __inbytesleft: *mut size_t,
        __outbuf: *mut *mut ::std::os::raw::c_char,
        __outbytesleft: *mut size_t,
    ) -> size_t;
}
extern "C" {
    pub fn iconv_close(__cd: iconv_t) -> ::std::os::raw::c_int;
}
pub const SDL_bool_SDL_FALSE: SDL_bool = 0;
pub const SDL_bool_SDL_TRUE: SDL_bool = 1;
pub type SDL_bool = ::std::os::raw::c_uint;
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_dummy_uint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_uint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_uint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_uint64 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint64 = [::std::os::raw::c_int; 1usize];
pub const SDL_DUMMY_ENUM_DUMMY_ENUM_VALUE: SDL_DUMMY_ENUM = 0;
pub type SDL_DUMMY_ENUM = ::std::os::raw::c_uint;
pub type SDL_dummy_enum = [::std::os::raw::c_int; 1usize];
extern "C" {
    pub fn SDL_revcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        maxlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        maxlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_strrev(string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strupr(string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strlwr(string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ltoa(
        value: ::std::os::raw::c_long,
        string: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ultoa(
        value: ::std::os::raw::c_ulong,
        string: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_lltoa(
        value: Sint64,
        string: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(
        value: Uint64,
        string: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_iconv(
        cd: iconv_t,
        inbuf: *mut *const ::std::os::raw::c_char,
        inbytesleft: *mut size_t,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbytesleft: *mut size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_iconv_string(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
        inbuf: *const ::std::os::raw::c_char,
        inbytesleft: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_SetError(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn SDL_GetError() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ClearError();
}
pub const SDL_errorcode_SDL_ENOMEM: SDL_errorcode = 0;
pub const SDL_errorcode_SDL_EFREAD: SDL_errorcode = 1;
pub const SDL_errorcode_SDL_EFWRITE: SDL_errorcode = 2;
pub const SDL_errorcode_SDL_EFSEEK: SDL_errorcode = 3;
pub const SDL_errorcode_SDL_UNSUPPORTED: SDL_errorcode = 4;
pub const SDL_errorcode_SDL_LASTERROR: SDL_errorcode = 5;
pub type SDL_errorcode = ::std::os::raw::c_uint;
extern "C" {
    pub fn SDL_Error(code: SDL_errorcode);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
    pub fn SDL_mutexP(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_mutexV(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
    _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CondWait(cond: *mut SDL_cond, mut_: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CondWaitTimeout(
        cond: *mut SDL_cond,
        mutex: *mut SDL_mutex,
        ms: Uint32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SDL_CreateThread(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    pub fn SDL_ThreadID() -> Uint32;
}
extern "C" {
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> Uint32;
}
extern "C" {
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn SDL_KillThread(thread: *mut SDL_Thread);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: ::std::os::raw::c_int,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            maxnum: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(context: *mut SDL_RWops) -> ::std::os::raw::c_int,
    >,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub autoclose: ::std::os::raw::c_int,
    pub fp: *mut FILE,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).autoclose as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autoclose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).fp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).here as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(here)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).stop as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(stop)
        )
    );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    pub data1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data1)
        )
    );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1>())).stdio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops__bindgen_ty_1>())).unknown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
impl Default for SDL_RWops__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops>(),
        64usize,
        concat!("Size of: ", stringify!(SDL_RWops))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).seek as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).read as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).write as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_RWops>())).hidden as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(hidden)
        )
    );
}
impl Default for SDL_RWops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SDL_RWFromFile(
        file: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromFP(fp: *mut FILE, autoclose: ::std::os::raw::c_int) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromMem(
        mem: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromConstMem(
        mem: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioSpec {
    pub freq: ::std::os::raw::c_int,
    pub format: Uint16,
    pub channels: Uint8,
    pub silence: Uint8,
    pub samples: Uint16,
    pub padding: Uint16,
    pub size: Uint32,
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::std::os::raw::c_void,
            stream: *mut Uint8,
            len: ::std::os::raw::c_int,
        ),
    >,
    pub userdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioSpec>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).channels as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).silence as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(silence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).samples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).callback as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioSpec>())).userdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(userdata)
        )
    );
}
impl Default for SDL_AudioSpec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioCVT {
    pub needed: ::std::os::raw::c_int,
    pub src_format: Uint16,
    pub dst_format: Uint16,
    pub rate_incr: f64,
    pub buf: *mut Uint8,
    pub len: ::std::os::raw::c_int,
    pub len_cvt: ::std::os::raw::c_int,
    pub len_mult: ::std::os::raw::c_int,
    pub len_ratio: f64,
    pub filters: [::std::option::Option<
        unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: Uint16),
    >; 10usize],
    pub filter_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioCVT>(),
        136usize,
        concat!("Size of: ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioCVT>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).needed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).src_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(src_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).dst_format as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(dst_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).rate_incr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(rate_incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len_cvt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_cvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len_mult as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).len_ratio as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).filters as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_AudioCVT>())).filter_index as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filter_index)
        )
    );
}
impl Default for SDL_AudioCVT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SDL_AudioInit(driver_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_AudioQuit();
}
extern "C" {
    pub fn SDL_AudioDriverName(
        namebuf: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_OpenAudio(
        desired: *mut SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
    ) -> ::std::os::raw::c_int;
}
pub const SDL_audiostatus_SDL_AUDIO_STOPPED: SDL_audiostatus = 0;
pub const SDL_audiostatus_SDL_AUDIO_PLAYING: SDL_audiostatus = 1;
pub const SDL_audiostatus_SDL_AUDIO_PAUSED: SDL_audiostatus = 2;
pub type SDL_audiostatus = ::std::os::raw::c_uint;
extern "C" {
    pub fn SDL_GetAudioStatus() -> SDL_audiostatus;
}
extern "C" {
    pub fn SDL_PauseAudio(pause_on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SDL_LoadWAV_RW(
        src: *mut SDL_RWops,
        freesrc: ::std::os::raw::c_int,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> *mut SDL_AudioSpec;
}
extern "C" {
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
    pub fn SDL_BuildAudioCVT(
        cvt: *mut SDL_AudioCVT,
        src_format: Uint16,
        src_channels: Uint8,
        src_rate: ::std::os::raw::c_int,
        dst_format: Uint16,
        dst_channels: Uint8,
        dst_rate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_MixAudio(
        dst: *mut Uint8,
        src: *const Uint8,
        len: Uint32,
        volume: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SDL_LockAudio();
}
extern "C" {
    pub fn SDL_UnlockAudio();
}
extern "C" {
    pub fn SDL_CloseAudio();
}
pub const CDstatus_CD_TRAYEMPTY: CDstatus = 0;
pub const CDstatus_CD_STOPPED: CDstatus = 1;
pub const CDstatus_CD_PLAYING: CDstatus = 2;
pub const CDstatus_CD_PAUSED: CDstatus = 3;
pub const CDstatus_CD_ERROR: CDstatus = -1;
pub type CDstatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_CDtrack {
    pub id: Uint8,
    pub type_: Uint8,
    pub unused: Uint16,
    pub length: Uint32,
    pub offset: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CDtrack() {
    assert_eq!(
        ::std::mem::size_of::<SDL_CDtrack>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_CDtrack))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_CDtrack>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_CDtrack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CDtrack>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CDtrack),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CDtrack>())).type_ as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CDtrack),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CDtrack>())).unused as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CDtrack),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CDtrack>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CDtrack),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CDtrack>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CDtrack),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_CD {
    pub id: ::std::os::raw::c_int,
    pub status: CDstatus,
    pub numtracks: ::std::os::raw::c_int,
    pub cur_track: ::std::os::raw::c_int,
    pub cur_frame: ::std::os::raw::c_int,
    pub track: [SDL_CDtrack; 100usize],
}
#[test]
fn bindgen_test_layout_SDL_CD() {
    assert_eq!(
        ::std::mem::size_of::<SDL_CD>(),
        1220usize,
        concat!("Size of: ", stringify!(SDL_CD))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_CD>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_CD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CD>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CD),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CD>())).status as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CD),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CD>())).numtracks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CD),
            "::",
            stringify!(numtracks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CD>())).cur_track as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CD),
            "::",
            stringify!(cur_track)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CD>())).cur_frame as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CD),
            "::",
            stringify!(cur_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_CD>())).track as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CD),
            "::",
            stringify!(track)
        )
    );
}
impl Default for SDL_CD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SDL_CDNumDrives() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDName(drive: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_CDOpen(drive: ::std::os::raw::c_int) -> *mut SDL_CD;
}
extern "C" {
    pub fn SDL_CDStatus(cdrom: *mut SDL_CD) -> CDstatus;
}
extern "C" {
    pub fn SDL_CDPlayTracks(
        cdrom: *mut SDL_CD,
        start_track: ::std::os::raw::c_int,
        start_frame: ::std::os::raw::c_int,
        ntracks: ::std::os::raw::c_int,
        nframes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDPlay(
        cdrom: *mut SDL_CD,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDPause(cdrom: *mut SDL_CD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDResume(cdrom: *mut SDL_CD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDStop(cdrom: *mut SDL_CD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDEject(cdrom: *mut SDL_CD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_CDClose(cdrom: *mut SDL_CD);
}
extern "C" {
    pub fn SDL_HasRDTSC() -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasMMXExt() -> SDL_bool;
}
extern "C" {
    pub fn SDL_Has3DNow() -> SDL_bool;
}
extern "C" {
    pub fn SDL_Has3DNowExt() -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    pub fn SDL_GetAppState() -> Uint8;
}
pub const SDLKey_SDLK_UNKNOWN: SDLKey = 0;
pub const SDLKey_SDLK_FIRST: SDLKey = 0;
pub const SDLKey_SDLK_BACKSPACE: SDLKey = 8;
pub const SDLKey_SDLK_TAB: SDLKey = 9;
pub const SDLKey_SDLK_CLEAR: SDLKey = 12;
pub const SDLKey_SDLK_RETURN: SDLKey = 13;
pub const SDLKey_SDLK_PAUSE: SDLKey = 19;
pub const SDLKey_SDLK_ESCAPE: SDLKey = 27;
pub const SDLKey_SDLK_SPACE: SDLKey = 32;
pub const SDLKey_SDLK_EXCLAIM: SDLKey = 33;
pub const SDLKey_SDLK_QUOTEDBL: SDLKey = 34;
pub const SDLKey_SDLK_HASH: SDLKey = 35;
pub const SDLKey_SDLK_DOLLAR: SDLKey = 36;
pub const SDLKey_SDLK_AMPERSAND: SDLKey = 38;
pub const SDLKey_SDLK_QUOTE: SDLKey = 39;
pub const SDLKey_SDLK_LEFTPAREN: SDLKey = 40;
pub const SDLKey_SDLK_RIGHTPAREN: SDLKey = 41;
pub const SDLKey_SDLK_ASTERISK: SDLKey = 42;
pub const SDLKey_SDLK_PLUS: SDLKey = 43;
pub const SDLKey_SDLK_COMMA: SDLKey = 44;
pub const SDLKey_SDLK_MINUS: SDLKey = 45;
pub const SDLKey_SDLK_PERIOD: SDLKey = 46;
pub const SDLKey_SDLK_SLASH: SDLKey = 47;
pub const SDLKey_SDLK_0: SDLKey = 48;
pub const SDLKey_SDLK_1: SDLKey = 49;
pub const SDLKey_SDLK_2: SDLKey = 50;
pub const SDLKey_SDLK_3: SDLKey = 51;
pub const SDLKey_SDLK_4: SDLKey = 52;
pub const SDLKey_SDLK_5: SDLKey = 53;
pub const SDLKey_SDLK_6: SDLKey = 54;
pub const SDLKey_SDLK_7: SDLKey = 55;
pub const SDLKey_SDLK_8: SDLKey = 56;
pub const SDLKey_SDLK_9: SDLKey = 57;
pub const SDLKey_SDLK_COLON: SDLKey = 58;
pub const SDLKey_SDLK_SEMICOLON: SDLKey = 59;
pub const SDLKey_SDLK_LESS: SDLKey = 60;
pub const SDLKey_SDLK_EQUALS: SDLKey = 61;
pub const SDLKey_SDLK_GREATER: SDLKey = 62;
pub const SDLKey_SDLK_QUESTION: SDLKey = 63;
pub const SDLKey_SDLK_AT: SDLKey = 64;
pub const SDLKey_SDLK_LEFTBRACKET: SDLKey = 91;
pub const SDLKey_SDLK_BACKSLASH: SDLKey = 92;
pub const SDLKey_SDLK_RIGHTBRACKET: SDLKey = 93;
pub const SDLKey_SDLK_CARET: SDLKey = 94;
pub const SDLKey_SDLK_UNDERSCORE: SDLKey = 95;
pub const SDLKey_SDLK_BACKQUOTE: SDLKey = 96;
pub const SDLKey_SDLK_a: SDLKey = 97;
pub const SDLKey_SDLK_b: SDLKey = 98;
pub const SDLKey_SDLK_c: SDLKey = 99;
pub const SDLKey_SDLK_d: SDLKey = 100;
pub const SDLKey_SDLK_e: SDLKey = 101;
pub const SDLKey_SDLK_f: SDLKey = 102;
pub const SDLKey_SDLK_g: SDLKey = 103;
pub const SDLKey_SDLK_h: SDLKey = 104;
pub const SDLKey_SDLK_i: SDLKey = 105;
pub const SDLKey_SDLK_j: SDLKey = 106;
pub const SDLKey_SDLK_k: SDLKey = 107;
pub const SDLKey_SDLK_l: SDLKey = 108;
pub const SDLKey_SDLK_m: SDLKey = 109;
pub const SDLKey_SDLK_n: SDLKey = 110;
pub const SDLKey_SDLK_o: SDLKey = 111;
pub const SDLKey_SDLK_p: SDLKey = 112;
pub const SDLKey_SDLK_q: SDLKey = 113;
pub const SDLKey_SDLK_r: SDLKey = 114;
pub const SDLKey_SDLK_s: SDLKey = 115;
pub const SDLKey_SDLK_t: SDLKey = 116;
pub const SDLKey_SDLK_u: SDLKey = 117;
pub const SDLKey_SDLK_v: SDLKey = 118;
pub const SDLKey_SDLK_w: SDLKey = 119;
pub const SDLKey_SDLK_x: SDLKey = 120;
pub const SDLKey_SDLK_y: SDLKey = 121;
pub const SDLKey_SDLK_z: SDLKey = 122;
pub const SDLKey_SDLK_DELETE: SDLKey = 127;
pub const SDLKey_SDLK_WORLD_0: SDLKey = 160;
pub const SDLKey_SDLK_WORLD_1: SDLKey = 161;
pub const SDLKey_SDLK_WORLD_2: SDLKey = 162;
pub const SDLKey_SDLK_WORLD_3: SDLKey = 163;
pub const SDLKey_SDLK_WORLD_4: SDLKey = 164;
pub const SDLKey_SDLK_WORLD_5: SDLKey = 165;
pub const SDLKey_SDLK_WORLD_6: SDLKey = 166;
pub const SDLKey_SDLK_WORLD_7: SDLKey = 167;
pub const SDLKey_SDLK_WORLD_8: SDLKey = 168;
pub const SDLKey_SDLK_WORLD_9: SDLKey = 169;
pub const SDLKey_SDLK_WORLD_10: SDLKey = 170;
pub const SDLKey_SDLK_WORLD_11: SDLKey = 171;
pub const SDLKey_SDLK_WORLD_12: SDLKey = 172;
pub const SDLKey_SDLK_WORLD_13: SDLKey = 173;
pub const SDLKey_SDLK_WORLD_14: SDLKey = 174;
pub const SDLKey_SDLK_WORLD_15: SDLKey = 175;
pub const SDLKey_SDLK_WORLD_16: SDLKey = 176;
pub const SDLKey_SDLK_WORLD_17: SDLKey = 177;
pub const SDLKey_SDLK_WORLD_18: SDLKey = 178;
pub const SDLKey_SDLK_WORLD_19: SDLKey = 179;
pub const SDLKey_SDLK_WORLD_20: SDLKey = 180;
pub const SDLKey_SDLK_WORLD_21: SDLKey = 181;
pub const SDLKey_SDLK_WORLD_22: SDLKey = 182;
pub const SDLKey_SDLK_WORLD_23: SDLKey = 183;
pub const SDLKey_SDLK_WORLD_24: SDLKey = 184;
pub const SDLKey_SDLK_WORLD_25: SDLKey = 185;
pub const SDLKey_SDLK_WORLD_26: SDLKey = 186;
pub const SDLKey_SDLK_WORLD_27: SDLKey = 187;
pub const SDLKey_SDLK_WORLD_28: SDLKey = 188;
pub const SDLKey_SDLK_WORLD_29: SDLKey = 189;
pub const SDLKey_SDLK_WORLD_30: SDLKey = 190;
pub const SDLKey_SDLK_WORLD_31: SDLKey = 191;
pub const SDLKey_SDLK_WORLD_32: SDLKey = 192;
pub const SDLKey_SDLK_WORLD_33: SDLKey = 193;
pub const SDLKey_SDLK_WORLD_34: SDLKey = 194;
pub const SDLKey_SDLK_WORLD_35: SDLKey = 195;
pub const SDLKey_SDLK_WORLD_36: SDLKey = 196;
pub const SDLKey_SDLK_WORLD_37: SDLKey = 197;
pub const SDLKey_SDLK_WORLD_38: SDLKey = 198;
pub const SDLKey_SDLK_WORLD_39: SDLKey = 199;
pub const SDLKey_SDLK_WORLD_40: SDLKey = 200;
pub const SDLKey_SDLK_WORLD_41: SDLKey = 201;
pub const SDLKey_SDLK_WORLD_42: SDLKey = 202;
pub const SDLKey_SDLK_WORLD_43: SDLKey = 203;
pub const SDLKey_SDLK_WORLD_44: SDLKey = 204;
pub const SDLKey_SDLK_WORLD_45: SDLKey = 205;
pub const SDLKey_SDLK_WORLD_46: SDLKey = 206;
pub const SDLKey_SDLK_WORLD_47: SDLKey = 207;
pub const SDLKey_SDLK_WORLD_48: SDLKey = 208;
pub const SDLKey_SDLK_WORLD_49: SDLKey = 209;
pub const SDLKey_SDLK_WORLD_50: SDLKey = 210;
pub const SDLKey_SDLK_WORLD_51: SDLKey = 211;
pub const SDLKey_SDLK_WORLD_52: SDLKey = 212;
pub const SDLKey_SDLK_WORLD_53: SDLKey = 213;
pub const SDLKey_SDLK_WORLD_54: SDLKey = 214;
pub const SDLKey_SDLK_WORLD_55: SDLKey = 215;
pub const SDLKey_SDLK_WORLD_56: SDLKey = 216;
pub const SDLKey_SDLK_WORLD_57: SDLKey = 217;
pub const SDLKey_SDLK_WORLD_58: SDLKey = 218;
pub const SDLKey_SDLK_WORLD_59: SDLKey = 219;
pub const SDLKey_SDLK_WORLD_60: SDLKey = 220;
pub const SDLKey_SDLK_WORLD_61: SDLKey = 221;
pub const SDLKey_SDLK_WORLD_62: SDLKey = 222;
pub const SDLKey_SDLK_WORLD_63: SDLKey = 223;
pub const SDLKey_SDLK_WORLD_64: SDLKey = 224;
pub const SDLKey_SDLK_WORLD_65: SDLKey = 225;
pub const SDLKey_SDLK_WORLD_66: SDLKey = 226;
pub const SDLKey_SDLK_WORLD_67: SDLKey = 227;
pub const SDLKey_SDLK_WORLD_68: SDLKey = 228;
pub const SDLKey_SDLK_WORLD_69: SDLKey = 229;
pub const SDLKey_SDLK_WORLD_70: SDLKey = 230;
pub const SDLKey_SDLK_WORLD_71: SDLKey = 231;
pub const SDLKey_SDLK_WORLD_72: SDLKey = 232;
pub const SDLKey_SDLK_WORLD_73: SDLKey = 233;
pub const SDLKey_SDLK_WORLD_74: SDLKey = 234;
pub const SDLKey_SDLK_WORLD_75: SDLKey = 235;
pub const SDLKey_SDLK_WORLD_76: SDLKey = 236;
pub const SDLKey_SDLK_WORLD_77: SDLKey = 237;
pub const SDLKey_SDLK_WORLD_78: SDLKey = 238;
pub const SDLKey_SDLK_WORLD_79: SDLKey = 239;
pub const SDLKey_SDLK_WORLD_80: SDLKey = 240;
pub const SDLKey_SDLK_WORLD_81: SDLKey = 241;
pub const SDLKey_SDLK_WORLD_82: SDLKey = 242;
pub const SDLKey_SDLK_WORLD_83: SDLKey = 243;
pub const SDLKey_SDLK_WORLD_84: SDLKey = 244;
pub const SDLKey_SDLK_WORLD_85: SDLKey = 245;
pub const SDLKey_SDLK_WORLD_86: SDLKey = 246;
pub const SDLKey_SDLK_WORLD_87: SDLKey = 247;
pub const SDLKey_SDLK_WORLD_88: SDLKey = 248;
pub const SDLKey_SDLK_WORLD_89: SDLKey = 249;
pub const SDLKey_SDLK_WORLD_90: SDLKey = 250;
pub const SDLKey_SDLK_WORLD_91: SDLKey = 251;
pub const SDLKey_SDLK_WORLD_92: SDLKey = 252;
pub const SDLKey_SDLK_WORLD_93: SDLKey = 253;
pub const SDLKey_SDLK_WORLD_94: SDLKey = 254;
pub const SDLKey_SDLK_WORLD_95: SDLKey = 255;
pub const SDLKey_SDLK_KP0: SDLKey = 256;
pub const SDLKey_SDLK_KP1: SDLKey = 257;
pub const SDLKey_SDLK_KP2: SDLKey = 258;
pub const SDLKey_SDLK_KP3: SDLKey = 259;
pub const SDLKey_SDLK_KP4: SDLKey = 260;
pub const SDLKey_SDLK_KP5: SDLKey = 261;
pub const SDLKey_SDLK_KP6: SDLKey = 262;
pub const SDLKey_SDLK_KP7: SDLKey = 263;
pub const SDLKey_SDLK_KP8: SDLKey = 264;
pub const SDLKey_SDLK_KP9: SDLKey = 265;
pub const SDLKey_SDLK_KP_PERIOD: SDLKey = 266;
pub const SDLKey_SDLK_KP_DIVIDE: SDLKey = 267;
pub const SDLKey_SDLK_KP_MULTIPLY: SDLKey = 268;
pub const SDLKey_SDLK_KP_MINUS: SDLKey = 269;
pub const SDLKey_SDLK_KP_PLUS: SDLKey = 270;
pub const SDLKey_SDLK_KP_ENTER: SDLKey = 271;
pub const SDLKey_SDLK_KP_EQUALS: SDLKey = 272;
pub const SDLKey_SDLK_UP: SDLKey = 273;
pub const SDLKey_SDLK_DOWN: SDLKey = 274;
pub const SDLKey_SDLK_RIGHT: SDLKey = 275;
pub const SDLKey_SDLK_LEFT: SDLKey = 276;
pub const SDLKey_SDLK_INSERT: SDLKey = 277;
pub const SDLKey_SDLK_HOME: SDLKey = 278;
pub const SDLKey_SDLK_END: SDLKey = 279;
pub const SDLKey_SDLK_PAGEUP: SDLKey = 280;
pub const SDLKey_SDLK_PAGEDOWN: SDLKey = 281;
pub const SDLKey_SDLK_F1: SDLKey = 282;
pub const SDLKey_SDLK_F2: SDLKey = 283;
pub const SDLKey_SDLK_F3: SDLKey = 284;
pub const SDLKey_SDLK_F4: SDLKey = 285;
pub const SDLKey_SDLK_F5: SDLKey = 286;
pub const SDLKey_SDLK_F6: SDLKey = 287;
pub const SDLKey_SDLK_F7: SDLKey = 288;
pub const SDLKey_SDLK_F8: SDLKey = 289;
pub const SDLKey_SDLK_F9: SDLKey = 290;
pub const SDLKey_SDLK_F10: SDLKey = 291;
pub const SDLKey_SDLK_F11: SDLKey = 292;
pub const SDLKey_SDLK_F12: SDLKey = 293;
pub const SDLKey_SDLK_F13: SDLKey = 294;
pub const SDLKey_SDLK_F14: SDLKey = 295;
pub const SDLKey_SDLK_F15: SDLKey = 296;
pub const SDLKey_SDLK_NUMLOCK: SDLKey = 300;
pub const SDLKey_SDLK_CAPSLOCK: SDLKey = 301;
pub const SDLKey_SDLK_SCROLLOCK: SDLKey = 302;
pub const SDLKey_SDLK_RSHIFT: SDLKey = 303;
pub const SDLKey_SDLK_LSHIFT: SDLKey = 304;
pub const SDLKey_SDLK_RCTRL: SDLKey = 305;
pub const SDLKey_SDLK_LCTRL: SDLKey = 306;
pub const SDLKey_SDLK_RALT: SDLKey = 307;
pub const SDLKey_SDLK_LALT: SDLKey = 308;
pub const SDLKey_SDLK_RMETA: SDLKey = 309;
pub const SDLKey_SDLK_LMETA: SDLKey = 310;
pub const SDLKey_SDLK_LSUPER: SDLKey = 311;
pub const SDLKey_SDLK_RSUPER: SDLKey = 312;
pub const SDLKey_SDLK_MODE: SDLKey = 313;
pub const SDLKey_SDLK_COMPOSE: SDLKey = 314;
pub const SDLKey_SDLK_HELP: SDLKey = 315;
pub const SDLKey_SDLK_PRINT: SDLKey = 316;
pub const SDLKey_SDLK_SYSREQ: SDLKey = 317;
pub const SDLKey_SDLK_BREAK: SDLKey = 318;
pub const SDLKey_SDLK_MENU: SDLKey = 319;
pub const SDLKey_SDLK_POWER: SDLKey = 320;
pub const SDLKey_SDLK_EURO: SDLKey = 321;
pub const SDLKey_SDLK_UNDO: SDLKey = 322;
pub const SDLKey_SDLK_LAST: SDLKey = 323;
pub type SDLKey = ::std::os::raw::c_uint;
pub const SDLMod_KMOD_NONE: SDLMod = 0;
pub const SDLMod_KMOD_LSHIFT: SDLMod = 1;
pub const SDLMod_KMOD_RSHIFT: SDLMod = 2;
pub const SDLMod_KMOD_LCTRL: SDLMod = 64;
pub const SDLMod_KMOD_RCTRL: SDLMod = 128;
pub const SDLMod_KMOD_LALT: SDLMod = 256;
pub const SDLMod_KMOD_RALT: SDLMod = 512;
pub const SDLMod_KMOD_LMETA: SDLMod = 1024;
pub const SDLMod_KMOD_RMETA: SDLMod = 2048;
pub const SDLMod_KMOD_NUM: SDLMod = 4096;
pub const SDLMod_KMOD_CAPS: SDLMod = 8192;
pub const SDLMod_KMOD_MODE: SDLMod = 16384;
pub const SDLMod_KMOD_RESERVED: SDLMod = 32768;
pub type SDLMod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_keysym {
    pub scancode: Uint8,
    pub sym: SDLKey,
    pub mod_: SDLMod,
    pub unicode: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_keysym() {
    assert_eq!(
        ::std::mem::size_of::<SDL_keysym>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_keysym))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_keysym>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_keysym))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_keysym>())).scancode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_keysym),
            "::",
            stringify!(scancode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_keysym>())).sym as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_keysym),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_keysym>())).mod_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_keysym),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_keysym>())).unicode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_keysym),
            "::",
            stringify!(unicode)
        )
    );
}
impl Default for SDL_keysym {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SDL_EnableUNICODE(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_EnableKeyRepeat(
        delay: ::std::os::raw::c_int,
        interval: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetKeyRepeat(
        delay: *mut ::std::os::raw::c_int,
        interval: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SDL_GetKeyState(numkeys: *mut ::std::os::raw::c_int) -> *mut Uint8;
}
extern "C" {
    pub fn SDL_GetModState() -> SDLMod;
}
extern "C" {
    pub fn SDL_SetModState(modstate: SDLMod);
}
extern "C" {
    pub fn SDL_GetKeyName(key: SDLKey) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_Rect {
    pub x: Sint16,
    pub y: Sint16,
    pub w: Uint16,
    pub h: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Rect>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Rect>(),
        2usize,
        concat!("Alignment of ", stringify!(SDL_Rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Rect>())).h as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub unused: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Color>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_Color))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Color>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_Color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Color>())).unused as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Palette {
    pub ncolors: ::std::os::raw::c_int,
    pub colors: *mut SDL_Color,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Palette>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Palette))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Palette))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Palette>())).ncolors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Palette>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(colors)
        )
    );
}
impl Default for SDL_Palette {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PixelFormat {
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub colorkey: Uint32,
    pub alpha: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    assert_eq!(
        ::std::mem::size_of::<SDL_PixelFormat>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_PixelFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).palette as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).BitsPerPixel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BitsPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).BytesPerPixel as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BytesPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Rloss as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Gloss as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Bloss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Aloss as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Aloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Rshift as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Gshift as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Bshift as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Ashift as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Ashift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Rmask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Gmask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Bmask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).Amask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).colorkey as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(colorkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_PixelFormat>())).alpha as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(alpha)
        )
    );
}
impl Default for SDL_PixelFormat {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Surface {
    pub flags: Uint32,
    pub format: *mut SDL_PixelFormat,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub pitch: Uint16,
    pub pixels: *mut ::std::os::raw::c_void,
    pub offset: ::std::os::raw::c_int,
    pub hwdata: *mut private_hwdata,
    pub clip_rect: SDL_Rect,
    pub unused1: Uint32,
    pub locked: Uint32,
    pub map: *mut SDL_BlitMap,
    pub format_version: ::std::os::raw::c_uint,
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Surface>(),
        88usize,
        concat!("Size of: ", stringify!(SDL_Surface))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Surface>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Surface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).pitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).pixels as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).hwdata as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(hwdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).clip_rect as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(clip_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).unused1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).locked as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).map as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).format_version as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(format_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Surface>())).refcount as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(refcount)
        )
    );
}
impl Default for SDL_Surface {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type SDL_blit = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_VideoInfo {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub video_mem: Uint32,
    pub vfmt: *mut SDL_PixelFormat,
    pub current_w: ::std::os::raw::c_int,
    pub current_h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_VideoInfo() {
    assert_eq!(
        ::std::mem::size_of::<SDL_VideoInfo>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_VideoInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_VideoInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_VideoInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_VideoInfo>())).video_mem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VideoInfo),
            "::",
            stringify!(video_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_VideoInfo>())).vfmt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VideoInfo),
            "::",
            stringify!(vfmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_VideoInfo>())).current_w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VideoInfo),
            "::",
            stringify!(current_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_VideoInfo>())).current_h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VideoInfo),
            "::",
            stringify!(current_h)
        )
    );
}
impl Default for SDL_VideoInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl SDL_VideoInfo {
    #[inline]
    pub fn hw_available(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_available(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wm_available(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wm_available(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusedBits1(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_UnusedBits1(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusedBits2(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnusedBits2(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_hw(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_hw(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_hw_CC(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_hw_CC(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_hw_A(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_hw_A(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_sw(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_sw(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_sw_CC(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_sw_CC(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_sw_A(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_sw_A(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blit_fill(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_fill(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusedBits3(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_UnusedBits3(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_available: Uint32,
        wm_available: Uint32,
        UnusedBits1: Uint32,
        UnusedBits2: Uint32,
        blit_hw: Uint32,
        blit_hw_CC: Uint32,
        blit_hw_A: Uint32,
        blit_sw: Uint32,
        blit_sw_CC: Uint32,
        blit_sw_A: Uint32,
        blit_fill: Uint32,
        UnusedBits3: Uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_available: u32 = unsafe { ::std::mem::transmute(hw_available) };
            hw_available as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wm_available: u32 = unsafe { ::std::mem::transmute(wm_available) };
            wm_available as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let UnusedBits1: u32 = unsafe { ::std::mem::transmute(UnusedBits1) };
            UnusedBits1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UnusedBits2: u32 = unsafe { ::std::mem::transmute(UnusedBits2) };
            UnusedBits2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let blit_hw: u32 = unsafe { ::std::mem::transmute(blit_hw) };
            blit_hw as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let blit_hw_CC: u32 = unsafe { ::std::mem::transmute(blit_hw_CC) };
            blit_hw_CC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let blit_hw_A: u32 = unsafe { ::std::mem::transmute(blit_hw_A) };
            blit_hw_A as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let blit_sw: u32 = unsafe { ::std::mem::transmute(blit_sw) };
            blit_sw as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let blit_sw_CC: u32 = unsafe { ::std::mem::transmute(blit_sw_CC) };
            blit_sw_CC as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let blit_sw_A: u32 = unsafe { ::std::mem::transmute(blit_sw_A) };
            blit_sw_A as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let blit_fill: u32 = unsafe { ::std::mem::transmute(blit_fill) };
            blit_fill as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let UnusedBits3: u32 = unsafe { ::std::mem::transmute(UnusedBits3) };
            UnusedBits3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Overlay {
    pub format: Uint32,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub planes: ::std::os::raw::c_int,
    pub pitches: *mut Uint16,
    pub pixels: *mut *mut Uint8,
    pub hwfuncs: *mut private_yuvhwfuncs,
    pub hwdata: *mut private_yuvhwdata,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_SDL_Overlay() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Overlay>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_Overlay))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Overlay>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Overlay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).planes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).pitches as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(pitches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).pixels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).hwfuncs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(hwfuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Overlay>())).hwdata as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Overlay),
            "::",
            stringify!(hwdata)
        )
    );
}
impl Default for SDL_Overlay {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl SDL_Overlay {
    #[inline]
    pub fn hw_overlay(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_overlay(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnusedBits(&self) -> Uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_UnusedBits(&mut self, val: Uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_overlay: Uint32,
        UnusedBits: Uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_overlay: u32 = unsafe { ::std::mem::transmute(hw_overlay) };
            hw_overlay as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let UnusedBits: u32 = unsafe { ::std::mem::transmute(UnusedBits) };
            UnusedBits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const SDL_GLattr_SDL_GL_RED_SIZE: SDL_GLattr = 0;
pub const SDL_GLattr_SDL_GL_GREEN_SIZE: SDL_GLattr = 1;
pub const SDL_GLattr_SDL_GL_BLUE_SIZE: SDL_GLattr = 2;
pub const SDL_GLattr_SDL_GL_ALPHA_SIZE: SDL_GLattr = 3;
pub const SDL_GLattr_SDL_GL_BUFFER_SIZE: SDL_GLattr = 4;
pub const SDL_GLattr_SDL_GL_DOUBLEBUFFER: SDL_GLattr = 5;
pub const SDL_GLattr_SDL_GL_DEPTH_SIZE: SDL_GLattr = 6;
pub const SDL_GLattr_SDL_GL_STENCIL_SIZE: SDL_GLattr = 7;
pub const SDL_GLattr_SDL_GL_ACCUM_RED_SIZE: SDL_GLattr = 8;
pub const SDL_GLattr_SDL_GL_ACCUM_GREEN_SIZE: SDL_GLattr = 9;
pub const SDL_GLattr_SDL_GL_ACCUM_BLUE_SIZE: SDL_GLattr = 10;
pub const SDL_GLattr_SDL_GL_ACCUM_ALPHA_SIZE: SDL_GLattr = 11;
pub const SDL_GLattr_SDL_GL_STEREO: SDL_GLattr = 12;
pub const SDL_GLattr_SDL_GL_MULTISAMPLEBUFFERS: SDL_GLattr = 13;
pub const SDL_GLattr_SDL_GL_MULTISAMPLESAMPLES: SDL_GLattr = 14;
pub const SDL_GLattr_SDL_GL_ACCELERATED_VISUAL: SDL_GLattr = 15;
pub const SDL_GLattr_SDL_GL_SWAP_CONTROL: SDL_GLattr = 16;
pub type SDL_GLattr = ::std::os::raw::c_uint;
extern "C" {
    pub fn SDL_VideoInit(
        driver_name: *const ::std::os::raw::c_char,
        flags: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_VideoQuit();
}
extern "C" {
    pub fn SDL_VideoDriverName(
        namebuf: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_GetVideoSurface() -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_GetVideoInfo() -> *const SDL_VideoInfo;
}
extern "C" {
    pub fn SDL_VideoModeOK(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        flags: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_ListModes(format: *mut SDL_PixelFormat, flags: Uint32) -> *mut *mut SDL_Rect;
}
extern "C" {
    pub fn SDL_SetVideoMode(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_UpdateRects(
        screen: *mut SDL_Surface,
        numrects: ::std::os::raw::c_int,
        rects: *mut SDL_Rect,
    );
}
extern "C" {
    pub fn SDL_UpdateRect(screen: *mut SDL_Surface, x: Sint32, y: Sint32, w: Uint32, h: Uint32);
}
extern "C" {
    pub fn SDL_Flip(screen: *mut SDL_Surface) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetGamma(red: f32, green: f32, blue: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetGammaRamp(
        red: *const Uint16,
        green: *const Uint16,
        blue: *const Uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetGammaRamp(
        red: *mut Uint16,
        green: *mut Uint16,
        blue: *mut Uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetColors(
        surface: *mut SDL_Surface,
        colors: *mut SDL_Color,
        firstcolor: ::std::os::raw::c_int,
        ncolors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetPalette(
        surface: *mut SDL_Surface,
        flags: ::std::os::raw::c_int,
        colors: *mut SDL_Color,
        firstcolor: ::std::os::raw::c_int,
        ncolors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormat,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
extern "C" {
    pub fn SDL_GetRGB(
        pixel: Uint32,
        fmt: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
extern "C" {
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        fmt: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
extern "C" {
    pub fn SDL_CreateRGBSurface(
        flags: Uint32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceFrom(
        pixels: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: ::std::os::raw::c_int) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_SaveBMP_RW(
        surface: *mut SDL_Surface,
        dst: *mut SDL_RWops,
        freedst: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetColorKey(
        surface: *mut SDL_Surface,
        flag: Uint32,
        key: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetAlpha(
        surface: *mut SDL_Surface,
        flag: Uint32,
        alpha: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
    pub fn SDL_ConvertSurface(
        src: *mut SDL_Surface,
        fmt: *mut SDL_PixelFormat,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_UpperBlit(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_LowerBlit(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_FillRect(
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
        color: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_DisplayFormat(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_DisplayFormatAlpha(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateYUVOverlay(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: Uint32,
        display: *mut SDL_Surface,
    ) -> *mut SDL_Overlay;
}
extern "C" {
    pub fn SDL_LockYUVOverlay(overlay: *mut SDL_Overlay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_UnlockYUVOverlay(overlay: *mut SDL_Overlay);
}
extern "C" {
    pub fn SDL_DisplayYUVOverlay(
        overlay: *mut SDL_Overlay,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_FreeYUVOverlay(overlay: *mut SDL_Overlay);
}
extern "C" {
    pub fn SDL_GL_LoadLibrary(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GL_GetProcAddress(
        proc_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_GL_SetAttribute(
        attr: SDL_GLattr,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GL_GetAttribute(
        attr: SDL_GLattr,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GL_SwapBuffers();
}
extern "C" {
    pub fn SDL_GL_UpdateRects(numrects: ::std::os::raw::c_int, rects: *mut SDL_Rect);
}
extern "C" {
    pub fn SDL_GL_Lock();
}
extern "C" {
    pub fn SDL_GL_Unlock();
}
extern "C" {
    pub fn SDL_WM_SetCaption(
        title: *const ::std::os::raw::c_char,
        icon: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SDL_WM_GetCaption(
        title: *mut *mut ::std::os::raw::c_char,
        icon: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SDL_WM_SetIcon(icon: *mut SDL_Surface, mask: *mut Uint8);
}
extern "C" {
    pub fn SDL_WM_IconifyWindow() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WM_ToggleFullScreen(surface: *mut SDL_Surface) -> ::std::os::raw::c_int;
}
pub const SDL_GrabMode_SDL_GRAB_QUERY: SDL_GrabMode = -1;
pub const SDL_GrabMode_SDL_GRAB_OFF: SDL_GrabMode = 0;
pub const SDL_GrabMode_SDL_GRAB_ON: SDL_GrabMode = 1;
pub const SDL_GrabMode_SDL_GRAB_FULLSCREEN: SDL_GrabMode = 2;
pub type SDL_GrabMode = ::std::os::raw::c_int;
extern "C" {
    pub fn SDL_WM_GrabInput(mode: SDL_GrabMode) -> SDL_GrabMode;
}
extern "C" {
    pub fn SDL_SoftStretch(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WMcursor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
    pub area: SDL_Rect,
    pub hot_x: Sint16,
    pub hot_y: Sint16,
    pub data: *mut Uint8,
    pub mask: *mut Uint8,
    pub save: [*mut Uint8; 2usize],
    pub wm_cursor: *mut WMcursor,
}
#[test]
fn bindgen_test_layout_SDL_Cursor() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Cursor>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_Cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Cursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).hot_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(hot_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).hot_y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(hot_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).save as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Cursor>())).wm_cursor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Cursor),
            "::",
            stringify!(wm_cursor)
        )
    );
}
impl Default for SDL_Cursor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SDL_GetMouseState(x: *mut ::std::os::raw::c_int, y: *mut ::std::os::raw::c_int)
        -> Uint8;
}
extern "C" {
    pub fn SDL_GetRelativeMouseState(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> Uint8;
}
extern "C" {
    pub fn SDL_WarpMouse(x: Uint16, y: Uint16);
}
extern "C" {
    pub fn SDL_CreateCursor(
        data: *mut Uint8,
        mask: *mut Uint8,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hot_x: ::std::os::raw::c_int,
        hot_y: ::std::os::raw::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    pub fn SDL_ShowCursor(toggle: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
    _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
extern "C" {
    pub fn SDL_NumJoysticks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickName(device_index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_JoystickOpen(device_index: ::std::os::raw::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    pub fn SDL_JoystickOpened(device_index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickIndex(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickUpdate();
}
extern "C" {
    pub fn SDL_JoystickEventState(state: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: ::std::os::raw::c_int) -> Sint16;
}
extern "C" {
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    pub fn SDL_JoystickGetBall(
        joystick: *mut SDL_Joystick,
        ball: ::std::os::raw::c_int,
        dx: *mut ::std::os::raw::c_int,
        dy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_JoystickGetButton(
        joystick: *mut SDL_Joystick,
        button: ::std::os::raw::c_int,
    ) -> Uint8;
}
extern "C" {
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
pub const SDL_EventType_SDL_NOEVENT: SDL_EventType = 0;
pub const SDL_EventType_SDL_ACTIVEEVENT: SDL_EventType = 1;
pub const SDL_EventType_SDL_KEYDOWN: SDL_EventType = 2;
pub const SDL_EventType_SDL_KEYUP: SDL_EventType = 3;
pub const SDL_EventType_SDL_MOUSEMOTION: SDL_EventType = 4;
pub const SDL_EventType_SDL_MOUSEBUTTONDOWN: SDL_EventType = 5;
pub const SDL_EventType_SDL_MOUSEBUTTONUP: SDL_EventType = 6;
pub const SDL_EventType_SDL_JOYAXISMOTION: SDL_EventType = 7;
pub const SDL_EventType_SDL_JOYBALLMOTION: SDL_EventType = 8;
pub const SDL_EventType_SDL_JOYHATMOTION: SDL_EventType = 9;
pub const SDL_EventType_SDL_JOYBUTTONDOWN: SDL_EventType = 10;
pub const SDL_EventType_SDL_JOYBUTTONUP: SDL_EventType = 11;
pub const SDL_EventType_SDL_QUIT: SDL_EventType = 12;
pub const SDL_EventType_SDL_SYSWMEVENT: SDL_EventType = 13;
pub const SDL_EventType_SDL_EVENT_RESERVEDA: SDL_EventType = 14;
pub const SDL_EventType_SDL_EVENT_RESERVEDB: SDL_EventType = 15;
pub const SDL_EventType_SDL_VIDEORESIZE: SDL_EventType = 16;
pub const SDL_EventType_SDL_VIDEOEXPOSE: SDL_EventType = 17;
pub const SDL_EventType_SDL_EVENT_RESERVED2: SDL_EventType = 18;
pub const SDL_EventType_SDL_EVENT_RESERVED3: SDL_EventType = 19;
pub const SDL_EventType_SDL_EVENT_RESERVED4: SDL_EventType = 20;
pub const SDL_EventType_SDL_EVENT_RESERVED5: SDL_EventType = 21;
pub const SDL_EventType_SDL_EVENT_RESERVED6: SDL_EventType = 22;
pub const SDL_EventType_SDL_EVENT_RESERVED7: SDL_EventType = 23;
pub const SDL_EventType_SDL_USEREVENT: SDL_EventType = 24;
pub const SDL_EventType_SDL_NUMEVENTS: SDL_EventType = 32;
pub type SDL_EventType = ::std::os::raw::c_uint;
pub const SDL_EventMask_SDL_ACTIVEEVENTMASK: SDL_EventMask = 2;
pub const SDL_EventMask_SDL_KEYDOWNMASK: SDL_EventMask = 4;
pub const SDL_EventMask_SDL_KEYUPMASK: SDL_EventMask = 8;
pub const SDL_EventMask_SDL_KEYEVENTMASK: SDL_EventMask = 12;
pub const SDL_EventMask_SDL_MOUSEMOTIONMASK: SDL_EventMask = 16;
pub const SDL_EventMask_SDL_MOUSEBUTTONDOWNMASK: SDL_EventMask = 32;
pub const SDL_EventMask_SDL_MOUSEBUTTONUPMASK: SDL_EventMask = 64;
pub const SDL_EventMask_SDL_MOUSEEVENTMASK: SDL_EventMask = 112;
pub const SDL_EventMask_SDL_JOYAXISMOTIONMASK: SDL_EventMask = 128;
pub const SDL_EventMask_SDL_JOYBALLMOTIONMASK: SDL_EventMask = 256;
pub const SDL_EventMask_SDL_JOYHATMOTIONMASK: SDL_EventMask = 512;
pub const SDL_EventMask_SDL_JOYBUTTONDOWNMASK: SDL_EventMask = 1024;
pub const SDL_EventMask_SDL_JOYBUTTONUPMASK: SDL_EventMask = 2048;
pub const SDL_EventMask_SDL_JOYEVENTMASK: SDL_EventMask = 3968;
pub const SDL_EventMask_SDL_VIDEORESIZEMASK: SDL_EventMask = 65536;
pub const SDL_EventMask_SDL_VIDEOEXPOSEMASK: SDL_EventMask = 131072;
pub const SDL_EventMask_SDL_QUITMASK: SDL_EventMask = 4096;
pub const SDL_EventMask_SDL_SYSWMEVENTMASK: SDL_EventMask = 8192;
pub type SDL_EventMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_ActiveEvent {
    pub type_: Uint8,
    pub gain: Uint8,
    pub state: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ActiveEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ActiveEvent>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_ActiveEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ActiveEvent>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_ActiveEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ActiveEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ActiveEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ActiveEvent>())).gain as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ActiveEvent),
            "::",
            stringify!(gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ActiveEvent>())).state as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ActiveEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_KeyboardEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub state: Uint8,
    pub keysym: SDL_keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_KeyboardEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_KeyboardEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).state as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_KeyboardEvent>())).keysym as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(keysym)
        )
    );
}
impl Default for SDL_KeyboardEvent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub state: Uint8,
    pub x: Uint16,
    pub y: Uint16,
    pub xrel: Sint16,
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseMotionEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseMotionEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).state as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).xrel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseMotionEvent>())).yrel as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub button: Uint8,
    pub state: Uint8,
    pub x: Uint16,
    pub y: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseButtonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseButtonEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).button as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).state as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_MouseButtonEvent>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub axis: Uint8,
    pub value: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyAxisEvent>(),
        6usize,
        concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyAxisEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).axis as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyAxisEvent>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_JoyBallEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub ball: Uint8,
    pub xrel: Sint16,
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyBallEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyBallEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).ball as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(ball)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).xrel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyBallEvent>())).yrel as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_JoyHatEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub hat: Uint8,
    pub value: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyHatEvent>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyHatEvent>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).hat as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyHatEvent>())).value as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    pub type_: Uint8,
    pub which: Uint8,
    pub button: Uint8,
    pub state: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyButtonEvent>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyButtonEvent>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).button as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_JoyButtonEvent>())).state as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_ResizeEvent {
    pub type_: Uint8,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_ResizeEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ResizeEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_ResizeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ResizeEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ResizeEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ResizeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ResizeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ResizeEvent>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ResizeEvent),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ResizeEvent>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ResizeEvent),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_ExposeEvent {
    pub type_: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ExposeEvent>(),
        1usize,
        concat!("Size of: ", stringify!(SDL_ExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ExposeEvent>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_ExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_ExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ExposeEvent),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_QuitEvent {
    pub type_: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_QuitEvent>(),
        1usize,
        concat!("Size of: ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_QuitEvent>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_QuitEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_UserEvent {
    pub type_: Uint8,
    pub code: ::std::os::raw::c_int,
    pub data1: *mut ::std::os::raw::c_void,
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_UserEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_UserEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).data1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_UserEvent>())).data2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data2)
        )
    );
}
impl Default for SDL_UserEvent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMmsg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMEvent {
    pub type_: Uint8,
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SysWMEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_SysWMEvent>())).msg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(msg)
        )
    );
}
impl Default for SDL_SysWMEvent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    pub type_: Uint8,
    pub active: SDL_ActiveEvent,
    pub key: SDL_KeyboardEvent,
    pub motion: SDL_MouseMotionEvent,
    pub button: SDL_MouseButtonEvent,
    pub jaxis: SDL_JoyAxisEvent,
    pub jball: SDL_JoyBallEvent,
    pub jhat: SDL_JoyHatEvent,
    pub jbutton: SDL_JoyButtonEvent,
    pub resize: SDL_ResizeEvent,
    pub expose: SDL_ExposeEvent,
    pub quit: SDL_QuitEvent,
    pub user: SDL_UserEvent,
    pub syswm: SDL_SysWMEvent,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Event>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).button as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jaxis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jaxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jball as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jball)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jhat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jhat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).jbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).resize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).expose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(expose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).quit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_Event>())).syswm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(syswm)
        )
    );
}
impl Default for SDL_Event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SDL_PumpEvents();
}
pub const SDL_eventaction_SDL_ADDEVENT: SDL_eventaction = 0;
pub const SDL_eventaction_SDL_PEEKEVENT: SDL_eventaction = 1;
pub const SDL_eventaction_SDL_GETEVENT: SDL_eventaction = 2;
pub type SDL_eventaction = ::std::os::raw::c_uint;
extern "C" {
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: ::std::os::raw::c_int,
        action: SDL_eventaction,
        mask: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
pub type SDL_EventFilter =
    ::std::option::Option<unsafe extern "C" fn(event: *const SDL_Event) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter);
}
extern "C" {
    pub fn SDL_GetEventFilter() -> SDL_EventFilter;
}
extern "C" {
    pub fn SDL_EventState(type_: Uint8, state: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    pub fn SDL_LoadObject(sofile: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_LoadFunction(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_UnloadObject(handle: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
    pub fn SDL_Delay(ms: Uint32);
}
pub type SDL_TimerCallback =
    ::std::option::Option<unsafe extern "C" fn(interval: Uint32) -> Uint32>;
extern "C" {
    pub fn SDL_SetTimer(interval: Uint32, callback: SDL_TimerCallback) -> ::std::os::raw::c_int;
}
pub type SDL_NewTimerCallback = ::std::option::Option<
    unsafe extern "C" fn(interval: Uint32, param: *mut ::std::os::raw::c_void) -> Uint32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_TimerID {
    _unused: [u8; 0],
}
pub type SDL_TimerID = *mut _SDL_TimerID;
extern "C" {
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_NewTimerCallback,
        param: *mut ::std::os::raw::c_void,
    ) -> SDL_TimerID;
}
extern "C" {
    pub fn SDL_RemoveTimer(t: SDL_TimerID) -> SDL_bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_version {
    pub major: Uint8,
    pub minor: Uint8,
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    assert_eq!(
        ::std::mem::size_of::<SDL_version>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_version))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_version>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_version>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDL_version>())).patch as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    pub fn SDL_Linked_Version() -> *const SDL_version;
}
extern "C" {
    pub fn SDL_Init(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_InitSubSystem(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    pub fn SDL_Quit();
}
pub type byte = ::std::os::raw::c_uchar;
pub type INT16 = ::std::os::raw::c_short;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type INT32 = ::std::os::raw::c_int;
pub type UINT32 = ::std::os::raw::c_uint;
#[doc = " @ingroup access_time_local"]
#[doc = "Structure to hold msec and usec."]
#[doc = "\\sa current_micro"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MICRO {
    pub msec: INT32,
    pub usec: INT16,
}
#[test]
fn bindgen_test_layout_MICRO() {
    assert_eq!(
        ::std::mem::size_of::<MICRO>(),
        8usize,
        concat!("Size of: ", stringify!(MICRO))
    );
    assert_eq!(
        ::std::mem::align_of::<MICRO>(),
        4usize,
        concat!("Alignment of ", stringify!(MICRO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MICRO>())).msec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MICRO),
            "::",
            stringify!(msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MICRO>())).usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MICRO),
            "::",
            stringify!(usec)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Integer sample data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ISAMPLE {
    #[doc = "< time of sample"]
    pub time: UINT32,
    #[doc = "< always SAMPLE_TYPE"]
    pub type_: INT16,
    #[doc = "< flags to indicate contents"]
    pub flags: UINT16,
    #[doc = "< pupil x"]
    pub px: [INT16; 2usize],
    #[doc = "< pupil y"]
    pub py: [INT16; 2usize],
    #[doc = "< headref x"]
    pub hx: [INT16; 2usize],
    #[doc = "< headref y"]
    pub hy: [INT16; 2usize],
    #[doc = "< pupil size or area"]
    pub pa: [UINT16; 2usize],
    #[doc = "< screen gaze x"]
    pub gx: [INT16; 2usize],
    #[doc = "< screen gaze y"]
    pub gy: [INT16; 2usize],
    #[doc = "< screen pixels per degree"]
    pub rx: INT16,
    #[doc = "< screen pixels per degree"]
    pub ry: INT16,
    #[doc = "< tracker status flags"]
    pub status: UINT16,
    #[doc = "< extra (input word)"]
    pub input: UINT16,
    #[doc = "< button state & changes"]
    pub buttons: UINT16,
    #[doc = "< head-tracker data type (0=none)"]
    pub htype: INT16,
    #[doc = "< head-tracker data"]
    pub hdata: [INT16; 8usize],
}
#[test]
fn bindgen_test_layout_ISAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<ISAMPLE>(),
        64usize,
        concat!("Size of: ", stringify!(ISAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<ISAMPLE>(),
        4usize,
        concat!("Alignment of ", stringify!(ISAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).px as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).py as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).hx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(hx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).hy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(hy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).pa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).gx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).gy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).rx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).ry as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).input as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).buttons as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).htype as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ISAMPLE>())).hdata as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAMPLE),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Floating-point sample"]
#[doc = ""]
#[doc = "The EyeLink tracker measures eye position 250, 500, 1000 or 2000 times per second depending on"]
#[doc = "the tracking mode you are working with, and computes true gaze position on the display"]
#[doc = "using the head camera data. This data is stored in the EDF file, and made available"]
#[doc = "through the link in as little as 3 milliseconds after a physical eye movement."]
#[doc = "Samples can be read from the link by eyelink_get_float_data() or eyelink_newest_float_sample()."]
#[doc = ""]
#[doc = "If sample rate is 2000hz, two samples with same time stamp possible. If SAMPLE_ADD_OFFSET is set on the"]
#[doc = "flags, add .5 ms to get the real time. Convenient FLOAT_TIME can also be used."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAMPLE {
    #[doc = "< time of sample"]
    pub time: UINT32,
    #[doc = "< always SAMPLE_TYPE"]
    pub type_: INT16,
    #[doc = "< flags to indicate contents"]
    pub flags: UINT16,
    #[doc = "< pupil x"]
    pub px: [f32; 2usize],
    #[doc = "< pupil y"]
    pub py: [f32; 2usize],
    #[doc = "< headref x"]
    pub hx: [f32; 2usize],
    #[doc = "< headref y"]
    pub hy: [f32; 2usize],
    #[doc = "< pupil size or area"]
    pub pa: [f32; 2usize],
    #[doc = "< screen gaze x"]
    pub gx: [f32; 2usize],
    #[doc = "< screen gaze y"]
    pub gy: [f32; 2usize],
    #[doc = "< screen pixels per degree"]
    pub rx: f32,
    #[doc = "< screen pixels per degree"]
    pub ry: f32,
    #[doc = "< tracker status flags"]
    pub status: UINT16,
    #[doc = "< extra (input word)"]
    pub input: UINT16,
    #[doc = "< button state & changes"]
    pub buttons: UINT16,
    #[doc = "< head-tracker data type (0=none)"]
    pub htype: INT16,
    #[doc = "< head-tracker data (not prescaled)"]
    pub hdata: [INT16; 8usize],
}
#[test]
fn bindgen_test_layout_FSAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<FSAMPLE>(),
        96usize,
        concat!("Size of: ", stringify!(FSAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<FSAMPLE>(),
        4usize,
        concat!("Alignment of ", stringify!(FSAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).px as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).py as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).hx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(hx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).hy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(hy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).pa as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).gx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).gy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).rx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).ry as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).status as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).input as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).buttons as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).htype as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE>())).hdata as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Floating-point sample with floating point time"]
#[doc = ""]
#[doc = "The EyeLink tracker measures eye position 250, 500, 1000 or 2000 times per second depending on"]
#[doc = "the tracking mode you are working with, and computes true gaze position on the display"]
#[doc = "using the head camera data. This data is stored in the EDF file, and made available"]
#[doc = "through the link in as little as 3 milliseconds after a physical eye movement."]
#[doc = "Samples can be read from the link by eyelink_get_double_data() or eyelink_newest_double_sample()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DSAMPLE {
    #[doc = "< time of sample"]
    pub time: f64,
    #[doc = "< always SAMPLE_TYPE"]
    pub type_: INT16,
    #[doc = "< flags to indicate contents"]
    pub flags: UINT16,
    #[doc = "< pupil x"]
    pub px: [f32; 2usize],
    #[doc = "< pupil y"]
    pub py: [f32; 2usize],
    #[doc = "< headref x"]
    pub hx: [f32; 2usize],
    #[doc = "< headref y"]
    pub hy: [f32; 2usize],
    #[doc = "< pupil size or area"]
    pub pa: [f32; 2usize],
    #[doc = "< screen gaze x"]
    pub gx: [f32; 2usize],
    #[doc = "< screen gaze y"]
    pub gy: [f32; 2usize],
    #[doc = "< screen pixels per degree"]
    pub rx: f32,
    #[doc = "< screen pixels per degree"]
    pub ry: f32,
    #[doc = "< tracker status flags"]
    pub status: UINT16,
    #[doc = "< extra (input word)"]
    pub input: UINT16,
    #[doc = "< button state & changes"]
    pub buttons: UINT16,
    #[doc = "< head-tracker data type (0=none)"]
    pub htype: INT16,
    #[doc = "< head-tracker data (not prescaled)"]
    pub hdata: [INT16; 8usize],
}
#[test]
fn bindgen_test_layout_DSAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<DSAMPLE>(),
        104usize,
        concat!("Size of: ", stringify!(DSAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<DSAMPLE>(),
        8usize,
        concat!("Alignment of ", stringify!(DSAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).px as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).py as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).hx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(hx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).hy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(hy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).pa as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).gx as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).gy as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).rx as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).ry as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).status as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).input as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).buttons as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).htype as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSAMPLE>())).hdata as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DSAMPLE),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = "@internal"]
#[doc = "Used to access raw online data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAMPLE_RAW {
    pub struct_size: UINT32,
    pub raw_pupil: [f32; 2usize],
    pub raw_cr: [f32; 2usize],
    pub pupil_area: UINT32,
    pub cr_area: UINT32,
    pub pupil_dimension: [UINT32; 2usize],
    pub cr_dimension: [UINT32; 2usize],
    pub window_position: [UINT32; 2usize],
    pub pupil_cr: [f32; 2usize],
    pub cr_area2: UINT32,
    pub raw_cr2: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_FSAMPLE_RAW() {
    assert_eq!(
        ::std::mem::size_of::<FSAMPLE_RAW>(),
        72usize,
        concat!("Size of: ", stringify!(FSAMPLE_RAW))
    );
    assert_eq!(
        ::std::mem::align_of::<FSAMPLE_RAW>(),
        4usize,
        concat!("Alignment of ", stringify!(FSAMPLE_RAW))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).struct_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).raw_pupil as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(raw_pupil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).raw_cr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(raw_cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).pupil_area as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(pupil_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).cr_area as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(cr_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).pupil_dimension as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(pupil_dimension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).cr_dimension as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(cr_dimension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).window_position as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(window_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).pupil_cr as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(pupil_cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).cr_area2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(cr_area2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSAMPLE_RAW>())).raw_cr2 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAMPLE_RAW),
            "::",
            stringify!(raw_cr2)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Integer eye-movement events"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IEVENT {
    #[doc = "< effective time of event"]
    pub time: UINT32,
    #[doc = "< event type"]
    pub type_: INT16,
    #[doc = "< flags which items were included"]
    pub read: UINT16,
    #[doc = "< eye: 0=left,1=right"]
    pub eye: INT16,
    #[doc = "< start times"]
    pub sttime: UINT32,
    #[doc = "< end times"]
    pub entime: UINT32,
    #[doc = "< starting point x"]
    pub hstx: INT16,
    #[doc = "< starting point y"]
    pub hsty: INT16,
    #[doc = "< starting point x"]
    pub gstx: INT16,
    #[doc = "< starting point y"]
    pub gsty: INT16,
    pub sta: UINT16,
    #[doc = "< ending point x"]
    pub henx: INT16,
    #[doc = "< ending point y"]
    pub heny: INT16,
    #[doc = "< ending point x"]
    pub genx: INT16,
    #[doc = "< ending point y"]
    pub geny: INT16,
    pub ena: UINT16,
    #[doc = "< average x"]
    pub havx: INT16,
    #[doc = "< average y"]
    pub havy: INT16,
    #[doc = "< average x"]
    pub gavx: INT16,
    #[doc = "< average y"]
    pub gavy: INT16,
    #[doc = "< also used as accumulator"]
    pub ava: UINT16,
    #[doc = "< avg velocity accum"]
    pub avel: INT16,
    #[doc = "< peak velocity accum"]
    pub pvel: INT16,
    #[doc = "< start velocity"]
    pub svel: INT16,
    #[doc = "< end velocity"]
    pub evel: INT16,
    #[doc = "< start units-per-degree x"]
    pub supd_x: INT16,
    #[doc = "< end units-per-degree y"]
    pub eupd_x: INT16,
    #[doc = "< start units-per-degree y"]
    pub supd_y: INT16,
    #[doc = "< end units-per-degree y"]
    pub eupd_y: INT16,
    #[doc = "< error, warning flags"]
    pub status: UINT16,
}
#[test]
fn bindgen_test_layout_IEVENT() {
    assert_eq!(
        ::std::mem::size_of::<IEVENT>(),
        68usize,
        concat!("Size of: ", stringify!(IEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<IEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(IEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).read as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).eye as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).sttime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(sttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).entime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(entime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).hstx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(hstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).hsty as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(hsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gstx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gsty as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).sta as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(sta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).henx as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(henx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).heny as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(heny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).genx as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(genx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).geny as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(geny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).ena as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(ena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).havx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(havx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).havy as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(havy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gavx as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gavx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).gavy as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(gavy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).ava as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(ava)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).avel as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(avel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).pvel as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(pvel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).svel as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(svel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).evel as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(evel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).supd_x as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(supd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).eupd_x as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(eupd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).supd_y as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(supd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).eupd_y as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(eupd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IEVENT>())).status as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(IEVENT),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Floating-point eye event"]
#[doc = ""]
#[doc = "The EyeLink tracker analyzes the eye-position samples during recording to"]
#[doc = "detect saccades, and accumulates data on saccades and fixations. Events"]
#[doc = "are produced to mark the start and end of saccades, fixations and blinks."]
#[doc = "When both eyes are being tracked, left and right eye events are produced,"]
#[doc = "as indicated in the eye field of the FEVENT structure."]
#[doc = ""]
#[doc = "Start events contain only the start time, and optionally the start eye"]
#[doc = "or gaze position. End events contain the start and end time, plus summary"]
#[doc = "data on saccades and fixations. This includes start and end and average"]
#[doc = "measures of position and pupil size, plus peak and average velocity in"]
#[doc = "degrees per second."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FEVENT {
    #[doc = "< effective time of event"]
    pub time: UINT32,
    #[doc = "< event type"]
    pub type_: INT16,
    #[doc = "< flags which items were included"]
    pub read: UINT16,
    #[doc = "< eye: 0=left,1=right"]
    pub eye: INT16,
    #[doc = "< start times"]
    pub sttime: UINT32,
    #[doc = "< end times"]
    pub entime: UINT32,
    #[doc = "< starting point x"]
    pub hstx: f32,
    #[doc = "< starting point y"]
    pub hsty: f32,
    #[doc = "< starting point x"]
    pub gstx: f32,
    #[doc = "< starting point y"]
    pub gsty: f32,
    #[doc = "< starting area"]
    pub sta: f32,
    #[doc = "< ending point x"]
    pub henx: f32,
    #[doc = "< ending point y"]
    pub heny: f32,
    #[doc = "< ending point x"]
    pub genx: f32,
    #[doc = "< ending point y"]
    pub geny: f32,
    #[doc = "< ending area"]
    pub ena: f32,
    #[doc = "< average x"]
    pub havx: f32,
    #[doc = "< average y"]
    pub havy: f32,
    #[doc = "< average x"]
    pub gavx: f32,
    #[doc = "< average y"]
    pub gavy: f32,
    #[doc = "< average area"]
    pub ava: f32,
    #[doc = "< avg velocity accum"]
    pub avel: f32,
    #[doc = "< peak velocity accum"]
    pub pvel: f32,
    #[doc = "< start velocity"]
    pub svel: f32,
    #[doc = "< end velocity"]
    pub evel: f32,
    #[doc = "< start units-per-degree x"]
    pub supd_x: f32,
    #[doc = "< end units-per-degree x"]
    pub eupd_x: f32,
    #[doc = "< start units-per-degree y"]
    pub supd_y: f32,
    #[doc = "< end units-per-degree y"]
    pub eupd_y: f32,
    #[doc = "< error, warning flags"]
    pub status: UINT16,
}
#[test]
fn bindgen_test_layout_FEVENT() {
    assert_eq!(
        ::std::mem::size_of::<FEVENT>(),
        116usize,
        concat!("Size of: ", stringify!(FEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<FEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(FEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).read as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).eye as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).sttime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(sttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).entime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(entime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).hstx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(hstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).hsty as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(hsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gstx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gsty as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).sta as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(sta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).henx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(henx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).heny as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(heny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).genx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(genx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).geny as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(geny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).ena as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(ena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).havx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(havx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).havy as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(havy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gavx as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gavx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).gavy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(gavy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).ava as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(ava)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).avel as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(avel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).pvel as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(pvel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).svel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(svel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).evel as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(evel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).supd_x as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(supd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).eupd_x as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(eupd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).supd_y as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(supd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).eupd_y as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(eupd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FEVENT>())).status as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(FEVENT),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Floating-point eye event with floating point time"]
#[doc = ""]
#[doc = "The EyeLink tracker analyzes the eye-position samples during recording to"]
#[doc = "detect saccades, and accumulates data on saccades and fixations. Events"]
#[doc = "are produced to mark the start and end of saccades, fixations and blinks."]
#[doc = "When both eyes are being tracked, left and right eye events are produced,"]
#[doc = "as indicated in the eye field of the FEVENT structure."]
#[doc = ""]
#[doc = "Start events contain only the start time, and optionally the start eye"]
#[doc = "or gaze position. End events contain the start and end time, plus summary"]
#[doc = "data on saccades and fixations. This includes start and end and average"]
#[doc = "measures of position and pupil size, plus peak and average velocity in"]
#[doc = "degrees per second."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DEVENT {
    #[doc = "< effective time of event"]
    pub time: f64,
    #[doc = "< event type"]
    pub type_: INT16,
    #[doc = "< flags which items were included"]
    pub read: UINT16,
    #[doc = "< eye: 0=left,1=right"]
    pub eye: INT16,
    #[doc = "< start times"]
    pub sttime: f64,
    #[doc = "< end times"]
    pub entime: f64,
    #[doc = "< starting point x"]
    pub hstx: f32,
    #[doc = "< starting point y"]
    pub hsty: f32,
    #[doc = "< starting point x"]
    pub gstx: f32,
    #[doc = "< starting point y"]
    pub gsty: f32,
    #[doc = "< starting area"]
    pub sta: f32,
    #[doc = "< ending point x"]
    pub henx: f32,
    #[doc = "< ending point y"]
    pub heny: f32,
    #[doc = "< ending point x"]
    pub genx: f32,
    #[doc = "< ending point y"]
    pub geny: f32,
    #[doc = "< ending area"]
    pub ena: f32,
    #[doc = "< average x"]
    pub havx: f32,
    #[doc = "< average y"]
    pub havy: f32,
    #[doc = "< average x"]
    pub gavx: f32,
    #[doc = "< average y"]
    pub gavy: f32,
    #[doc = "< average area"]
    pub ava: f32,
    #[doc = "< avg velocity accum"]
    pub avel: f32,
    #[doc = "< peak velocity accum"]
    pub pvel: f32,
    #[doc = "< start velocity"]
    pub svel: f32,
    #[doc = "< end velocity"]
    pub evel: f32,
    #[doc = "< start units-per-degree x"]
    pub supd_x: f32,
    #[doc = "< end units-per-degree x"]
    pub eupd_x: f32,
    #[doc = "< start units-per-degree y"]
    pub supd_y: f32,
    #[doc = "< end units-per-degree y"]
    pub eupd_y: f32,
    #[doc = "< error, warning flags"]
    pub status: UINT16,
}
#[test]
fn bindgen_test_layout_DEVENT() {
    assert_eq!(
        ::std::mem::size_of::<DEVENT>(),
        128usize,
        concat!("Size of: ", stringify!(DEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<DEVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(DEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).read as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).eye as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).sttime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(sttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).entime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(entime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).hstx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(hstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).hsty as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(hsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gstx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gstx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gsty as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).sta as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(sta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).henx as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(henx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).heny as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(heny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).genx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(genx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).geny as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(geny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).ena as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(ena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).havx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(havx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).havy as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(havy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gavx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gavx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).gavy as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(gavy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).ava as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(ava)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).avel as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(avel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).pvel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(pvel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).svel as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(svel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).evel as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(evel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).supd_x as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(supd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).eupd_x as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(eupd_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).supd_y as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(supd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).eupd_y as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(eupd_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DEVENT>())).status as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(DEVENT),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Message events: usually text but may contain binary data"]
#[doc = ""]
#[doc = "A message event is created by your experiment program, and placed in the EDF file."]
#[doc = "It is possible to enable the sending of these messages back through the link,"]
#[doc = "although there is rarely a reason to do this. Although this method might be"]
#[doc = "used to determine the tracker time (the time field of a message event will indicate"]
#[doc = "when the message was received by the tracker), the use of eyelink_request_time()"]
#[doc = "and eyelink_read_time() is more efficient for retrieving the current time from the"]
#[doc = "eye tracker's timestamp clock. The eye tracker time is rarely needed in any case,"]
#[doc = "and would only be useful to compute link transport delays."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMESSAGE {
    #[doc = "< time message logged"]
    pub time: UINT32,
    #[doc = "< event type: usually MESSAGEEVENT"]
    pub type_: INT16,
    #[doc = "< length of message"]
    pub length: UINT16,
    #[doc = "< message contents (max length 255)"]
    pub text: [byte; 260usize],
}
#[test]
fn bindgen_test_layout_IMESSAGE() {
    assert_eq!(
        ::std::mem::size_of::<IMESSAGE>(),
        268usize,
        concat!("Size of: ", stringify!(IMESSAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<IMESSAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(IMESSAGE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMESSAGE>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMESSAGE),
            "::",
            stringify!(text)
        )
    );
}
impl Default for IMESSAGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup messaging"]
#[doc = "\\brief Message events: usually text but may contain binary data with floating point time."]
#[doc = ""]
#[doc = "A message event is created by your experiment program, and placed in the EDF file."]
#[doc = "It is possible to enable the sending of these messages back through the link,"]
#[doc = "although there is rarely a reason to do this. Although this method might be"]
#[doc = "used to determine the tracker time (the time field of a message event will indicate"]
#[doc = "when the message was received by the tracker), the use of eyelink_request_time()"]
#[doc = "and eyelink_read_time() is more efficient for retrieving the current time from the"]
#[doc = "eye tracker's timestamp clock. The eye tracker time is rarely needed in any case,"]
#[doc = "and would only be useful to compute link transport delays."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DMESSAGE {
    #[doc = "< time message logged"]
    pub time: f64,
    #[doc = "< event type: usually MESSAGEEVENT"]
    pub type_: INT16,
    #[doc = "< length of message"]
    pub length: UINT16,
    #[doc = "< message contents (max length 255)"]
    pub text: [byte; 260usize],
}
#[test]
fn bindgen_test_layout_DMESSAGE() {
    assert_eq!(
        ::std::mem::size_of::<DMESSAGE>(),
        272usize,
        concat!("Size of: ", stringify!(DMESSAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<DMESSAGE>(),
        8usize,
        concat!("Alignment of ", stringify!(DMESSAGE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).length as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DMESSAGE>())).text as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DMESSAGE),
            "::",
            stringify!(text)
        )
    );
}
impl Default for DMESSAGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Button, input, other simple events"]
#[doc = ""]
#[doc = "BUTTONEVENT and INPUTEVENT types are the simplest events, reporting"]
#[doc = "changes in button status or in the input port data. The time field"]
#[doc = "records the timestamp of the eye-data sample where the change occurred,"]
#[doc = "although the event itself is usually sent before that sample. The data"]
#[doc = "field contains the data after the change, in the same format as in the"]
#[doc = "FSAMPLE structure."]
#[doc = ""]
#[doc = "Button events from the link are rarely used; monitoring buttons with one"]
#[doc = "of eyelink_read_keybutton(), eyelink_last_button_press(), or"]
#[doc = "eyelink_button_states() is preferable, since these can report button"]
#[doc = "states at any time, not just during recording."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IOEVENT {
    #[doc = "< time logged"]
    pub time: UINT32,
    #[doc = "< event type:"]
    pub type_: INT16,
    #[doc = "< coded event data"]
    pub data: UINT16,
}
#[test]
fn bindgen_test_layout_IOEVENT() {
    assert_eq!(
        ::std::mem::size_of::<IOEVENT>(),
        8usize,
        concat!("Size of: ", stringify!(IOEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<IOEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(IOEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IOEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IOEVENT>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IOEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IOEVENT>())).data as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IOEVENT),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Button, input, other simple events with floating point time."]
#[doc = ""]
#[doc = "BUTTONEVENT and INPUTEVENT types are the simplest events, reporting"]
#[doc = "changes in button status or in the input port data. The time field"]
#[doc = "records the timestamp of the eye-data sample where the change occurred,"]
#[doc = "although the event itself is usually sent before that sample. The data"]
#[doc = "field contains the data after the change, in the same format as in the"]
#[doc = "FSAMPLE structure."]
#[doc = ""]
#[doc = "Button events from the link are rarely used; monitoring buttons with one"]
#[doc = "of eyelink_read_keybutton(), eyelink_last_button_press(), or"]
#[doc = "eyelink_button_states() is preferable, since these can report button"]
#[doc = "states at any time, not just during recording."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DIOEVENT {
    #[doc = "< time logged"]
    pub time: f64,
    #[doc = "< event type:"]
    pub type_: INT16,
    #[doc = "< coded event data"]
    pub data: UINT16,
}
#[test]
fn bindgen_test_layout_DIOEVENT() {
    assert_eq!(
        ::std::mem::size_of::<DIOEVENT>(),
        16usize,
        concat!("Size of: ", stringify!(DIOEVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<DIOEVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(DIOEVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIOEVENT>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIOEVENT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIOEVENT>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIOEVENT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIOEVENT>())).data as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DIOEVENT),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALL_DATA {
    pub ie: IEVENT,
    pub im: IMESSAGE,
    pub io: IOEVENT,
    pub is: ISAMPLE,
    _bindgen_union_align: [u32; 67usize],
}
#[test]
fn bindgen_test_layout_ALL_DATA() {
    assert_eq!(
        ::std::mem::size_of::<ALL_DATA>(),
        268usize,
        concat!("Size of: ", stringify!(ALL_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ALL_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(ALL_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).ie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(ie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALL_DATA>())).is as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALL_DATA),
            "::",
            stringify!(is)
        )
    );
}
impl Default for ALL_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Union of message, io event and float sample and float event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALLF_DATA {
    pub fe: FEVENT,
    pub im: IMESSAGE,
    pub io: IOEVENT,
    pub fs: FSAMPLE,
    _bindgen_union_align: [u32; 67usize],
}
#[test]
fn bindgen_test_layout_ALLF_DATA() {
    assert_eq!(
        ::std::mem::size_of::<ALLF_DATA>(),
        268usize,
        concat!("Size of: ", stringify!(ALLF_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ALLF_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(ALLF_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).fe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(fe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLF_DATA>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLF_DATA),
            "::",
            stringify!(fs)
        )
    );
}
impl Default for ALLF_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup messaging"]
#[doc = "\\brief Union of message, io event and double sample and double event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALLD_DATA {
    pub fe: DEVENT,
    pub im: DMESSAGE,
    pub io: DIOEVENT,
    pub fs: DSAMPLE,
    _bindgen_union_align: [u64; 34usize],
}
#[test]
fn bindgen_test_layout_ALLD_DATA() {
    assert_eq!(
        ::std::mem::size_of::<ALLD_DATA>(),
        272usize,
        concat!("Size of: ", stringify!(ALLD_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ALLD_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(ALLD_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).fe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(fe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ALLD_DATA>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALLD_DATA),
            "::",
            stringify!(fs)
        )
    );
}
impl Default for ALLD_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ELINKADDR = [byte; 16usize];
#[doc = " \\brief Name and address for connection."]
#[doc = ""]
#[doc = "Name and address for connection or ping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ELINKNODE {
    #[doc = "< address of the remote  or local tracker"]
    pub addr: ELINKADDR,
    #[doc = "< name of the remote  or local tracker"]
    pub name: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ELINKNODE() {
    assert_eq!(
        ::std::mem::size_of::<ELINKNODE>(),
        56usize,
        concat!("Size of: ", stringify!(ELINKNODE))
    );
    assert_eq!(
        ::std::mem::align_of::<ELINKNODE>(),
        1usize,
        concat!("Alignment of ", stringify!(ELINKNODE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ELINKNODE>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ELINKNODE),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ELINKNODE>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ELINKNODE),
            "::",
            stringify!(name)
        )
    );
}
impl Default for ELINKNODE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief Class to represent tracker status."]
#[doc = ""]
#[doc = "Class to represent tracker status information such as time stamps, flags, tracker addresses and so on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ILINKDATA {
    #[doc = "< time of last control event"]
    pub time: UINT32,
    #[doc = "< structure version"]
    pub version: UINT32,
    #[doc = "< 10*sample rate (0 if no samples, 1 if nonconstant)"]
    pub samrate: UINT16,
    #[doc = "< sample \"divisor\" (min msec between samples)"]
    pub samdiv: UINT16,
    #[doc = "< amount to divide gaze x,y,res by"]
    pub prescaler: UINT16,
    #[doc = "< amount to divide velocity by"]
    pub vprescaler: UINT16,
    #[doc = "< pupil prescale (1 if area, greater if diameter)"]
    pub pprescaler: UINT16,
    #[doc = "< head-distance prescale (to mm)"]
    pub hprescaler: UINT16,
    #[doc = "< 0 if off, else all flags"]
    pub sample_data: UINT16,
    #[doc = "< 0 if off, else all flags"]
    pub event_data: UINT16,
    #[doc = "< 0 if off, else event-type flags"]
    pub event_types: UINT16,
    #[doc = "< set if in block with samples"]
    pub in_sample_block: byte,
    #[doc = "< set if in block with events"]
    pub in_event_block: byte,
    #[doc = "< set if any left-eye data expected"]
    pub have_left_eye: byte,
    #[doc = "< set if any right-eye data expected"]
    pub have_right_eye: byte,
    #[doc = "< flags what we lost before last item"]
    pub last_data_gap_types: UINT16,
    #[doc = "< buffer-type code"]
    pub last_data_buffer_type: UINT16,
    #[doc = "< buffer size of last item"]
    pub last_data_buffer_size: UINT16,
    #[doc = "< set if control event read with last data"]
    pub control_read: UINT16,
    #[doc = "< set if control event started new block"]
    pub first_in_block: UINT16,
    #[doc = "< time field of item"]
    pub last_data_item_time: UINT32,
    #[doc = "< type: 100=sample, 0=none, else event type"]
    pub last_data_item_type: UINT16,
    #[doc = "< content: &lt;read&gt; (IEVENT), &lt;flags&gt; (ISAMPLE)"]
    pub last_data_item_contents: UINT16,
    #[doc = "< buffer containing last item"]
    pub last_data_item: ALL_DATA,
    #[doc = "< block in file"]
    pub block_number: UINT32,
    #[doc = "< samples read in block so far"]
    pub block_sample: UINT32,
    #[doc = "< events (excl. control read in block"]
    pub block_event: UINT32,
    #[doc = "< updated by samples only"]
    pub last_resx: UINT16,
    #[doc = "< updated by samples only"]
    pub last_resy: UINT16,
    #[doc = "< updated by samples only"]
    pub last_pupil: [UINT16; 2usize],
    #[doc = "< updated by samples, events"]
    pub last_status: UINT16,
    #[doc = "< number of items in queue"]
    pub queued_samples: UINT16,
    #[doc = "< includes control events"]
    pub queued_events: UINT16,
    #[doc = "< total queue buffer size"]
    pub queue_size: UINT16,
    #[doc = "< unused bytes in queue"]
    pub queue_free: UINT16,
    #[doc = "< time tracker last sent packet"]
    pub last_rcve_time: UINT32,
    #[doc = "< data type rcve enable (switch)"]
    pub samples_on: byte,
    pub events_on: byte,
    #[doc = "< status flags from data packet"]
    pub packet_flags: UINT16,
    #[doc = "< status flags from link packet header"]
    pub link_flags: UINT16,
    #[doc = "< tracker error state flags"]
    pub state_flags: UINT16,
    #[doc = "< tracker data output state"]
    pub link_dstatus: byte,
    #[doc = "< tracker commands pending"]
    pub link_pendcmd: byte,
    #[doc = "< 0 for EyeLink I or original EyeLink API DLL."]
    #[doc = "EYELINK II ONLY: MSB set if read"]
    #[doc = "crmode<<8 + file_filter<<4 + link_filter"]
    #[doc = "crmode = 0 if pupil, else pupil-CR"]
    #[doc = "file_filter, link_filter: 0, 1, or 2"]
    #[doc = "for level of heuristic filter applied"]
    pub reserved: UINT16,
    #[doc = "< a name for our machine"]
    pub our_name: [::std::os::raw::c_char; 40usize],
    pub our_address: ELINKADDR,
    #[doc = "< name of tracker connected to"]
    pub eye_name: [::std::os::raw::c_char; 40usize],
    pub eye_address: ELINKADDR,
    #[doc = "< Broadcast address for eye trackers"]
    pub ebroadcast_address: ELINKADDR,
    #[doc = "< Broadcast address for remotes"]
    pub rbroadcast_address: ELINKADDR,
    #[doc = "< 1 if polling remotes, else polling trackers"]
    pub polling_remotes: UINT16,
    #[doc = "< total nodes responding to polling"]
    pub poll_responses: UINT16,
    #[doc = "< data on nodes"]
    pub nodes: [ELINKNODE; 4usize],
}
#[test]
fn bindgen_test_layout_ILINKDATA() {
    assert_eq!(
        ::std::mem::size_of::<ILINKDATA>(),
        736usize,
        concat!("Size of: ", stringify!(ILINKDATA))
    );
    assert_eq!(
        ::std::mem::align_of::<ILINKDATA>(),
        4usize,
        concat!("Alignment of ", stringify!(ILINKDATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).samrate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(samrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).samdiv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(samdiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).prescaler as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(prescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).vprescaler as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(vprescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).pprescaler as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(pprescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).hprescaler as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(hprescaler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).sample_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(sample_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).event_data as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(event_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).event_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(event_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).in_sample_block as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(in_sample_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).in_event_block as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(in_event_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).have_left_eye as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(have_left_eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).have_right_eye as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(have_right_eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_gap_types as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_gap_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_buffer_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_buffer_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_buffer_size as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).control_read as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(control_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).first_in_block as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(first_in_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_item_time as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_item_type as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ILINKDATA>())).last_data_item_contents as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item_contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_data_item as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_data_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).block_number as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(block_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).block_sample as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(block_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).block_event as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(block_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_resx as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_resx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_resy as *const _ as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_resy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_pupil as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_pupil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_status as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queued_samples as *const _ as usize },
        338usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queued_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queued_events as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queued_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queue_size as *const _ as usize },
        342usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).queue_free as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(queue_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).last_rcve_time as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(last_rcve_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).samples_on as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(samples_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).events_on as *const _ as usize },
        353usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(events_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).packet_flags as *const _ as usize },
        354usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(packet_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).link_flags as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(link_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).state_flags as *const _ as usize },
        358usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(state_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).link_dstatus as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(link_dstatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).link_pendcmd as *const _ as usize },
        361usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(link_pendcmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).reserved as *const _ as usize },
        362usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).our_name as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(our_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).our_address as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(our_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).eye_name as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(eye_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).eye_address as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(eye_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).ebroadcast_address as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(ebroadcast_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).rbroadcast_address as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(rbroadcast_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).polling_remotes as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(polling_remotes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).poll_responses as *const _ as usize },
        510usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(poll_responses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ILINKDATA>())).nodes as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ILINKDATA),
            "::",
            stringify!(nodes)
        )
    );
}
impl Default for ILINKDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Use this function to initialize the EyeLink library.  This will also start"]
    #[doc = "the millisecond clock.  No connection is attempted to the eyetracker yet."]
    #[doc = "It is preferable to call open_eyelink_connection(\\c -1)  instead, as this"]
    #[doc = "prepares other parts of the DLL for use."]
    #[doc = ""]
    #[doc = "@remarks MUST BE FIRST CALL TO LINK INTERFACE."]
    #[doc = "@param bufsize Size of sample buffer.  \\c 60000 is the maximum allowed. (\\c 0 for default)"]
    #[doc = "@param options Text specifying initialization options.  Currently no options are supported."]
    #[doc = "(\\c NULL or \"\" for defaults)"]
    #[doc = "@return \\c 0 if failed, nonzero (\\c -1 or TSR SWI number) if success."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int dummy = 0;  // Sets the connection type"]
    #[doc = ""]
    #[doc = "if(!open_eyelink_system(0, \"\"))"]
    #[doc = "{"]
    #[doc = "printf(\"\\nERROR: Cannot initialize eyelink library\\n\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if(dummy)"]
    #[doc = "i = eyelink_dummy_open(); // Starts a dummy connection"]
    #[doc = "else"]
    #[doc = "i = eyelink_open();  // Connects to the tracker"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "set_offline_mode();"]
    #[doc = "eyecmd_printf(\"close_data_file\");    // close data file"]
    #[doc = "eyelink_close(1);         // disconnect from tracker"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "close_eyelink_system();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c close_eyelink_connection(), \\c close_eyelink_system(), \\c eyelink_close() and \\c eyelink_open()"]
    pub fn open_eyelink_system(bufsize: UINT16, options: *mut ::std::os::raw::c_char) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sets the node name of this computer (up to 35 characters)."]
    #[doc = ""]
    #[doc = "@param name String to become new name."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKNODE node;  // This will hold application name and address"]
    #[doc = ""]
    #[doc = "if (set_eyelink_address(\"100.1.1.7\"))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "eyelink_set_name(\"Newapplication\");"]
    #[doc = ""]
    #[doc = "if(eyelink_get_node(0, &node) == OK_RESULT)"]
    #[doc = "eyemsg_printf(\"%s\", node.name);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t2248248 Newapplication"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_node(), \\c open_eyelink_connection() and \\c set_eyelink_address()"]
    pub fn eyelink_set_name(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Resets the EyeLink library, releases the system resources used by the millisecond clock."]
    #[doc = ""]
    #[doc = "@remarks MUST DO BEFORE EXITING."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c open_eyelink_system()"]
    #[doc = ""]
    #[doc = "\\sa \\c open_eyelink_system(), \\c eyelink_close() and \\c set_offline_mode()"]
    pub fn close_eyelink_system();
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current millisecond since the initialization."]
    #[doc = ""]
    #[doc = "@remarks If the eyelink_exptkit library is not initialized, or initialized multiple times,"]
    #[doc = "the return value is invalid and the return value is unpredictable. So in order to avoid"]
    #[doc = "this, make sure that \\c close_eyelink_system() is called at the end."]
    #[doc = "The call to \\c current_msec() is always equivalent to \\c current_time()."]
    #[doc = "@return The current millisecond since the initialization of the library."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Delay test starts: %ld\", current_msec());"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf(\"Delay test ends: %ld\", current_time());"]
    #[doc = "\\endcode"]
    #[doc = "<pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t4532575 Delay test starts: 5236"]
    #[doc = "MSG\t4532671 Delay test ends: 5336"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c current_msec(), \\c current_micro(), \\c current_usec(), \\c eyelink_tracker_time() and \\c msec_delay()"]
    pub fn current_time() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current microsecond since the initialization."]
    #[doc = "Equivalent to \\c current_usec() and \\c current_double_usec()."]
    #[doc = ""]
    #[doc = "@param m Pointer to MICRO structure."]
    #[doc = "@return The current microsecond since the initialization of the library, modulo 2^32."]
    #[doc = "It can also fill in the \\c MICRO structure if the pointer is not \\c NULL."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c current_usec()"]
    #[doc = ""]
    #[doc = "\\sa \\c current_usec(), \\c current_double_usec(), \\c current_msec(), \\c current_time() and \\c msec_delay()"]
    pub fn current_micro(m: *mut MICRO) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current microsecond since the initialization."]
    #[doc = "Equivalent to \\c current_micro() and \\c current_double_usec()."]
    #[doc = ""]
    #[doc = "@remarks If the eyelink_exptkit library is not initialized, or initialized multiple times,"]
    #[doc = "the return value is invalid and unpredictable.  The call to"]
    #[doc = "\\c current_usec() is equivalent to \\c current_micro(NULL).  The function is very"]
    #[doc = "platform dependent. Platforms such as windows 95, 98, ME may not return usec"]
    #[doc = "properly. Ie. It may return <tt>current_time() * 1000</tt>."]
    #[doc = "@return The current microsecond since the initialization of the library, modulo 2^32."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "MICRO m1, m2;  // Special high-resolution time structure"]
    #[doc = ""]
    #[doc = "current_micro(&m1);"]
    #[doc = "eyemsg_printf(\"Delay test starts: %ld\", current_usec());"]
    #[doc = ""]
    #[doc = "msec_delay(100);"]
    #[doc = ""]
    #[doc = "current_micro(&m2);"]
    #[doc = "eyemsg_printf(\"Delay test ends: %ld\", current_usec());"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Total Delay: %6.3f\","]
    #[doc = "m2.msec + m2.usec/1000.0 - m1.msec + m1.usec/1000.0);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t5441107 Delay test starts: 4610094"]
    #[doc = "MSG\t5441206 Delay test ends: 4710005"]
    #[doc = "MSG\t5441206 Total Delay: 100.003"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c current_micro(), \\c current_double_usec(), \\c current_msec(), \\c current_time() and \\c msec_delay()"]
    pub fn current_usec() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Does a unblocked delay using \\c current_time()."]
    #[doc = ""]
    #[doc = "@param n n milliseconds to delay."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Delay test starts: %ld\", current_msec());"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf(\"Delay test ends: %ld\", current_time());"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t4346690 Delay test starts: 12768"]
    #[doc = "MSG\t4346791 Delay test ends: 12868"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c current_msec() and \\c pump_delay()"]
    pub fn msec_delay(n: UINT32);
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Returns the current microsecond as double (56 bits) since the initialization."]
    #[doc = "Equivalent to \\c current_micro() and \\c current_usec()."]
    #[doc = ""]
    #[doc = "@return The current microsecond as a double value since the initialization of the library, modulo 2^32."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c current_usec()"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\sa \\c current_micro(), \\c current_usec(), \\c current_msec(), \\c current_time() and \\c msec_delay()"]
    pub fn current_double_usec() -> f64;
}
extern "C" {
    pub static mut eye_broadcast_address: ELINKADDR;
}
extern "C" {
    pub static mut rem_broadcast_address: ELINKADDR;
}
extern "C" {
    pub static mut our_address: ELINKADDR;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Allows the computer to connect to tracker, where the tracker is on the same network."]
    #[doc = ""]
    #[doc = "@param node Must be an address returned by \\c eyelink_poll_trackers() and"]
    #[doc = "\\c eyelink_poll_responses() to connect to any tracker."]
    #[doc = "@param busytest If non-zero the call to \\c eyelink_open_node() will not disconnect an existing connection."]
    #[doc = "@return \\c 0 if successful.\\n"]
    #[doc = "\\c LINK_INITIALIZE_FAILED  if link could not be established.\\n"]
    #[doc = "\\c CONNECT_TIMEOUT_FAILED  if tracker did not respond.\\n"]
    #[doc = "\\c WRONG_LINK_VERSION if the versions of the EyeLink library and tracker are incompatible.\\n"]
    #[doc = "\\c TRACKER_BUSY if \\c &lt;busytest&gt; is set, and tracker is connected to another computer.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "ELINKADDR node;\t\t\t\t// EyeLink address node"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "text_to_elinkaddr(\"100.1.1.1\", node, 0);"]
    #[doc = ""]
    #[doc = "if (eyelink_open_node(node, 1))"]
    #[doc = "return -1;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_node_receive(), \\c eyelink_node_send(), \\c eyelink_node_send_message() and \\c eyelink_open()"]
    pub fn eyelink_open_node(node: *mut byte, busytest: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Attempts to open a link connection to the EyeLink tracker.  Simple connect to single Eyelink tracker."]
    #[doc = "Equivalent to \\c eyelink_open_node(broadcast_address, 0)."]
    #[doc = ""]
    #[doc = "@remarks The tracker address can be set by calling the function \\c set_eyelink_address().  If this"]
    #[doc = "address was \"255.255.255.255\" the call to \\c eyelink_open() will \"broadcast\" a request"]
    #[doc = "to any tracker, however this may fail if multiple Ethernet cards are installed."]
    #[doc = "For the broadcast option to work use EyeLink I v2.1 or higher, EyeLink II v1.1 or higher."]
    #[doc = "Before using this command, call either \\c open_eyelink_connection(-1) or"]
    #[doc = "\\c open_eyelink_system () to prepare the link for use."]
    #[doc = ""]
    #[doc = "@return \\c 0 if successful.\\n"]
    #[doc = "\\c LINK_INITIALIZE_FAILED  if link could not be established.\\n"]
    #[doc = "\\c CONNECT_TIMEOUT_FAILED  if tracker did not respond.\\n"]
    #[doc = "\\c WRONG_LINK_VERSION if the versions of the EyeLink library and tracker are incompatible.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "set_eyelink_address(\"100.1.1.1\");"]
    #[doc = ""]
    #[doc = "if (eyelink_open())"]
    #[doc = "return -1;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open(), \\c eyelink_close(), \\c eyelink_dummy_open(), \\c eyelink_open_node(),"]
    #[doc = "\\c open_eyelink_connection(), \\c open_eyelink_system() and \\c set_eyelink_address()"]
    pub fn eyelink_open() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Allows a third computer to listen in on a session between the eye tracker and a controlling"]
    #[doc = "remote machine.  This allows it to receive data during recording and playback, and to monitor"]
    #[doc = "the eye tracker mode.  The local computer will not be able to send commands to the eye tracker,"]
    #[doc = "but may be able to send messages or request the tracker time."]
    #[doc = ""]
    #[doc = "@remarks May not function properly, if there are more than one Ethernet cards installed."]
    #[doc = "@return \\c 0 if successful.\\n"]
    #[doc = "\\c LINK_INITIALIZE_FAILED  if link could not be established.\\n"]
    #[doc = "\\c CONNECT_TIMEOUT_FAILED  if tracker did not respond.\\n"]
    #[doc = "\\c WRONG_LINK_VERSION if the versions of the EyeLink library and tracker are incompatible.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "eyelink_set_name(\"Broadcast\");"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_broadcast_open())"]
    #[doc = "{"]
    #[doc = "printf(\"Cannot open broadcast connection to tracker\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyelink_reset_data(1);"]
    #[doc = "eyelink_data_switch(RECORD_LINK_SAMPLES | RECORD_LINK_EVENTS);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_close(), \\c eyelink_dummy_open(), \\c eyelink_is_connected(), \\c eyelink_open() and"]
    #[doc = "\\c eyelink_open_node()"]
    pub fn eyelink_broadcast_open() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sets the EyeLink library to simulate an eyetracker connection.  Functions will return"]
    #[doc = "plausible values, but no data."]
    #[doc = ""]
    #[doc = "@remarks The function \\c eyelink_is_connected() will return \\c -1 to indicate a simulated connection."]
    #[doc = "@return Always returns \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "eyelink_dummy_open();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open(), \\c eyelink_open() and \\c eyelink_open_node()"]
    pub fn eyelink_dummy_open() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sends a disconnect message to the EyeLink tracker, resets the link data system."]
    #[doc = ""]
    #[doc = "@param send_msg Usually \\c &lt;send_msg&gt; is \\c 1. However, \\c 0 can be used to reset the eyelink system"]
    #[doc = "if it is listening on a broadcast session."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "set_offline_mode();      \t// off-line mode"]
    #[doc = "eyecmd_printf(\"close_data_file\");"]
    #[doc = "eyelink_close(1);         // disconnect from tracker"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open(), \\c eyelink_open(), \\c eyelink_dummy_open() and \\c eyelink_open_node()"]
    pub fn eyelink_close(send_msg: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup access_time_local"]
    #[doc = "Initializes the high frequency clock."]
    #[doc = ""]
    #[doc = "With TSR interface under msdos, Start/stop timing resources."]
    #[doc = ""]
    #[doc = "@param enable Usually \\c &lt;enable&gt; is \\c 1. However, in MS-DOS passing \\c 0 will cleanup the timing resources."]
    #[doc = "In other platforms passing \\c 0 has no effect."]
    pub fn eyelink_reset_clock(enable: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Checks whether the connection to the tracker is alive."]
    #[doc = ""]
    #[doc = "@remarks Call this routine during loops and wherever the experiment might lock up if"]
    #[doc = "the tracker is shut down.  Exit the experiment (by terminating loops and"]
    #[doc = "returning from all calls) if this returns \\c 0."]
    #[doc = "@return \\c 0 if link closed.\\n"]
    #[doc = "\\c -1 if simulating connection.\\n"]
    #[doc = "\\c 1 for normal connection.\\n"]
    #[doc = "\\c 2 for broadcast connection (NEW for v2.1 and later).\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "error = do_drift_correct(SCRWIDTH/2, SCRHEIGHT/2, 1, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27) break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_close() and \\c eyelink_open()"]
    pub fn eyelink_is_connected() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Controls the level of control an application has over the tracker."]
    #[doc = ""]
    #[doc = "@remarks This is used in combination with broadcast mode (multiple applications connected to one tracker)"]
    #[doc = "to ensure that \"listener\" applications do not inadvertently send commands, key presses, or"]
    #[doc = "messages to the tracker.  This is mostly useful when quickly converting an existing"]
    #[doc = "application into a listener."]
    #[doc = "@param mode \\c 0 to allow all communication.\\n"]
    #[doc = "\\c 1 to block commands (allows only key presses, messages, and time or variable read requests).\\n"]
    #[doc = "\\c 2 to disable all commands, requests and messages.\\n"]
    #[doc = "\\c -1 to just return current setting.\\n"]
    #[doc = "@return The previous settings."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(eyelink_broadcast_open())"]
    #[doc = "{"]
    #[doc = "printf(\"Cannot open broadcast connection to tracker\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyelink_reset_data(1);"]
    #[doc = "eyelink_data_switch(RECORD_LINK_SAMPLES | RECORD_LINK_EVENTS);"]
    #[doc = ""]
    #[doc = "eyelink_quiet_mode(0);\t// Allows for message sending"]
    #[doc = "eyelink_send_message(\"This should be recorded in the EDF file\");"]
    #[doc = "eyelink_quiet_mode(2);   // Disables message sending"]
    #[doc = "eyelink_send_message(\"This should not appear in the EDF file\");"]
    #[doc = "eyelink_quiet_mode(0);   // Allows for message sending again"]
    #[doc = "eyelink_send_message(\"This should appear in the EDF file\");"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t3304947 This message should be recorded in the EDF file"]
    #[doc = "MSG\t3304947 This message should appear in the EDF file"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_broadcast_open() and \\c eyelink_open()"]
    pub fn eyelink_quiet_mode(mode: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Asks all trackers (with EyeLink software running) on the network to send their names and node address."]
    #[doc = ""]
    #[doc = "@return \\c OK_RESULT if successful, otherwise link error."]
    #[doc = "@return \\c LINK_TERMINATED_RESULT if link error."]
    #[doc = "@return \\c -1 if broadcast option is not available."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_poll_remotes()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_poll_remotes() and \\c eyelink_poll_responses()"]
    pub fn eyelink_poll_trackers() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Asks all non-tracker computers (with EyeLink software running) on the network to send their names"]
    #[doc = "and node address."]
    #[doc = ""]
    #[doc = "@return \\c OK_RESULT if successful, otherwise link error."]
    #[doc = "@return \\c LINK_TERMINATED_RESULT if link error."]
    #[doc = "@return \\c -1 if broadcast option is not available."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKADDR listener_address;  // Address of listener application"]
    #[doc = ""]
    #[doc = "int check_for_listener(void)"]
    #[doc = "{"]
    #[doc = "int i, n;"]
    #[doc = "ELINKNODE node;  // This will hold application name and address"]
    #[doc = ""]
    #[doc = "eyelink_poll_remotes(); // Polls network for EyeLink applications"]
    #[doc = "pump_delay(500);        // Gives applications time to respond"]
    #[doc = ""]
    #[doc = "n = eyelink_poll_responses();  // How many responses?"]
    #[doc = "for(i = 1; i<= n; i++)"]
    #[doc = "{"]
    #[doc = "if(eyelink_get_node(i, &node) < 0)"]
    #[doc = "return -1;  // error: no such data"]
    #[doc = ""]
    #[doc = "if(!_stricmp(node.name, \"comm_listener\"))"]
    #[doc = "{"]
    #[doc = "memcpy(listener_address, node.addr, sizeof(ELINKADDR));"]
    #[doc = ""]
    #[doc = "eyelink_node_send(listener_address, \"NAME comm_simple\", 40);"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "return 0;   // all communication checks out"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "return -1;    // no listener node found"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_poll_responses() and \\c eyelink_poll_trackers()"]
    pub fn eyelink_poll_remotes() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Returns the count of node addresses received so far following the call of"]
    #[doc = "\\c eyelink_poll_remotes() or \\c eyelink_poll_trackers()."]
    #[doc = ""]
    #[doc = "@remarks You should allow about 100 milliseconds for all nodes to respond.  Up to 4 node"]
    #[doc = "responses are saved."]
    #[doc = "@return Number of nodes responded.  \\c 0 if no responses."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_poll_remotes()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_poll_remotes() and \\c eyelink_poll_trackers()"]
    pub fn eyelink_poll_responses() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Reads the responses returned by other trackers or remotes in response to"]
    #[doc = "\\c eyelink_poll_trackers() or \\c eyelink_poll_remotes(). It can also read the tracker"]
    #[doc = "broadcast address and remote broadcast addresses."]
    #[doc = ""]
    #[doc = "@param resp Nmber of responses to read:\\c 0 gets our data, \\c 1 get first response, \\c 2 gets the"]
    #[doc = "second response, etc. \\c -1 to read the tracker broadcast address. \\c -2 to read"]
    #[doc = "remote broadcast addresses."]
    #[doc = "@param data Pointer to buffer of \\c ELINKNODE type, to hold name and \\c ELINKADDR of the respondent."]
    #[doc = "@return \\c 0 if OK, \\c -1 if node response number is too high."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_poll_remotes()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_node_receive(), \\c eyelink_node_send() and \\c eyelink_poll_remotes()"]
    pub fn eyelink_get_node(resp: INT16, data: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a given data to the given node."]
    #[doc = ""]
    #[doc = "@param node \\c ELINKADDR node address."]
    #[doc = "@param data Pointer to buffer containing data to send."]
    #[doc = "@param dsize Number of bytes of data. Maximum \\c ELREMBUFSIZE bytes."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKADDR listener_address; // Address of the listener application"]
    #[doc = "char text_message[256], echo_message[256];"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "sprintf(text_message, \"START_RECORD\");"]
    #[doc = "eyelink_node_send(listener_address, text_message, 40);"]
    #[doc = ""]
    #[doc = "while (1)"]
    #[doc = "{"]
    #[doc = "k = eyelink_node_receive(listener_address, echo_message);"]
    #[doc = "if (k > 0 && strstr(echo_message, text_message))"]
    #[doc = "break;"]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ELINKADDR sender_address; // Address of the sender application"]
    #[doc = "char text_message[256], echo_message[256];"]
    #[doc = ""]
    #[doc = "k = eyelink_node_receive(sender_address, text_message);"]
    #[doc = ""]
    #[doc = "if(k > 0 && !_strnicmp(text_message, \"START_RECORD\", 12))"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(text_message);"]
    #[doc = "error = start_recording(1,1,1,1); // Starts recording"]
    #[doc = "if(error != 0)"]
    #[doc = "return error;        // Return error code if failed"]
    #[doc = ""]
    #[doc = "sprintf(echo_message, \"ECHO %s\", text_message);"]
    #[doc = "eyelink_node_send(sender_address, echo_message, 60);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_get_node(), \\c eyelink_node_receive() and \\c eyelink_open_node()"]
    pub fn eyelink_node_send(
        node: *mut byte,
        data: *mut ::std::os::raw::c_void,
        dsize: UINT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Checks for and gets the last packet received, stores the data and the node address sent from."]
    #[doc = ""]
    #[doc = "@remarks Data can only be read once, and is overwritten if a new packet arrives before the"]
    #[doc = "last packet has been read."]
    #[doc = "@param node Address of the sender."]
    #[doc = "@param data Pointer to a buffer to hold the data."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_node_send()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_open_node() and \\c eyelink_node_send()"]
    pub fn eyelink_node_receive(node: *mut byte, data: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a command to the connected eye tracker."]
    #[doc = ""]
    #[doc = "@remarks If \\c eyelink_send_commnd() is used, the text command will be executed, and a"]
    #[doc = "result code returned that can be read with \\c eyelink_command_result()."]
    #[doc = "@param text String command to send."]
    #[doc = "@return \\c 0 if successful, otherwise link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT32 t;"]
    #[doc = "int i, j;"]
    #[doc = "char buf[256];"]
    #[doc = ""]
    #[doc = "eyelink_send_command(\"button_function 1 'accept_target_fixation'\");"]
    #[doc = ""]
    #[doc = "t = current_msec();"]
    #[doc = "while(current_msec()-t < 1000)"]
    #[doc = "{"]
    #[doc = "i = eyelink_command_result();"]
    #[doc = "j = eyelink_last_message(buf);"]
    #[doc = ""]
    #[doc = "if (i == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Command executed successfully: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "else if (i!=NO_REPLY)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Error in executing command: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t4608038 Command executed successfully: OK"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_command_result() and \\c eyelink_timed_command()"]
    pub fn eyelink_send_command(text: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Check for and retrieves the numeric result code sent by the tracker from the last command."]
    #[doc = ""]
    #[doc = "@return \\c NO_REPLY if no reply to last command.\\n"]
    #[doc = "<tt>OK_RESULT (0)</tt> if OK.\\n"]
    #[doc = "Other error codes represent tracker execution error.\\n"]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_send_command()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_last_message(), \\c eyelink_send_command() and \\c eyelink_timed_command()"]
    pub fn eyelink_command_result() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a command to the connected eye tracker, wait for reply."]
    #[doc = ""]
    #[doc = "@remarks If \\c eyelink_send_command() is used, the text command will be executed, and a result"]
    #[doc = "code returned that can be read with \\c eyelink_command_result()."]
    #[doc = "@param text String command to send."]
    #[doc = "@param msec Maximum milliseconds to wait for reply."]
    #[doc = "@return <tt>OK_RESULT (0)</tt> if OK.\\n"]
    #[doc = "\\c NO_REPLY if timed out.\\n"]
    #[doc = "\\c LINK_TERMINATED_RESULT if cannot send.\\n"]
    #[doc = "other error codes represent tracker execution error.\\n"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "INT16 error;"]
    #[doc = "char buf[256];"]
    #[doc = ""]
    #[doc = "error = eyelink_timed_command(1000, \"button_function 5"]
    #[doc = "'accept_target_fixation'\");"]
    #[doc = ""]
    #[doc = "if (error)"]
    #[doc = "{"]
    #[doc = "eyelink_last_message(buf);"]
    #[doc = "eyemsg_printf(\"Error in excuting the command: %s\", buf);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_command_result() and \\c eyelink_send_command()"]
    pub fn eyelink_timed_command(msec: UINT32, text: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Checks for and gets the last packet received, stores the data and the node address sent from."]
    #[doc = ""]
    #[doc = "@param buf String buffer to return text message."]
    #[doc = "@return \\c 0 if no message since last command sent, otherwise length of string."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_timed_command()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_send_command() and \\c eyelink_timed_command()"]
    pub fn eyelink_last_message(buf: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a text message the connected eye tracker.  The text will be added to the EDF file."]
    #[doc = ""]
    #[doc = "@param msg Text to send to the tracker."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_quiet_mode()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_node_send_message(), \\c eyelink_quiet_mode() and \\c set_eyelink_address()"]
    pub fn eyelink_send_message(msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a text message the connected eye tracker.  The text will be added to the EDF file."]
    #[doc = ""]
    #[doc = "@remarks NEW (v2.1): If the link is initialized but not connected to a tracker, the"]
    #[doc = "message will be sent to the tracker set by \\c set_eyelink_address()."]
    #[doc = "@param msg Text to send to the tracker."]
    #[doc = "@param node Address of the tracker."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_quiet_mode()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_send_message(), \\c eyelink_quiet_mode() and \\c set_eyelink_address()"]
    pub fn eyelink_node_send_message(node: *mut byte, msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Send a data file message string to connected tracker with time offset."]
    #[doc = "@param exectime time offset. If the offset is 0, this function is the same as eyelink_send_message()"]
    #[doc = "@param msg Message to be sent"]
    #[doc = "@return \\c OK_RESULT or \\c LINK_TERMINATED_RESULT."]
    #[doc = "@sa eyemsg_printf_ex(), eyelink_send_message()"]
    pub fn eyelink_send_message_ex(exectime: UINT32, msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Send a data file message to any or all trackers with time offset."]
    #[doc = "@param exectime time offset. If the offset is 0, this function is the same as eyelink_node_send_message()"]
    #[doc = "@param node Node address"]
    #[doc = "@param msg Message to be sent"]
    #[doc = "@return \\c OK_RESULT or \\c LINK_TERMINATED_RESULT."]
    #[doc = "@sa eyelink_node_send_message()"]
    pub fn eyelink_node_send_message_ex(
        exectime: UINT32,
        node: *mut byte,
        msg: *mut ::std::os::raw::c_char,
    ) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Sends a text variable name whose value is to be read and returned by the tracker as a text string."]
    #[doc = ""]
    #[doc = "@remarks NEW (v2.1): If the link is initialized but not connected to a tracker, the message will"]
    #[doc = "be sent to the tracker set by \\c set_eyelink_address(). However, these requests will be"]
    #[doc = "ignored by tracker versions older than EyeLink I v2.1 and EyeLink II v1.1."]
    #[doc = "@param text String with message to send."]
    #[doc = "@return \\c 0 if success, otherwise link error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "int read_tracker_pixel_coords(void)"]
    #[doc = "{"]
    #[doc = "char buf[100] = \"\";"]
    #[doc = "UINT32 t;"]
    #[doc = ""]
    #[doc = "if(!eyelink_is_connected() || break_pressed())"]
    #[doc = "return 1;"]
    #[doc = ""]
    #[doc = "eyelink_read_request(\"screen_pixel_coords\");"]
    #[doc = ""]
    #[doc = "t = current_msec();"]
    #[doc = "while(current_msec()-t < 500)"]
    #[doc = "{"]
    #[doc = "if(eyelink_read_reply(buf) == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"%s\", buf);"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "message_pump(NULL);  // Keeps Windows happy"]
    #[doc = "if(!eyelink_is_connected) return 1;"]
    #[doc = "if(break_pressed()) return 1;"]
    #[doc = "}"]
    #[doc = "return -1;  // Timed out"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t374986 0.000000,0.000000,1023.000000,767.000000"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_read_reply()"]
    pub fn eyelink_read_request(text: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Returns text with reply to last read request."]
    #[doc = ""]
    #[doc = "@param buf String to contain text."]
    #[doc = "@return <tt>OK_RESULT (0)</tt> if response received.\\n"]
    #[doc = "\\c NO_REPLY if no response yet."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_read_request()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_read_request()"]
    pub fn eyelink_read_reply(buf: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Sends a request the connected eye tracker to return its current time."]
    #[doc = ""]
    #[doc = "@remarks The time reply can be read with \\c eyelink_read_time()."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT32 current_tracker_time()"]
    #[doc = "{"]
    #[doc = "UINT32  time_subject=0, time_tracker=0;"]
    #[doc = ""]
    #[doc = "eyelink_request_time();        // request the tracker PC time"]
    #[doc = "time_subject = current_msec();"]
    #[doc = "while(!time_tracker && current_msec() -time_subject < 50)"]
    #[doc = "time_tracker = eyelink_read_time();  // read tracker PC time"]
    #[doc = ""]
    #[doc = "return time_tracker;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_node_request_time() and \\c eyelink_read_time()"]
    #[doc = "@deprecated  This function is depricated. It is left for compatibility reasons."]
    pub fn eyelink_request_time() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Sends a request the connected eye tracker to return its current time."]
    #[doc = ""]
    #[doc = "@remarks The time reply can be read with \\c eyelink_read_time()."]
    #[doc = "@param node Address of a specific tracker."]
    #[doc = "@return \\c 0 if no error, else link error code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_request_time()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_request_time() and \\c eyelink_read_time()"]
    pub fn eyelink_node_request_time(node: *mut byte) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the tracker time requested by \\c eyelink_request_time() or \\c eyelink_node_request_time()."]
    #[doc = ""]
    #[doc = "@return \\c 0 if no response yet,  else timestamp in millisecond."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_request_time()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_node_request_time() and \\c eyelink_request_time()"]
    pub fn eyelink_read_time() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Places EyeLink tracker in off-line (idle) mode."]
    #[doc = ""]
    #[doc = "@remarks Use before attempting to draw graphics on the tracker display,"]
    #[doc = "transferring files, or closing link. Always call \\c eyelink_wait_for_mode_ready()"]
    #[doc = "afterwards to ensure tracker has finished the mode transition. This function"]
    #[doc = "pair is implemented by the eyelink_exptkit library function \\c set_offline_mode()."]
    #[doc = "@return \\c 0 if mode switch begun, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"heuristic_filter = ON\");"]
    #[doc = "eyelink_abort();    // stop data flow"]
    #[doc = "eyelink_wait_for_mode_ready(500); // wait till finished mode switch"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_wait_for_mode_ready() and \\c set_offline_mode()"]
    pub fn eyelink_abort() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Enters setup mode"]
    pub fn eyelink_start_setup() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Checks if tracker is still in a Setup menu activity (includes camera image view, calibration,"]
    #[doc = "and validation).  Used to terminate the subject setup loop."]
    #[doc = ""]
    #[doc = "@return \\c 0 if no longer in setup mode."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int current_mode;"]
    #[doc = "int prev_mode =0;"]
    #[doc = "UINT start_time  = current_msec();"]
    #[doc = ""]
    #[doc = "while(current_msec() < start_time + 10000)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "current_mode =eyelink_in_setup();"]
    #[doc = "if (current_mode!=prev_mode)"]
    #[doc = "eyemsg_printf(\"%s\", current_mode?\"In setup\":\"Not in setup\");"]
    #[doc = ""]
    #[doc = "prev_mode = current_mode;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t905992 In setup"]
    #[doc = "MSG\t909596 Not in setup"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_current_mode()"]
    pub fn eyelink_in_setup() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Returns the current target position and state."]
    #[doc = ""]
    #[doc = "@param x Pointer to variable to hold target X position."]
    #[doc = "@param y Pointer to variable to hold target Y position."]
    #[doc = "@return \\c 1 if target is visible, 0 if not."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "INT16 target_mode_display(void)"]
    #[doc = "{"]
    #[doc = "int target_visible = 0;\t// target currently drawn"]
    #[doc = "INT16 tx;\t\t// new target position"]
    #[doc = "INT16 ty;"]
    #[doc = ""]
    #[doc = "INT16 otx=MISSING;    // current target position"]
    #[doc = "INT16 oty=MISSING;"]
    #[doc = ""]
    #[doc = "unsigned key;\t\t// local key pressed"]
    #[doc = "int i;"]
    #[doc = "int result = NO_REPLY;"]
    #[doc = ""]
    #[doc = "while(eyelink_current_mode() & IN_TARGET_MODE)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected()) return -1;"]
    #[doc = "key = getkey();"]
    #[doc = "if(key)"]
    #[doc = "{"]
    #[doc = "switch(key)"]
    #[doc = "{"]
    #[doc = "case TERMINATE_KEY:       // breakout key code"]
    #[doc = "clear_cal_display();"]
    #[doc = "return TERMINATE_KEY;"]
    #[doc = "case 32:\t         \t// Spacebar: accept fixation"]
    #[doc = "eyelink_accept_trigger();"]
    #[doc = "break;"]
    #[doc = "case 0: \t\t// No key"]
    #[doc = "case JUNK_KEY: \t// No key"]
    #[doc = "break;"]
    #[doc = "case ESC_KEY: if(eyelink_is_connected()==-1) goto exit;"]
    #[doc = "default:          // Echo to tracker for remote control"]
    #[doc = "if(allow_local_control)"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "result = eyelink_cal_result();"]
    #[doc = "if(result != NO_REPLY) break;"]
    #[doc = ""]
    #[doc = "i = eyelink_target_check(&tx, &ty);"]
    #[doc = "if( (target_visible && i==0) || tx!=otx || ty!=oty)"]
    #[doc = "{"]
    #[doc = "erase_cal_target();"]
    #[doc = "target_visible = 0;"]
    #[doc = "}"]
    #[doc = "if(!target_visible && i)"]
    #[doc = "{"]
    #[doc = "draw_cal_target(tx, ty);"]
    #[doc = ""]
    #[doc = "target_visible = 1;"]
    #[doc = "otx = tx;\t\t// record position for future tests"]
    #[doc = "oty = ty;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "exit:"]
    #[doc = ""]
    #[doc = "if(target_visible)"]
    #[doc = "erase_cal_target();   // erase target on exit"]
    #[doc = ""]
    #[doc = "clear_cal_display();"]
    #[doc = "return result;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_apply_driftcorr(), \\c eyelink_current_mode()"]
    #[doc = "and \\c eyelink_driftcorr_start()"]
    pub fn eyelink_target_check(x: *mut INT16, y: *mut INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Returns the current target position and state.  Same as eyelink_target_check() except this function returns data in floating point values."]
    #[doc = ""]
    #[doc = "@param x Pointer to variable to hold target X position."]
    #[doc = "@param y Pointer to variable to hold target Y position."]
    #[doc = "@return \\c 1 if target is visible, 0 if not."]
    pub fn eyelink_target_checkf(x: *mut f32, y: *mut f32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Triggers the EyeLink tracker to accept a fixation on a target, similar to the 'Enter'"]
    #[doc = "key or spacebar on the tracker."]
    #[doc = ""]
    #[doc = "@return \\c NO_REPLY if drift correction not completed yet.\\n"]
    #[doc = "<tt>OK_RESULT (0)</tt> if success.\\n"]
    #[doc = "<tt>ABORT_REPLY (27)</tt> if 'ESC' key aborted operation.\\n"]
    #[doc = "\\c -1 if operation failed.\\n"]
    #[doc = "\\c 1 if poor calibration or excessive validation error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_driftcorr_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_apply_driftcorr(), \\c eyelink_current_mode(), \\c eyelink_driftcorr_start()"]
    #[doc = "and \\c eyelink_target_check()"]
    pub fn eyelink_accept_trigger() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Sets the position of the drift correction target, and switches the tracker to"]
    #[doc = "drift-correction mode.  Should be followed by a call to \\c eyelink_wait_for_mode_ready()."]
    #[doc = ""]
    #[doc = "@param x X position of the target."]
    #[doc = "@param y Y position of the target."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "unsigned key;"]
    #[doc = "int result = 0;"]
    #[doc = "int x, y; // position of the drift correction target"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "eyecmd_printf(\"heuristic_filter = ON\");"]
    #[doc = "..."]
    #[doc = "while(getkey()) {};  // dump the keys"]
    #[doc = ""]
    #[doc = "eyelink_driftcorr_start(x, y); // start the drift correction"]
    #[doc = "do {"]
    #[doc = "result = eyelink_cal_result();"]
    #[doc = ""]
    #[doc = "key = getkey();"]
    #[doc = "switch(key)"]
    #[doc = "{"]
    #[doc = "case TERMINATE_KEY:  // breakout code"]
    #[doc = "return TERMINATE_KEY;"]
    #[doc = "case 0: \t\t// no key"]
    #[doc = "case JUNK_KEY: \t// no key"]
    #[doc = "break;"]
    #[doc = "case ESC_KEY:       // ESC key: we flag abort from our end"]
    #[doc = "result = 27;"]
    #[doc = "break;"]
    #[doc = "case 32: \t\t// Spacebar: we trigger ourselves"]
    #[doc = "eyelink_accept_trigger();"]
    #[doc = "break;"]
    #[doc = "default:"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "} while(result == NO_REPLY);"]
    #[doc = ""]
    #[doc = "if (result != 27 && result != -1)"]
    #[doc = "eyelink_apply_driftcorr();"]
    #[doc = "else"]
    #[doc = "; // Other code for handling"]
    #[doc = ""]
    #[doc = "return result;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger() and \\c eyelink_send_keybutton()"]
    pub fn eyelink_driftcorr_start(x: INT16, y: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Sets the position of the drift correction target, and switches the tracker to"]
    #[doc = "drift-correction mode.  Should be followed by a call to \\c eyelink_wait_for_mode_ready()."]
    #[doc = "Same as eyelink_driftcorr_start() except the x,y parameters take floating point values."]
    #[doc = ""]
    #[doc = "@param x X position of the target."]
    #[doc = "@param y Y position of the target."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "unsigned key;"]
    #[doc = "int result = 0;"]
    #[doc = "int x, y; // position of the drift correction target"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "eyecmd_printf(\"heuristic_filter = ON\");"]
    #[doc = "..."]
    #[doc = "while(getkey()) {};  // dump the keys"]
    #[doc = ""]
    #[doc = "eyelink_driftcorr_start(x, y); // start the drift correction"]
    #[doc = "do {"]
    #[doc = "result = eyelink_cal_result();"]
    #[doc = ""]
    #[doc = "key = getkey();"]
    #[doc = "switch(key)"]
    #[doc = "{"]
    #[doc = "case TERMINATE_KEY:  // breakout code"]
    #[doc = "return TERMINATE_KEY;"]
    #[doc = "case 0: \t\t// no key"]
    #[doc = "case JUNK_KEY: \t// no key"]
    #[doc = "break;"]
    #[doc = "case ESC_KEY:       // ESC key: we flag abort from our end"]
    #[doc = "result = 27;"]
    #[doc = "break;"]
    #[doc = "case 32: \t\t// Spacebar: we trigger ourselves"]
    #[doc = "eyelink_accept_trigger();"]
    #[doc = "break;"]
    #[doc = "default:"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "} while(result == NO_REPLY);"]
    #[doc = ""]
    #[doc = "if (result != 27 && result != -1)"]
    #[doc = "eyelink_apply_driftcorr();"]
    #[doc = "else"]
    #[doc = "; // Other code for handling"]
    #[doc = ""]
    #[doc = "return result;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger() and \\c eyelink_send_keybutton()"]
    pub fn eyelink_driftcorr_startf(x: f32, y: f32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Checks for a numeric result code returned by calibration, validation, or drift correction."]
    #[doc = ""]
    #[doc = "@return \\c NO_REPLY if drift correction not completed yet.\\n"]
    #[doc = "<tt>OK_RESULT (0)</tt> if success.\\n"]
    #[doc = "<tt>ABORT_REPLY (27)</tt> if 'ESC' key aborted operation.\\n"]
    #[doc = "\\c -1 if operation failed.\\n"]
    #[doc = "\\c 1 if poor calibration or excessive validation error.\\n"]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_driftcorr_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_apply_driftcorr(), \\c eyelink_cal_message() and"]
    #[doc = "\\c eyelink_driftcorr_start()"]
    pub fn eyelink_cal_result() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Applies the results of the last drift correction.  This is not done automatically after a"]
    #[doc = "drift correction, allowing the message returned by \\c eyelink_cal_message() to be examined first."]
    #[doc = ""]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_driftcorr_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_cal_result(), \\c eyelink_current_mode(), \\c eyelink_driftcorr_start()"]
    #[doc = "and \\c eyelink_target_check()"]
    pub fn eyelink_apply_driftcorr() -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Returns text associated with result of last calibration, validation, or drift correction."]
    #[doc = "This usually specifies errors or other statistics."]
    #[doc = ""]
    #[doc = "@param msg Buffer to return back the message."]
    #[doc = "@return \\c 0 if no message since last command sent, else length of string."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "char message[256];"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{   // Check link often so we can exit if tracker stopped"]
    #[doc = "if(!eyelink_is_connected()) return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "error = do_drift_correct(SCRWIDTH/2, SCRHEIGHT/2, 1, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27) break;"]
    #[doc = "}"]
    #[doc = "eyelink_cal_message(message);"]
    #[doc = "eyemsg_printf(message);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t1896559 DRIFTCORRECT R RIGHT at 320,40  OFFSET 0.11 deg.  -1.0,-4.0 pix."]
    #[doc = "MSG\t1896560 drift_correction: 0.11 -1.00 -4.00"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_accept_trigger(), \\c eyelink_apply_driftcorr() and \\c eyelink_cal_result()"]
    pub fn eyelink_cal_message(msg: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "This function tests the current tracker mode, and returns a set of flags based of"]
    #[doc = "what the mode is doing.  The most useful flag using the EXPTSPPT toolkit is \\c IN_USER_MENU"]
    #[doc = "to test if the EyeLink Abort menu has been activated."]
    #[doc = ""]
    #[doc = "@return Set of bitflags that mark mode function:"]
    #[doc = "\\c IN_DISCONNECT_MODE if disconnected."]
    #[doc = "\\c IN_IDLE_MODE if off-line (Idle mode)."]
    #[doc = "\\c IN_SETUP_MODE if in Setup-menu related mode."]
    #[doc = "\\c IN_RECORD_MODE if tracking is in progress."]
    #[doc = "\\c IN_PLAYBACK_MODE if currently playing back data."]
    #[doc = "\\c IN_TARGET_MODE if in mode that requires a fixation target."]
    #[doc = "\\c IN_DRIFTCORR_MODE if in drift-correction."]
    #[doc = "\\c IN_IMAGE_MODE if displaying grayscale camera image."]
    #[doc = "\\c IN_USER_MENU if displaying Abort or user-defined menu."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Example: See \\c echo_key()"]
    #[doc = ""]
    #[doc = "\\sa \\c echo_key(), \\c eyelink_tracker_mode() and \\c eyelink_user_menu_selection()"]
    pub fn eyelink_current_mode() -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "Returns raw EyeLink mode numbers, defined in eyelink.h as EL_xxxx definitions."]
    #[doc = ""]
    #[doc = "@return Raw EyeLink mode, \\c -1 if link disconnected"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "void track_mode_loop(void)"]
    #[doc = "{"]
    #[doc = "int oldmode = -1;"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "int mode = eyelink_tracker_mode();"]
    #[doc = "unsigned key = getkey();"]
    #[doc = ""]
    #[doc = "if(key==27 || break_pressed() || !eyelink_is_connected())"]
    #[doc = "return;"]
    #[doc = "else if(key) // Echo to tracker"]
    #[doc = "eyelink_send_keybutton(key,0,KB_PRESS);"]
    #[doc = ""]
    #[doc = "if(mode == oldmode)"]
    #[doc = "continue;"]
    #[doc = "switch(mode)"]
    #[doc = "{"]
    #[doc = "case EL_RECORD_MODE:     // Recording mode"]
    #[doc = "break;"]
    #[doc = "case EL_IMAGE_MODE:      // Image mode"]
    #[doc = "break;"]
    #[doc = "case EL_SETUP_MENU_MODE: // Setup menu mode"]
    #[doc = "break;"]
    #[doc = "case EL_CALIBRATE_MODE:  // Calibration, validation, DC mode"]
    #[doc = "case EL_VALIDATE_MODE:"]
    #[doc = "case EL_DRIFT_CORR_MODE:"]
    #[doc = "break;"]
    #[doc = "case EL_OPTIONS_MENU_MODE: // Option menu mode"]
    #[doc = "break;"]
    #[doc = "default:"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "oldmode = mode;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_current_mode() and \\c eyelink_is_connected()"]
    pub fn eyelink_tracker_mode() -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "After a mode-change command is given to the EyeLink tracker, an additional"]
    #[doc = "5 to 30 milliseconds may be needed to complete mode setup.  Call this function"]
    #[doc = "after mode change functions."]
    #[doc = ""]
    #[doc = "@remarks If it does not return \\c 0, assume a tracker error has occurred."]
    #[doc = "@param maxwait Maximum milliseconds to wait for the mode to change."]
    #[doc = "@return \\c 0 if mode switching is done, else still waiting."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_data_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_start() and \\c set_offline_mode()"]
    pub fn eyelink_wait_for_mode_ready(maxwait: UINT32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup eyelink_mode"]
    #[doc = "Checks for a user-menu selection, clears response for next call."]
    #[doc = ""]
    #[doc = "@return \\c 0 if no selection made since last call, else code of selection."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "i = eyelink_current_mode();"]
    #[doc = "if(i & IN_USER_MENU)     // handle user menu selections"]
    #[doc = "{"]
    #[doc = "switch(eyelink_user_menu_selection()"]
    #[doc = "{"]
    #[doc = "case 1:     // SETUP selected"]
    #[doc = "break;"]
    #[doc = "case 2:     // REPEAT trial"]
    #[doc = "return REPEAT_TRIAL;"]
    #[doc = "case 3:\t// SKIP trial"]
    #[doc = "return SKIP_TRIAL;"]
    #[doc = "case 4:\t// Abort experiment"]
    #[doc = "eyelink_abort();// this cleans up by erasing menu"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = "default:\t// no selection: continue"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_current_mode()"]
    pub fn eyelink_user_menu_selection() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Returns the divisor used to convert integer eye data to floating point data."]
    #[doc = ""]
    #[doc = "@return Divisor (usually 10)."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "UINT32 start_time;"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"screen_write_prescale = 10\");"]
    #[doc = ""]
    #[doc = "start_time = current_msec();"]
    #[doc = "while(current_msec() < start + 1000)"]
    #[doc = "if (eyelink_command_result() == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Position scalar %d\","]
    #[doc = "eyelink_position_prescaler());"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_position_prescaler() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Prepares link buffers to receive new data.  If \\c &lt;clear&gt; is nonzero, removes old data from buffer."]
    #[doc = ""]
    #[doc = "@param clear If clear is non-zero, any buffer data is discarded."]
    #[doc = "@return Always returns \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_in_data_block()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_status() and \\c eyelink_in_data_block()"]
    pub fn eyelink_reset_data(clear: INT16) -> INT16;
}
extern "C" {
    pub fn eyelink_data_status() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "Checks to see if framing events read from queue indicate that the data"]
    #[doc = "is in a block containing  samples, events, or both."]
    #[doc = ""]
    #[doc = "@remarks The first item in queue may not be a block start even, so this should"]
    #[doc = "be used in a loop while discarding items using \\c eyelink_get_next_data(NULL)."]
    #[doc = "NOTE: this function did not work reliably in versions of the SLL before"]
    #[doc = "v2.0 (did not detect end of blocks)."]
    #[doc = "@param samples If non-zero, check if in a block with samples."]
    #[doc = "@param events If non-zero, check if in a block with events."]
    #[doc = "@return \\c 0 if no data of either masked type is being sent."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_broadcast_open())"]
    #[doc = "{"]
    #[doc = "printf(\"Cannot open broadcast connection to tracker\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "eyelink_reset_data(1);"]
    #[doc = ""]
    #[doc = "eyelink_data_switch(RECORD_LINK_SAMPLES | RECORD_LINK_EVENTS);"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "if(escape_pressed() || break_pressed()) return;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);"]
    #[doc = "if(i == 0) continue;"]
    #[doc = ""]
    #[doc = "if(eyelink_in_data_block(1, 1))"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_status() and \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_in_data_block(samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "Reads and discards events in data queue until in a recording block.  Waits for up to"]
    #[doc = "\\c  &lt;timeout&gt; milliseconds for a block containing samples, events, or both to be"]
    #[doc = "opened.  Items in the queue are discarded until the block start events are found and"]
    #[doc = "processed.  This function will fail if both samples and events are selected but only"]
    #[doc = "one of link samples and events were enabled by \\c start_recording()."]
    #[doc = ""]
    #[doc = "@remarks This function did not work in versions previous to 2.0."]
    #[doc = "@param maxwait Time in milliseconds to wait."]
    #[doc = "@param samples If non-zero, check if in a block with samples."]
    #[doc = "@param events If non-zero, check if in a block with events."]
    #[doc = "@return \\c 0 if time expired without any data of masked types available."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "if(start_recording(1,1,1,1)!= 0)"]
    #[doc = "return -1;          // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "begin_realtime_mode(100);"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No link samples received!\");"]
    #[doc = "return TRIAL_ERROR;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = "switch(eye_used) // select eye, add annotation to EDF file"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:  // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_wait_for_block_start(maxwait: UINT32, samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Fetches next data item from link buffer.  Usually called with \\c &lt;buf&gt; = \\c NULL,"]
    #[doc = "and returns the data item type.  If the item is not wanted, simply ignore it."]
    #[doc = "Otherwise, call \\c eyelink_get_float_data() to read it into a buffer."]
    #[doc = ""]
    #[doc = "@param buf If \\c NULL, saves data, else copies integer data into buffer."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ALLF_DATA evt;        // buffer to hold sample and event data"]
    #[doc = "int eye_used = -1;    // indicates which eye's data to display"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = ""]
    #[doc = "switch(eye_used)"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:   // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "i = eyelink_get_next_data(NULL);"]
    #[doc = "if(i == FIXUPDATE)"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);"]
    #[doc = "if(evt.fe.eye == eye_used)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Fixupdate: avg_x %8.2f, y %8.2f, dur %d\","]
    #[doc = "evt.fe.gavx, evt.fe.gavy, evt.fe.entime-evt.fe.sttime);"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t30244970 Fixupdate: avg_x   863.10, y   244.10, dur 48"]
    #[doc = "MSG\t30245018 Fixupdate: avg_x   863.10, y   245.60, dur 48"]
    #[doc = "MSG\t30245070 Fixupdate: avg_x   863.10, y   247.30, dur 48"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_newest_float_sample()"]
    #[doc = "and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_next_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets an integer (unconverted) copy of the last/newest link data (sample or event)"]
    #[doc = "seen by \\c eyelink_get_next_data()."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer (\\c ISAMPLE, \\c IEVENT, or \\c ALL_DATA type)."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "ALLF_DATA evt;        // buffer to hold sample and event data"]
    #[doc = "int eye_used = -1;    // indicates which eye's data to display"]
    #[doc = "int i;"]
    #[doc = "UINT32 prev_event_time = -1;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);  // Checks for data from link"]
    #[doc = "if(i == ENDFIX)\t  // only process ENDFIX events"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);  // get a copy of the ENDFIX event"]
    #[doc = "if(evt.fe.eye == eye_used)\t// only process data from desired eye?"]
    #[doc = "eyemsg_printf(\"NEXT Event: %ld %ld\", evt.fe.sttime,"]
    #[doc = "evt.fe.entime);"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "i = eyelink_get_last_data(&evt);"]
    #[doc = "if (i == ENDFIX && evt.fe.eye == eye_used"]
    #[doc = "&& evt.fe.entime != prev_event_time)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"LAST Event: %ld %ld\", evt.fe.sttime, evt.fe.entime);"]
    #[doc = "prev_event_time = evt.fe.entime;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "SFIX L   7812616"]
    #[doc = "SFIX R   7812616"]
    #[doc = "EFIX L   7812616\t7813232\t620\t  124.7\t  274.0\t     50"]
    #[doc = "EFIX R   7812616\t7813232\t620\t  118.2\t  262.4\t     50"]
    #[doc = "SSACC L  7813236"]
    #[doc = "SSACC R  7813236"]
    #[doc = "MSG\t7813254 NEXT Event: 7812616 7813232"]
    #[doc = "MSG\t7813254 LAST Event: 7812616 7813232"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_next_data() and \\c eyelink_newest_float_sample()"]
    pub fn eyelink_get_last_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets an integer (unconverted) copy of the last/newest link data (sample or event)"]
    #[doc = "seen by \\c eyelink_get_next_data()."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer (\\c ISAMPLE, \\c ALL_DATA type)."]
    #[doc = "@return \\c 0 if no data, else \\c SAMPLE_TYPE."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "ISAMPLE isample;"]
    #[doc = "float x, y;\t\t // gaze position"]
    #[doc = ""]
    #[doc = "if(eyelink_newest_sample(NULL)>0)  // check for new sample update"]
    #[doc = "{"]
    #[doc = "eyelink_newest_sample(&isample);"]
    #[doc = ""]
    #[doc = "if (x!=MISSING_DATA)"]
    #[doc = "x = ((float) isample.gx[eye_used])/((float) eyelink_position_prescaler());    // yes: get gaze position from sample"]
    #[doc = "else"]
    #[doc = "x = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "if (y!=MISSING_DATA)"]
    #[doc = "y = ((float) isample.gy[eye_used])/((float) eyelink_position_prescaler());"]
    #[doc = "else"]
    #[doc = "y = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_get_sample() and \\c eyelink_newest_float_sample()"]
    pub fn eyelink_newest_sample(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Reads the last item fetched by \\c eyelink_get_next_data() into a buffer.  The event is"]
    #[doc = "converted to a floating-point format (\\c FSAMPLE or \\c FEVENT).  This can handle both samples"]
    #[doc = "and events.  The buffer type can be \\c ALLF_DATA for both samples and events, \\c FSAMPLE for"]
    #[doc = "a sample, or a specific event buffer."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer for floating-point data: type is \\c ALLF_DATA or \\c FSAMPLE."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_get_next_data()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_last_data(), \\c eyelink_get_next_data(), \\c eyelink_newest_float_sample()"]
    #[doc = "\\c eyelink_newest_double_sample() \\c eyelink_get_double_data() and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_float_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Reads the last item fetched by \\c eyelink_get_next_data() into a buffer.  The event is"]
    #[doc = "converted to a floating-point format with floating point time (\\c DSAMPLE or \\c DEVENT)."]
    #[doc = "This can handle both samples and events.  The buffer type can be \\c ALLD_DATA for both"]
    #[doc = "samples and events, \\c DSAMPLE for a sample, or a specific event buffer."]
    #[doc = ""]
    #[doc = "@param buf Pointer to buffer for floating-point data: type is \\c ALLD_DATA or \\c DSAMPLE."]
    #[doc = "@return \\c 0 if no data, \\c SAMPLE_TYPE if sample, else event type code."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_get_next_data()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_last_data(), \\c eyelink_get_next_data(), \\c eyelink_newest_float_sample()"]
    #[doc = "\\c eyelink_newest_double_sample() \\c eyelink_get_float_data() and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_double_data(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Check if a new sample has arrived from the link.  This is the latest sample, not the"]
    #[doc = "oldest sample that is read by \\c eyelink_get_next_data(), and is intended to drive gaze"]
    #[doc = "cursors and gaze-contingent displays."]
    #[doc = "Typically the function is called with a \\c NULL buffer pointer, to test if new data has"]
    #[doc = "arrived.  If a value of \\c 1 is returned, the function is called with a \\c FSAMPLE buffer to"]
    #[doc = "get the new sample."]
    #[doc = ""]
    #[doc = "@param buf Pointer to sample buffer type \\c FSAMPLE.  If \\c NULL, just checks new-sample status."]
    #[doc = "@return \\c -1 if no samples, \\c 0 if no new data, \\c 1 if new sample."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "Example 1:"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ALLF_DATA evt;         // buffer to hold sample and event data"]
    #[doc = "int eye_used = 0;      // indicates which eye's data to display"]
    #[doc = "float x, y;\t\t// gaze position"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,0);"]
    #[doc = "if(error != 0) return error;   // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = ""]
    #[doc = "switch(eye_used)"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:   // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "while (1)"]
    #[doc = "{"]
    #[doc = "if(eyelink_newest_float_sample(NULL)>0)"]
    #[doc = "{"]
    #[doc = "eyelink_newest_float_sample(&evt);"]
    #[doc = ""]
    #[doc = "x = evt.fs.gx[eye_used];"]
    #[doc = "y = evt.fs.gy[eye_used];"]
    #[doc = ""]
    #[doc = "if(x!=MISSING_DATA && y!=MISSING_DATA && evt.fs.pa[eye_used]>0)"]
    #[doc = "eyemsg_printf(\"Sample: %ld %8.2f %8.2f\","]
    #[doc = "evt.fs.time, x, y);"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "<pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t23701980 EYE_USED 0 LEFT"]
    #[doc = "MSG\t23703426 Sample: 23703424   412.90   217.90"]
    #[doc = "MSG\t23703430 Sample: 23703426   433.20   216.20"]
    #[doc = "MSG\t23703430 Sample: 23703428   453.40   214.40"]
    #[doc = "MSG\t23703434 Sample: 23703430   473.60   212.60"]
    #[doc = "MSG\t23703434 Sample: 23703432   493.80   210.80"]
    #[doc = "MSG\t23703438 Sample: 23703434   514.00   209.00"]
    #[doc = "MSG\t23703438 Sample: 23703436   534.20   207.10"]
    #[doc = "MSG\t23703442 Sample: 23703438   554.30   205.20"]
    #[doc = "MSG\t23703442 Sample: 23703440   574.40   203.30"]
    #[doc = "MSG\t23703446 Sample: 23703442   594.50   201.30"]
    #[doc = "MSG\t23703446 Sample: 23703444   614.60   199.30"]
    #[doc = "MSG\t23703450 Sample: 23703446   634.70   197.20"]
    #[doc = "MSG\t23703450 Sample: 23703448   634.70   197.20"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "Example 2:"]
    #[doc = "eyecmd_printf(\"file_sample_data = LEFT,RIGHT,GAZE,AREA,HTARGET,GAZERES,STATUS,INPUT\");"]
    #[doc = "eyecmd_printf(\"link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,HTARGET,STATUS,INPUT\");"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if(eyelink_newest_float_sample(NULL)>0)"]
    #[doc = "{"]
    #[doc = "eyelink_newest_float_sample(&evt);   // get the sample"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"remote data %d %d %d %x\", evt.fs.hdata[0], evt.fs.hdata[1], evt.fs.hdata[2], evt.fs.hdata[3]);"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_get_sample() \\c eyelink_newest_double_sample() and \\c eyelink_newest_sample()"]
    pub fn eyelink_newest_float_sample(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Check if a new sample has arrived from the link.  This is the latest sample, not the"]
    #[doc = "oldest sample that is read by \\c eyelink_get_next_data(), and is intended to drive gaze"]
    #[doc = "cursors and gaze-contingent displays."]
    #[doc = "Typically the function is called with a \\c NULL buffer pointer, to test if new data has"]
    #[doc = "arrived.  If a value of \\c 1 is returned, the function is called with a \\c DSAMPLE buffer to"]
    #[doc = "get the new sample."]
    #[doc = ""]
    #[doc = "@param buf Pointer to sample buffer type \\c DSAMPLE.  If \\c NULL, just checks new-sample status."]
    #[doc = "@return \\c -1 if no samples, \\c 0 if no new data, \\c 1 if new sample."]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_get_sample() \\c eyelink_newest_float_sample() and \\c eyelink_newest_sample()"]
    pub fn eyelink_newest_double_sample(buf: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "After calling \\c eyelink_wait_for_block_start(), or after at least one sample or"]
    #[doc = "eye event has been read, can be used to check which eyes data is available for."]
    #[doc = ""]
    #[doc = "@return One of these constants, defined in EYE_DATA.H:"]
    #[doc = "\\c LEFT_EYE if left eye data."]
    #[doc = "\\c RIGHT_EYE if right eye data."]
    #[doc = "\\c BINOCULAR if both left and right eye data."]
    #[doc = "\\c -1 if no eye data is available."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int eye_used = 0;      // indicates which eye's data to display"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = ""]
    #[doc = "switch(eye_used)"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR:   // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t22157314 EYE_USED 0 LEFT"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_eye_available() -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets sample data content flag (\\c 0 if not in sample block)."]
    pub fn eyelink_sample_data_flags() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Returns the event data content flags."]
    #[doc = ""]
    #[doc = "@remarks This will be \\c 0 if the data being read from queue is not in a block with events."]
    #[doc = "@return Event data content flags:"]
    #[doc = "\\c EVENT_VELOCITY if has velocity data."]
    #[doc = "\\c EVENT_PUPILSIZE if has pupil size data."]
    #[doc = "\\c EVENT_GAZERES if has gaze resolution."]
    #[doc = "\\c EVENT_STATUS if has status flags."]
    #[doc = "\\c EVENT_GAZEXY if has gaze xy position."]
    #[doc = "\\c EVENT_HREFXY if has head-ref xy position."]
    #[doc = "\\c EVENT_PUPILXY if has pupil xy position."]
    #[doc = "\\c FIX_AVG_ONLY if only avg. data to fixation events."]
    #[doc = "\\c START_TIME_ONLY if only start-time in start events."]
    #[doc = "\\c PARSEDBY_GAZE if how events were generated."]
    #[doc = "\\c PARSEDBY_HREF."]
    #[doc = "\\c PARSEDBY_PUPIL."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = "int error;"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,0);"]
    #[doc = "if(error != 0) return error;   // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_data(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No link samples received!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "emsg_printf(\"Event data%d Event type %d\","]
    #[doc = "eyelink_event_data_flags(), eyelink_event_type_flags());"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t2689937 Event data 26316 Event type 29760"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_event_type_flags()"]
    pub fn eyelink_event_data_flags() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "After at least one button or eye event has been read, can be used to check what type of"]
    #[doc = "events will be available."]
    #[doc = ""]
    #[doc = "@return A set of bit flags:"]
    #[doc = "\\c LEFTEYE_EVENTS if has left eye events."]
    #[doc = "\\c RIGHTEYE_EVENTS if has right eye events."]
    #[doc = "\\c BLINK_EVENTS if has blink events."]
    #[doc = "\\c FIXATION_EVENTS if has fixation events."]
    #[doc = "\\c FIXUPDATE_EVENTS if has fixation updates."]
    #[doc = "\\c SACCADE_EVENTS if has saccade events."]
    #[doc = "\\c MESSAGE_EVENTS if has message events."]
    #[doc = "\\c BUTTON_EVENTS if has button events."]
    #[doc = "\\c INPUT_EVENTS if has input port events."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_event_data_flags()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_event_data_flags()"]
    pub fn eyelink_event_type_flags() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Counts total items in queue: samples, events, or both."]
    #[doc = ""]
    #[doc = "@param samples If non-zero count the samples."]
    #[doc = "@param events If non-zero count the events."]
    #[doc = "@return Total number of samples and events is in the queue."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "int check_sample_event_status(int link_samples, int link_events)"]
    #[doc = "{"]
    #[doc = "UINT32 t = current_time();"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "while(current_time() < t + 300)"]
    #[doc = "{"]
    #[doc = "int arrived = 1;"]
    #[doc = "if((i=check_recording())!=0) return i;"]
    #[doc = ""]
    #[doc = "if(link_samples)"]
    #[doc = "if(eyelink_data_count(1,0)==0)"]
    #[doc = "arrived = 0;"]
    #[doc = ""]
    #[doc = "if(link_events)"]
    #[doc = "if(eyelink_data_count(0,1)==0)"]
    #[doc = "arrived = 0;"]
    #[doc = ""]
    #[doc = "if(arrived) return 0;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "<pre>"]
    pub fn eyelink_data_count(samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Waits for data to be received from the eye tracker.  Can wait for an event, a sample, or"]
    #[doc = "either.  Typically used after record start to check if data is being sent."]
    #[doc = ""]
    #[doc = "@param maxwait Time in milliseconds to wait for data."]
    #[doc = "@param samples If \\c 1, return when first sample available."]
    #[doc = "@param events If \\c 1, return when first event available."]
    #[doc = "@return \\c 1 if data is available. \\c 0 if timed out."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = "int error;"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,0);"]
    #[doc = "if(error != 0) return error;   // ERROR: couldn't start recording"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_data(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No link samples received!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_wait_for_data(maxwait: UINT32, samples: INT16, events: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Gets an integer (unconverted) sample from end of queue, discards any events encountered."]
    #[doc = ""]
    #[doc = "@param sample Pointer to buffer (\\c ISAMPLE or \\c ALL_DATA type)."]
    #[doc = "@return \\c 0 if no data. \\c 1 if data retrieved."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "ISAMPLE   isample; // INTEGER SAMPLE DATA"]
    #[doc = "int eye_used = 0;  // indicates which eye's data to display"]
    #[doc = "float x, y;\t\t   // gaze position"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(100, 1, 0))"]
    #[doc = "{"]
    #[doc = "end_trial();"]
    #[doc = "return TRIAL_ERROR;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eye_used = eyelink_eye_available();"]
    #[doc = "switch(eye_used) // select eye, add annotation to EDF file"]
    #[doc = "{"]
    #[doc = "case RIGHT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 1 RIGHT\");"]
    #[doc = "break;"]
    #[doc = "case BINOCULAR: // both eye's data present: use left eye only"]
    #[doc = "eye_used = LEFT_EYE;"]
    #[doc = "case LEFT_EYE:"]
    #[doc = "eyemsg_printf(\"EYE_USED 0 LEFT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "i = eyelink_get_sample(&isample);"]
    #[doc = "if(i)"]
    #[doc = "{"]
    #[doc = "if (x!=MISSING_DATA)"]
    #[doc = "x = ((float) isample.gx[eye_used])/"]
    #[doc = "((float) eyelink_position_prescaler());"]
    #[doc = "else"]
    #[doc = "x = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "if (y!=MISSING_DATA)"]
    #[doc = "y = ((float) isample.gy[eye_used])/"]
    #[doc = "((float) eyelink_position_prescaler());"]
    #[doc = "else"]
    #[doc = "y = (float) MISSING_DATA;"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"Sample: %ld %6.2f %6.2f\", isample.time, x, y);"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t14839670 Sample: 14839666 539.20 372.60"]
    #[doc = "MSG\t14839670 Sample: 14839668 539.20 372.60"]
    #[doc = "MSG\t14839674 Sample: 14839670 539.20 372.60"]
    #[doc = "MSG\t14839674 Sample: 14839672 539.20 372.60"]
    #[doc = "MSG\t14839678 Sample: 14839674 547.90 367.60"]
    #[doc = "MSG\t14839678 Sample: 14839676 556.60 362.50"]
    #[doc = "MSG\t14839682 Sample: 14839678 565.30 357.40"]
    #[doc = "MSG\t14839682 Sample: 14839680 574.10 352.30"]
    #[doc = "MSG\t14839686 Sample: 14839682 582.80 347.20"]
    #[doc = "MSG\t14839686 Sample: 14839684 591.50 342.00"]
    #[doc = "MSG\t14839690 Sample: 14839686 600.30 336.80"]
    #[doc = "MSG\t14839690 Sample: 14839688 609.00 331.60"]
    #[doc = "MSG\t14839694 Sample: 14839690 617.80 326.40"]
    #[doc = "MSG\t14839694 Sample: 14839692 626.60 321.20"]
    #[doc = "MSG\t14839698 Sample: 14839694 635.30 315.90"]
    #[doc = "MSG\t14839698 Sample: 14839696 644.10 310.70"]
    #[doc = "MSG\t14839702 Sample: 14839698 652.90 305.40"]
    #[doc = "MSG\t14839702 Sample: 14839700 661.70 300.00"]
    #[doc = "MSG\t14839706 Sample: 14839702 670.50 294.70"]
    #[doc = "MSG\t14839706 Sample: 14839704 679.30 289.40"]
    #[doc = "MSG\t14839710 Sample: 14839706 688.10 284.00"]
    #[doc = "MSG\t14839710 Sample: 14839708 696.90 278.60"]
    #[doc = "MSG\t14839714 Sample: 14839710 705.80 273.20"]
    #[doc = "MSG\t14839714 Sample: 14839712 714.60 267.70"]
    #[doc = "MSG\t14839718 Sample: 14839714 723.40 262.30"]
    #[doc = "MSG\t14839718 Sample: 14839716 732.30 256.80"]
    #[doc = "MSG\t14839722 Sample: 14839718 741.20 251.30"]
    #[doc = "MSG\t14839722 Sample: 14839720 750.00 245.80"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_get_float_data(), \\c eyelink_get_last_data(), \\c eyelink_get_next_data(),"]
    #[doc = "\\c eyelink_newest_float_sample() and \\c eyelink_newest_sample()"]
    pub fn eyelink_get_sample(sample: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = ""]
    #[doc = "Sets what data from tracker will be accepted and placed in queue."]
    #[doc = ""]
    #[doc = "@remarks This does not start the tracker recording, and so can be used with"]
    #[doc = "\\c eyelink_broadcast_open().  It also does not clear old data from the"]
    #[doc = "queue.  The data is set with a bitwise OR of these flags:"]
    #[doc = "\\c RECORD_LINK_SAMPLES\t- send samples on link."]
    #[doc = "\\c RECORD_LINK_EVENTS\t- send events on link."]
    #[doc = "@param flags Bitwise OR flags."]
    #[doc = "@return \\c 0 if OK else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_in_data_block()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_in_data_block()"]
    pub fn eyelink_data_switch(flags: UINT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Switches tracker to Record mode, enables data types for recording to EDF file or sending to"]
    #[doc = "link.  These types are set with a bitwise OR of these flags:"]
    #[doc = "\\arg <tt>RECORD_FILE_SAMPLES (1)</tt> - only active if file open."]
    #[doc = "\\arg <tt>RECORD_FILE_EVENTS (2)</tt> - only active if file open."]
    #[doc = "\\arg <tt>RECORD_LINK_SAMPLES (4)</tt> - accept samples from link."]
    #[doc = "\\arg <tt>RECORD_LINK_EVENTS (8)</tt> - accept events from link."]
    #[doc = ""]
    #[doc = "@remarks If \\c &lt;lock&gt; is nonzero, the recording may only be terminated through"]
    #[doc = "\\c stop_recording() or \\c eyelink_data_stop(), or by the Abort menu"]
    #[doc = "(\\91Ctrl\\92 \\92Alt\\92 \\92A\\92 keys on the eye tracker).  If zero, the tracker 'ESC'"]
    #[doc = "key may be used to halt recording."]
    #[doc = "@param flags Bitwise OR of flags to control what data is recorded.  If \\c 0, recording will be stopped."]
    #[doc = "@param lock If nonzero, prevents 'ESC' key from ending recording."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "INT16 file_samples,  file_events, link_samples, link_events;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected()) \treturn ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "i = eyelink_data_start((file_samples?RECORD_FILE_SAMPLES:0) |"]
    #[doc = "(file_events?RECORD_FILE_EVENTS:0)   |"]
    #[doc = "(link_samples?RECORD_LINK_SAMPLES:0) |"]
    #[doc = "(link_events?RECORD_LINK_EVENTS:0) , 1);"]
    #[doc = ""]
    #[doc = "if(i) return i;"]
    #[doc = ""]
    #[doc = "i = eyelink_wait_for_mode_ready(500);"]
    #[doc = "if(i==0) return TRIAL_ERROR;"]
    #[doc = ""]
    #[doc = "if((i = check_recording())!=0)"]
    #[doc = "return i;"]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "eyelink_data_stop();"]
    #[doc = "eyelink_wait_for_mode_ready(500);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_stop(), \\c start_recording() and \\c stop_recording()"]
    pub fn eyelink_data_start(flags: UINT16, lock: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "Places tracker in idle (off-line) mode, does not flush data from queue."]
    #[doc = ""]
    #[doc = "@remarks Should be followed by a call to \\c eyelink_wait_for_mode_ready()."]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_data_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_start() and \\c eyelink_wait_for_mode_ready()"]
    pub fn eyelink_data_stop() -> INT16;
}
extern "C" {
    #[doc = " @ingroup playback"]
    #[doc = "Flushes data from queue and starts data playback.  An EDF file must be open and have at"]
    #[doc = "least one recorded trial.  Use \\c eyelink_wait_for_data() to wait for data: this will time"]
    #[doc = "out if the playback failed.  Playback begins from start of file or from just after the"]
    #[doc = "end of the next-but-last recording block.  Link data is determined by file contents,"]
    #[doc = "not by link sample and event settings."]
    #[doc = ""]
    #[doc = "@return \\c 0 if command sent OK, else link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "set_offline_mode();           // set up eye tracker for playback"]
    #[doc = "eyelink_playback_start();     // start data playback"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(2000, 1, 1))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: playback data did not start!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "while(1)   // Loop while data available"]
    #[doc = "{"]
    #[doc = "if(escape_pressed() || break_pressed() ||"]
    #[doc = "eyelink_last_button_press(NULL))"]
    #[doc = "{"]
    #[doc = "eyelink_playback_stop(); // stop playback"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);   // check for new data item"]
    #[doc = "if(i==0)\t                       // 0: no new data"]
    #[doc = "{   // Checks if playback has completed"]
    #[doc = "if((eyelink_current_mode() & IN_PLAYBACK_MODE)==0) break;"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyelink_playback_stop();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_playback_stop() and \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_playback_start() -> INT16;
}
extern "C" {
    #[doc = " @ingroup playback"]
    #[doc = "Stops playback if in progress.  Flushes any data in queue."]
    #[doc = ""]
    #[doc = "@return \\c 0 if mode switched, else link error."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c eyelink_playback_start()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_playback_start() and \\c eyelink_wait_for_block_start()"]
    pub fn eyelink_playback_stop() -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Request an image of \\c &lt;type&gt; with size less than or eqaul to \\c &lt;xsize&gt;"]
    #[doc = "and \\c &lt;ysize&gt;."]
    #[doc = ""]
    #[doc = "@return \\c 0 if sent OK, else send error code."]
    pub fn eyelink_request_image(type_: INT16, xsize: INT16, ysize: INT16) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Test image-reception status."]
    #[doc = "@return \\c 0 if not receiving, \\c -1 if aborted, \\c 1 if receiving."]
    pub fn eyelink_image_status() -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Forces image transmissin to halt."]
    pub fn eyelink_abort_image();
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Get data at start of new image."]
    #[doc = "@return \\c -1 if aborted/not in receive, \\c 0 if old palette, \\c 1 if new palette."]
    #[doc = "ptrs to size: may be NULL"]
    pub fn eyelink_image_data(xsize: *mut INT16, ysize: *mut INT16, type_: *mut INT16) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Gets unpacked line data."]
    #[doc = "@return \\c -1 if error/not rx, else line number."]
    pub fn eyelink_get_line(buf: *mut ::std::os::raw::c_void) -> INT16;
}
#[doc = " @internal"]
#[doc = ""]
#[doc = "image data and palette structure uses brightness ramp plus special colors"]
#[doc = "to compress and make remapping easier \tfits in old palette's 48-byte area"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMAGE_PALDATA {
    pub palette_id: byte,
    pub ncolors: byte,
    pub camera: byte,
    pub threshold: byte,
    pub flags: UINT16,
    pub image_number: UINT16,
    pub extra: [byte; 10usize],
    pub rfirst_color: byte,
    pub rfirst_brite: byte,
    pub rlast_color: byte,
    pub rlast_brite: byte,
    pub nspecial: INT16,
    pub spcolors: [IMAGE_PALDATA__bindgen_ty_1; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMAGE_PALDATA__bindgen_ty_1 {
    pub index: byte,
    pub r: byte,
    pub g: byte,
    pub b: byte,
}
#[test]
fn bindgen_test_layout_IMAGE_PALDATA__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_PALDATA__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IMAGE_PALDATA__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_PALDATA__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(IMAGE_PALDATA__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).r as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).g as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA__bindgen_ty_1>())).b as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
}
#[test]
fn bindgen_test_layout_IMAGE_PALDATA() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_PALDATA>(),
        48usize,
        concat!("Size of: ", stringify!(IMAGE_PALDATA))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_PALDATA>(),
        2usize,
        concat!("Alignment of ", stringify!(IMAGE_PALDATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).palette_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(palette_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).ncolors as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).camera as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(camera)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).threshold as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).image_number as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(image_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).extra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rfirst_color as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rfirst_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rfirst_brite as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rfirst_brite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rlast_color as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rlast_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).rlast_brite as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(rlast_brite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).nspecial as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(nspecial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_PALDATA>())).spcolors as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_PALDATA),
            "::",
            stringify!(spcolors)
        )
    );
}
extern "C" {
    #[doc = " @internal"]
    #[doc = ""]
    #[doc = "Get palette: always ramp definition."]
    #[doc = "@return \\c -1 if no image in progress, \\c 0 if old, \\c 1 if new palette."]
    #[doc = ""]
    #[doc = "non-palette data in *pal may change even if 0 returned."]
    pub fn eyelink_get_palette(pal: *mut ::std::os::raw::c_void) -> INT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Reads any queued key or button events from tracker."]
    #[doc = ""]
    #[doc = "@remarks Any of the parameters(mods/state/kcode/time) can be null to ignore."]
    #[doc = "@param mods Pointer to variable to hold button number or key modifier (Shift, Alt and Ctrl key states)."]
    #[doc = "@param state Pointer to variable to hold key or button change (\\c KB_PRESS, \\c KB_RELEASE, or \\c KB_REPEAT)."]
    #[doc = "@param kcode Pointer to variable to hold key scan code."]
    #[doc = "@param time Pointer to a variable to hold tracker time of the key or button change."]
    #[doc = "@return Key character is key press/release/repeat, <tt>KB_BUTTON (0xFF00)</tt> if button press or release. \\c 0 if none."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT16 \tkey;"]
    #[doc = "INT16 \tstate;"]
    #[doc = ""]
    #[doc = "key = eyelink_read_keybutton(NULL, &state, NULL, NULL);"]
    #[doc = ""]
    #[doc = "if (key && state == KB_PRESS && key != KB_BUTTON)"]
    #[doc = "{"]
    #[doc = "if(key < 256 && isprint(key))"]
    #[doc = "eyemsg_printf(\"KEY '%c'\", key);"]
    #[doc = "else"]
    #[doc = "eyemsg_printf(\"WAITKEY 0x%04X\", key);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_send_keybutton()"]
    pub fn eyelink_read_keybutton(
        mods: *mut INT16,
        state: *mut INT16,
        kcode: *mut UINT16,
        time: *mut UINT32,
    ) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Sends a key or button event to tracker.  Only key events are handled for remote control."]
    #[doc = ""]
    #[doc = "@param code Key character, or <tt>KB_BUTTON (0xFF00)</tt> if sending button event."]
    #[doc = "@param mods Button number, or key modifier (Shift, Alt and Ctrl key states)."]
    #[doc = "@param state Key or button change (\\c KB_PRESS or \\c KB_RELEASE)."]
    #[doc = "@return \\c 0 if OK, else send link error."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "UINT16 echo_key(void)"]
    #[doc = "{"]
    #[doc = "UINT16 k = getkey();"]
    #[doc = ""]
    #[doc = "if(k!=0 && k!=1)"]
    #[doc = "eyelink_send_keybutton(k, 0, KB_PRESS);"]
    #[doc = "return k;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_read_keybutton()"]
    pub fn eyelink_send_keybutton(code: UINT16, mods: UINT16, state: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Returns a flag word with bits set to indicate which tracker buttons are currently pressed."]
    #[doc = "This is button 1 for the LSB, up to button 16 for the MSB."]
    #[doc = ""]
    #[doc = "@remarks Buttons above 8 are not realized on the EyeLink tracker."]
    #[doc = "@return Flag bits for buttons currently pressed."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int   state =0;"]
    #[doc = "int \tprev_state = 0;"]
    #[doc = "UINT32 start_time = current_time();"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected()"]
    #[doc = "&& current_time() > start_time + 5000)"]
    #[doc = "{"]
    #[doc = "state = eyelink_button_states();"]
    #[doc = "if (state != prev_state)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Button 1:%s 2:%s 3:%s 4:%s 5:%s\","]
    #[doc = "state & 0x01 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x02) >> 1 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x04) >> 2 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x08) >> 3 ? \"Pressed\" : \"Released\","]
    #[doc = "(state & 0x10) >> 4 ? \"Pressed\" : \"Released\");"]
    #[doc = ""]
    #[doc = "prev_state = state;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "BUTTON\t4144034\t1\t1"]
    #[doc = "MSG\t4144035 Button 1:Pressed 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4144266\t1\t0"]
    #[doc = "MSG\t4144267 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4144650\t2\t1"]
    #[doc = "MSG\t4144651 Button 1:Released 2:Pressed 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4144898\t2\t0"]
    #[doc = "MSG\t4144899 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4145260\t3\t1"]
    #[doc = "MSG\t4145261 Button 1:Released 2:Released 3:Pressed 4:Released 5:Released"]
    #[doc = "BUTTON\t4145492\t3\t0"]
    #[doc = "MSG\t4145493 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4145834\t4\t1"]
    #[doc = "MSG\t4145835 Button 1:Released 2:Released 3:Released 4:Pressed 5:Released"]
    #[doc = "BUTTON\t4146106\t4\t0"]
    #[doc = "MSG\t4146107 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "BUTTON\t4146498\t5\t1"]
    #[doc = "MSG\t4146499 Button 1:Released 2:Released 3:Released 4:Released 5:Pressed"]
    #[doc = "BUTTON\t4146778\t5\t0"]
    #[doc = "MSG\t4146779 Button 1:Released 2:Released 3:Released 4:Released 5:Released"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_last_button_press()"]
    pub fn eyelink_button_states() -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Returns a flag word with bits set to indicate which tracker buttons are currently pressed."]
    #[doc = "This is button 1 for the LSB, up to button 16 for the MSB.  Same as eyelink_button_states()"]
    #[doc = "except, optionally time of the button states can be acquired."]
    #[doc = ""]
    #[doc = "@param[out] time pointer to return time of the button states."]
    #[doc = "@return Flag bits for buttons currently pressed."]
    #[doc = "\\sa \\c eyelink_send_keybutton()"]
    pub fn eyelink_last_button_states(time: *mut UINT32) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Reads the number of the last button detected by the EyeLink tracker.  This is \\c 0"]
    #[doc = "if no buttons were pressed since the last call, or since the buttons were flushed."]
    #[doc = "If a pointer to a variable is supplied the eye-tracker timestamp of the button may"]
    #[doc = "be read.  This could be used to see if a new button has been pressed since the last"]
    #[doc = "read.  If multiple buttons were pressed since the last call, only the last button"]
    #[doc = "is reported."]
    #[doc = ""]
    #[doc = "@param time Far pointer to a variable to hold tracker time of last button press."]
    #[doc = "Usually left as \\c NULL to ignore time."]
    #[doc = "@return Button last pressed, \\c 0 if no button pressed since last read, or call to \\c eyelink_flush_keybuttons()."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "int   button;"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "button = eyelink_last_button_press(NULL);"]
    #[doc = ""]
    #[doc = "if(button != 0 && button != 6 && button != 7)"]
    #[doc = "{"]
    #[doc = "if (button == 5)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"ENDBUTTON %d\", button);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "else"]
    #[doc = "eyemsg_printf(\"BUTTON PRESSED %d\", button);"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "BUTTON\t19753748\t2\t1"]
    #[doc = "MSG\t19753749 BUTTON PRESSED 2"]
    #[doc = "BUTTON\t19754018\t2\t0"]
    #[doc = "BUTTON\t19755595\t5\t1"]
    #[doc = "MSG\t19755595 ENDBUTTON 5"]
    #[doc = "BUTTON\t19755808\t5\t0"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_flush_keybuttons(), \\c eyelink_button_states(), \\c eyelink_read_keybutton()"]
    #[doc = "and \\c eyelink_send_keybutton()"]
    pub fn eyelink_last_button_press(time: *mut UINT32) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup elbutton"]
    #[doc = "Causes the EyeLink tracker and the EyeLink library to flush any stored button or key"]
    #[doc = "events.  This should be used before a trial to get rid of old button responses."]
    #[doc = "The \\c &lt;enable_buttons&gt; argument controls whether the EyeLink library will store"]
    #[doc = "button press and release events.  It always stores tracker key events.  Even if"]
    #[doc = "disabled, the last button pressed and button flag bits are updated."]
    #[doc = ""]
    #[doc = "@param enable_buttons Set to \\c 0 to monitor last button press only, \\c 1 to queue button events."]
    #[doc = "@return Always \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "UINT32 wait_time = 5000;"]
    #[doc = "int i;"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "wait_time += current_msec();"]
    #[doc = ""]
    #[doc = "while(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "if(getkey()==27 || !eyelink_is_connected())"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "i = eyelink_last_button_press(NULL);"]
    #[doc = "if(i)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"WAITBUTTON %d\", i);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if(current_time() > wait_time)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"WAITBUTTON TIMEOUT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "BUTTON\t19585661\t5\t1"]
    #[doc = "MSG\t19585662 WAITBUTTON 5"]
    #[doc = "BUTTON\t19586005\t5\t0"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_button_states(), \\c eyelink_last_button_press(), \\c eyelink_read_keybutton()"]
    #[doc = "and \\c eyelink_send_keybutton()"]
    pub fn eyelink_flush_keybuttons(enable_buttons: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Request send of file \"src\". If \"\", gets last data file."]
    #[doc = "@return \\c 0 if OK, else send error."]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_request_file_read(src: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Get next block of file.  If \\c &lt;offset&gt; is not \\c NULL, will be filled"]
    #[doc = "with block-start offset in file."]
    #[doc = ""]
    #[doc = "@return negative if error, \\c NO_REPLY if waiting for packet, else block size (0..512)."]
    #[doc = "size is < 512 (can be 0) if at EOF."]
    #[doc = ""]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_get_file_block(buf: *mut ::std::os::raw::c_void, offset: *mut INT32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Ask for next block of file, reads from \\c &lt;offset&gt;."]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_request_file_block(offset: UINT32) -> INT16;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Aborts send of file."]
    #[doc = "@return \\c 0 if OK, else send error."]
    #[doc = "@remark Internal function. use receive_data_file()"]
    pub fn eyelink_end_file_transfer() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "After connection, determines if the connected tracker is an EyeLink I or II."]
    #[doc = ""]
    #[doc = "@remarks For the EyeLink II tracker, it can optionally retrieve the tracker software version."]
    #[doc = "@param c \\c NULL, or pointer to a string (at least 40 characters) to hold the version string."]
    #[doc = "This will be \"EYELINK I\" or \"EYELINK II x.xx\", where \"x.xx\" is the software version."]
    #[doc = "@return \\c 0 if not connected, \\c 1 for EyeLink I, \\c 2 for EyeLink II \\c 3 for EyeLink 1000."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int i;"]
    #[doc = "char version_info[256];"]
    #[doc = ""]
    #[doc = "i = eyelink_get_tracker_version(version_info);"]
    #[doc = "eyemsg_printf(\"EyeLink %d version %s\", i, version_info);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t500850 EyeLink 2 version EYELINK II 1.10"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_get_tracker_version(c: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "\\deprecated Use \\c eyelink_mode_data() instead."]
    pub fn eyelink2_mode_data(
        sample_rate: *mut INT16,
        crmode: *mut INT16,
        file_filter: *mut INT16,
        link_filter: *mut INT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @ingroup recording"]
    #[doc = "After calling \\c eyelink_wait_for_block_start(), or after at least one sample or eye event has"]
    #[doc = "been read, returns EyeLink II extended mode data."]
    #[doc = ""]
    #[doc = "@param sample_rate \\c NULL, or pointer to variable to be filled with samples per second."]
    #[doc = "@param crmode \\c NULL, or pointer to variable to be filled with CR mode flag (\\c 0 if pupil-only mode,"]
    #[doc = "else pupil-CR mode)."]
    #[doc = "@param file_filter \\c NULL, or pointer to variable to be filled with filter level to be applied to"]
    #[doc = "file samples (\\c 0 = off, \\c 1 = std, \\c 2 = double filter)."]
    #[doc = "@param link_filter \\c NULL, or pointer to variable to be filled with filter level to be applied to"]
    #[doc = "link and analog output samples (\\c 0 = off, \\c 1 = std, \\c 2 = double filter)."]
    #[doc = "@return If no data available -1 else 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#inlcude <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "int is_eyelink2;"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(2000, 1, 1))"]
    #[doc = "{"]
    #[doc = "printf(\"ERROR: No sample or event been detected!\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "is_eyelink2 = (2 == eyelink_get_tracker_version(NULL));"]
    #[doc = ""]
    #[doc = "if(is_eyelink2 && !eyelink2_mode_data(&sample_rate, &crmode, NULL, NULL))"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Sample rate: %d\", sample_rate);"]
    #[doc = "eyemsg_printf(\"Tracking mode: %s\", crmode?\"CR\":\"Pupil only\");"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t1151024 Sample rate: 250"]
    #[doc = "MSG\t1151024 Tracking mode: CR"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_mode_data(
        sample_rate: *mut INT16,
        crmode: *mut INT16,
        file_filter: *mut INT16,
        link_filter: *mut INT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Send bitmap data packet to tracker."]
    #[doc = "@remark This function is strictly internal. If you need to send bitmap to the tracker,"]
    #[doc = "use el_bitmap_to_backdrop(), gdi_bitmap_to_backdrop() or sdl_bitmap_to_backdrop()."]
    #[doc = "@param data pointer of the data to be sent."]
    #[doc = "@param size size of the data to be sent."]
    #[doc = "@param seq \\c 1 for first packet, increases thereafter."]
    pub fn eyelink_bitmap_packet(
        data: *mut ::std::os::raw::c_void,
        size: UINT16,
        seq: UINT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "Get bitmap ack count."]
    #[doc = "Negative: special code or sequence number to restart at."]
    #[doc = "Reading resets count to 0."]
    #[doc = "@remark This function is strictly internal. If you need to send bitmap to the tracker,"]
    #[doc = "use el_bitmap_to_backdrop(), gdi_bitmap_to_backdrop() or sdl_bitmap_to_backdrop()."]
    pub fn eyelink_bitmap_ack_count() -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = ""]
    #[doc = "Address used for non-connected time requests and message sends. the \"proper\""]
    #[doc = "way to do this is with the \"node\" type of functions but we allow a \"back door\""]
    #[doc = "to simplify higher level support functions.  This is also the address used"]
    #[doc = "under Windows for looking for tracker (an IP broadcast is used on all"]
    #[doc = "other platforms). There is a bug in the Windows networking, causing broadcasts"]
    #[doc = "sent on all cards to have the IP source addres of only the first card. This"]
    #[doc = "means the tracker sends its connection reply to the wrong address. So the exact"]
    #[doc = "address or a subnet broadcast address (i.e. 100.1.1.255 for a subnet mask of"]
    #[doc = "255.255.255.0) needs to be set to that of the tracker."]
    pub fn eyelink_set_tracker_node(node: *mut byte);
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the current tracker time (in micro seconds) since the tracker application started."]
    #[doc = ""]
    #[doc = "@return Each of these functions returns the current tracker time (in microseconds)"]
    #[doc = "since tracker initialization."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "int i;"]
    #[doc = "ALLF_DATA evt;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);   // Checks for new data item"]
    #[doc = "switch(i)"]
    #[doc = "{"]
    #[doc = "case SAMPLE_TYPE:"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);"]
    #[doc = "if(eyelink_tracker_double_usec()/1000000 >(evt.time +2) )"]
    #[doc = "printf(\"Oops it took longer than 2 milliseconds for the data to get"]
    #[doc = "here.\\n\");"]
    #[doc = "}"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_tracker_msec(), \\c current_time(), \\c eyelink_msec_offset() and"]
    #[doc = "\\c eyelink_double_usec_offset()"]
    #[doc = ""]
    pub fn eyelink_tracker_double_usec() -> f64;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the current tracker time (in milliseconds) since the tracker application started."]
    #[doc = ""]
    #[doc = "@return Each of these functions returns the current tracker time (in microseconds)"]
    #[doc = "since tracker initialization."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "#include <stdio.h>"]
    #[doc = ""]
    #[doc = "int i;"]
    #[doc = "ALLF_DATA evt;"]
    #[doc = ""]
    #[doc = "i = eyelink_get_next_data(NULL);   // Checks for new data item"]
    #[doc = "switch(i)"]
    #[doc = "{"]
    #[doc = "case SAMPLE_TYPE:"]
    #[doc = "{"]
    #[doc = "eyelink_get_float_data(&evt);"]
    #[doc = "if(eyelink_tracker_msec()/1000 >(evt.time +2) )"]
    #[doc = "printf(\"Oops it took longer than 2 milliseconds for the data to get"]
    #[doc = "here.\\n\");"]
    #[doc = "}"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c current_time(), \\c eyelink_msec_offset(), \\c eyelink_double_usec_offset() and"]
    #[doc = "\\c eyelink_tracker_double_usec()"]
    pub fn eyelink_tracker_msec() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the time difference between the tracker time and display pc time."]
    #[doc = ""]
    #[doc = "@return Returns the time difference between the tracker time and display pc"]
    #[doc = "time in microseconds."]
    #[doc = ""]
    #[doc = "\\sa \\c current_time() and \\c eyelink_tracker_msec()"]
    pub fn eyelink_double_usec_offset() -> f64;
}
extern "C" {
    #[doc = " @ingroup access_time_tracker"]
    #[doc = "Returns the time difference between the tracker time and display pc time."]
    #[doc = ""]
    #[doc = "@return Returns the time difference between the tracker time and display pc time."]
    #[doc = ""]
    #[doc = "\\sa \\c current_time(), \\c eyelink_tracker_msec() and \\c eyelink_tracker_double_usec()"]
    pub fn eyelink_msec_offset() -> UINT32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DISPLAYINFO {
    #[doc = "< left of display"]
    pub left: INT32,
    #[doc = "< top of display"]
    pub top: INT32,
    #[doc = "< right of display"]
    pub right: INT32,
    #[doc = "< bottom of display"]
    pub bottom: INT32,
    #[doc = "< width of display"]
    pub width: INT32,
    #[doc = "< height of display"]
    pub height: INT32,
    #[doc = "< bits per pixel"]
    pub bits: INT32,
    #[doc = "< total entries in palette (\\c 0 if not indexed display mode)"]
    pub palsize: INT32,
    #[doc = "< number of static entries in palette"]
    #[doc = "( \\c 0 if not indexed display mode)"]
    pub palrsvd: INT32,
    #[doc = "< pages supported"]
    pub pages: INT32,
    #[doc = "< refresh rate in Hz"]
    pub refresh: f32,
    #[doc = "< \\c 0 if Windows 95, \\c 1 if Windows NT"]
    pub winnt: INT32,
}
#[test]
fn bindgen_test_layout_DISPLAYINFO() {
    assert_eq!(
        ::std::mem::size_of::<DISPLAYINFO>(),
        48usize,
        concat!("Size of: ", stringify!(DISPLAYINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPLAYINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(DISPLAYINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).bits as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).palsize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(palsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).palrsvd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(palrsvd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).pages as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).refresh as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPLAYINFO>())).winnt as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPLAYINFO),
            "::",
            stringify!(winnt)
        )
    );
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Initializes the EyeLink library, and opens a connection to the EyeLink tracker."]
    #[doc = ""]
    #[doc = "@remarks By setting \\c &lt;mode&gt; to be \\c 1, the connection can be simulated for debugging"]
    #[doc = "purposes.  Only timing operations and simple tests should be done in simulation"]
    #[doc = "mode, and the Windows TCP/IP system must be installed.  This function is"]
    #[doc = "intended for networks where a single tracker is connected to the network."]
    #[doc = "@param mode Mode of connection:"]
    #[doc = "\\arg \\c 0, opens a connection with the eye tracker;"]
    #[doc = "\\arg \\c 1, will create a dummy connection for simulation;"]
    #[doc = "\\arg \\c -1, initializes the DLL but does not open a connection."]
    #[doc = "@return \\c 0 if success, else error code"]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if (set_eyelink_address(\"100.1.1.7\"))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "close_eyelink_connection();      // disconnect from tracker"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c close_eyelink_connection(), \\c close_eyelink_system(), \\c eyelink_broadcast_open(),"]
    #[doc = "\\c eyelink_dummy_open(), \\c eyelink_open() and \\c eyelink_open_node()"]
    pub fn open_eyelink_connection(mode: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Closes any connection to the eye tracker, and closes the link."]
    #[doc = ""]
    #[doc = "@remarks NEW (v2.1):  Broadcast connections can be closed, but not to affect the eye tracker. If"]
    #[doc = "a non-broadcast (primary) connection is closed, all broadcast connections to the"]
    #[doc = "tracker are also closed."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c open_eyelink_connection()"]
    #[doc = ""]
    #[doc = "\\sa \\c open_eyelink_connection() and \\c eyelink_close()"]
    pub fn close_eyelink_connection();
}
extern "C" {
    #[doc = " @ingroup init_eyelink"]
    #[doc = "Sets the IP address used for connection to the EyeLink tracker.  This is set to \"100.1.1.1\" in the DLL,"]
    #[doc = "but may need to be changed for some network configurations.  This must be set before attempting to open"]
    #[doc = "a connection to the tracker."]
    #[doc = ""]
    #[doc = "@remarks A \"broadcast\" address (\"255.255.255.255\") may be used if the tracker address is not known -"]
    #[doc = "this will work only if a single Ethernet card is installed, or if DLL version 2.1 or higher,"]
    #[doc = "and the latest tracker software versions (EyeLink I v2.1 or higher, and EyeLink II v1.1 or"]
    #[doc = "higher) are installed."]
    #[doc = "@param addr Pointer to a string containing a \"dotted\" 4-digit IP address."]
    #[doc = "@return \\c 0 if success, \\c -1 if could not parse address string."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(-1))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "set_eyelink_address(\"100.1.1.1\");"]
    #[doc = ""]
    #[doc = "if (eyelink_open())"]
    #[doc = "return -1;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c eyelink_open(), \\c eyelink_open_node(), \\c text_to_elinkaddr()"]
    pub fn set_eyelink_address(addr: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "Changes the multitasking proirity of current application"]
    #[doc = "Using THREAD_PRIORITY_ABOVE_NORMAL may reduce latency"]
    #[doc = "Reset priority with THREAD_PRIORITY_NORMAL"]
    #[doc = "Too high priority will stop the link from functioning!"]
    #[doc = "@deprecated  This function is depricated. It is left for compatibility reasons."]
    #[doc = "The implementation does nothing."]
    pub fn set_application_priority(priority: INT32) -> INT32;
}
extern "C" {
    #[doc = " allows messages to operate in loops"]
    #[doc = " returns nonzero if app terminated"]
    #[doc = " eats key events, places on key queue for getkey()"]
    #[doc = " getkey() and echo_key() also call this function"]
    #[doc = ""]
    #[doc = " calling this in loops allows Windows to process messages"]
    #[doc = " returns nonzero if application terminated (ALT-F4 sent to window)"]
    #[doc = " set <dialog_hook> to handle of modeless dialog"]
    #[doc = " in order to properly handle its messages as well"]
    #[doc = "Almost all experiments must run in a deterministic fashion, executing sequentially and in"]
    #[doc = "loops instead of the traditional Windows event-processing model.  However, Windows messages"]
    #[doc = "must still be dispatched for keyboard input and other events.  Calling \\c getkey() will dispatch"]
    #[doc = "messages and return keys.  The \\c message_pump() function also dispatches messages, but does"]
    #[doc = "not read the keys.  It can also handle messages for a modeless dialog box."]
    #[doc = ""]
    #[doc = "@return \\c 0 normally, \\c 1 if ALT-F4 or CTRL-C pressed, or if \\c terminal_break() called.  Any loops"]
    #[doc = "should exit in this case."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "The following two programs works together to show the use of \\c message_pump() function. In this"]
    #[doc = "case, writes a message to EDF file when the left mouse button is pressed."]
    #[doc = ""]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "message_pump(NULL);"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "switch (message)"]
    #[doc = "{"]
    #[doc = "case WM_KEYDOWN:"]
    #[doc = "case WM_CHAR:"]
    #[doc = "process_key_messages(hwnd, message, wparam, lparam);"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "case WM_LBUTTONDOWN:"]
    #[doc = "eyemsg_printf(\"Left button is down\");"]
    #[doc = "break;"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t11661891 SYNCTIME 1"]
    #[doc = "MSG\t11662745 left button is down"]
    #[doc = "MSG\t11663048 left button is down"]
    #[doc = "BUTTON\t11665520\t4\t1"]
    #[doc = "MSG\t11665521 ENDBUTTON 4"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c pump_delay()"]
    pub fn message_pump() -> INT16;
}
extern "C" {
    #[doc = " @ingroup pump"]
    #[doc = "Similar to \\c message_pump(), but only processes keypresses."]
    #[doc = "This may help reduce latency."]
    pub fn key_message_pump() -> INT16;
}
extern "C" {
    #[doc = " Similar to msec_delay(), but allows Widows message process"]
    #[doc = " only allows message processing if delay > 20 msec"]
    #[doc = " does not process dialog box messages"]
    #[doc = "During calls to \\c msec_delay(), Windows is not able to handle messages.  One result of this is"]
    #[doc = "that windows may not appear.  This is the preferred delay function when accurate timing is"]
    #[doc = "not needed.  It calls \\c message_pump() until the last 20 milliseconds of the delay, allowing"]
    #[doc = "Windows to function properly.  In rare cases, the delay may be longer than expected.  It does"]
    #[doc = "not process modeless dialog box messages."]
    #[doc = ""]
    #[doc = "@param delay Number of milliseconds to delay."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "static void end_trial(void)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "end_realtime_mode();"]
    #[doc = "pump_delay(100);"]
    #[doc = ""]
    #[doc = "stop_recording();"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c msec_delay() and \\c message_pump()"]
    pub fn pump_delay(delay: UINT32);
}
extern "C" {
    #[doc = " Initializes and empties local key queue"]
    #[doc = "Initializes the key queue used by \\c getkey().  This should be called at the start of your"]
    #[doc = "program.  It may be called at any time to get rid any of old keys from the queue."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "if (set_eyelink_address(\"100.1.1.7\"))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0))"]
    #[doc = "return -1;"]
    #[doc = ""]
    #[doc = "flush_getkey_queue();   // initialize getkey() system"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "close_eyelink_connection();      // disconnect from tracker"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\sa \\c read_getkey_queue()"]
    pub fn flush_getkey_queue();
}
extern "C" {
    #[doc = " Similar to getkey(), but doesnt call message pump"]
    #[doc = " Use to build message pump for your own window"]
    #[doc = "Reads keys from the key queue.  It is similar to \\c getkey(), but does not process Windows"]
    #[doc = "messages.  This can be used to build key-message handlers in languages other than C."]
    #[doc = ""]
    #[doc = "@remarks These functions are intended to support languages other than C or C++."]
    #[doc = "@return \\c 0 if no key pressed.\\n"]
    #[doc = "<tt> JUNK_KEY (1)</tt> if untranslatable key.\\n"]
    #[doc = "<tt>TERMINATE_KEY (0x7FFF)</tt> if CTRL-C is pressed, \\c terminal_break() was called,  or"]
    #[doc = "the program has been terminated with ALT-F4.\\n"]
    #[doc = "else, code of key if any key pressed."]
    #[doc = ""]
    #[doc = "\\sa \\c flush_getkey_queue()"]
    pub fn read_getkey_queue() -> UINT16;
}
extern "C" {
    #[doc = " Calls getkey(), also sends keys to tracker for remote control               *"]
    #[doc = " User implementation allows filtering of keys before sending                 *"]
    #[doc = " returns same codes as getkey()                                              *"]
    #[doc = "Checks for Windows keystroke events and dispatches messages; similar to \\c getkey(), but"]
    #[doc = "also sends keystroke to tracker."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, this call will not work in realtime mode at all,"]
    #[doc = "and will take several seconds to respond if graphics are being drawn"]
    #[doc = "continuously.  This function works well in realtime mode under Windows 2000."]
    #[doc = "@return \\c 0 if no key pressed, else key code.\\n"]
    #[doc = "\\c TERMINATE_KEY if CTRL-C held down or program has been terminated."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybutton();"]
    #[doc = "while(getkey());"]
    #[doc = ""]
    #[doc = "while(eyelink_current_mode() & IN_SETUP_MODE)"]
    #[doc = "{"]
    #[doc = "int i = eyelink_current_mode();"]
    #[doc = ""]
    #[doc = "if(i & IN_TARGET_MODE)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "else if(i & IN_IMAGE_MODE)"]
    #[doc = "{"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "echo_key();"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_read_keybutton(), \\c eyelink_send_keybutton() and \\c getkey()"]
    pub fn echo_key() -> UINT16;
}
extern "C" {
    #[doc = " EYELINK tracker (MS-DOS) key scan equivalent"]
    #[doc = " Processes Windows messages, records key events"]
    #[doc = " Returns 0 if no key pressed"]
    #[doc = " returns 1-255 for non-extended keys"]
    #[doc = " returns 0x##00 for extended keys (##=hex code)"]
    #[doc = "A routine for checking for Windows keystroke events, and dispatching Windows messages."]
    #[doc = "If no key is pressed or waiting, it returns \\c 0.  For a standard ASCII key, a value from"]
    #[doc = "\\c 31 to \\c 127 is returned.  For extended keys, a special key value is returned.  If the"]
    #[doc = "program has been terminated by ALT-F4 or a call to \\c terminal_break(), or the \"Ctrl\" and"]
    #[doc = "\"C\" keys are held down, the value \\c TERMINATE_KEY is returned.  The value <tt>JUNK_KEY (1)</tt>"]
    #[doc = "is returned if a non-translatable key is pressed."]
    #[doc = "@remarks Warning: This function processes and dispatches any waiting messages.  This"]
    #[doc = "will allow Windows to perform disk access and negates the purpose of"]
    #[doc = "realtime mode.  Usually these delays will be only a few milliseconds, but"]
    #[doc = "delays over 20 milliseconds have been observed.  You may wish to call"]
    #[doc = "\\c escape_pressed() or \\c break_pressed() in recording loops instead of \\c getkey()"]
    #[doc = "if timing is critical, for example in a gaze-contingent display.  Under"]
    #[doc = "Windows XP and later, for single core system, these calls will not work in realtime mode at all (although"]
    #[doc = "these do work under Windows 2000).  Under Windows 95/98/Me, realtime"]
    #[doc = "performance is impossible even with this strategy.\\n"]
    #[doc = "Some useful keys are defined in core_expt.h, as:\\n"]
    #[doc = "\\arg \\c CURS_UP    \t\t\\c 0x4800"]
    #[doc = "\\arg \\c CURS_DOWN  \t\t\\c 0x5000"]
    #[doc = "\\arg \\c CURS_LEFT  \t\t\\c 0x4B00"]
    #[doc = "\\arg \\c CURS_RIGHT \t\t\\c 0x4D00"]
    #[doc = "\\arg \\c ESC_KEY   \t\t\\c 0x001B"]
    #[doc = "\\arg \\c ENTER_KEY \t\t\\c 0x000D"]
    #[doc = "\\arg \\c TERMINATE_KEY \t\\c 0x7FFF"]
    #[doc = "\\arg \\c JUNK_KEY \t\t\\c 0x0001"]
    #[doc = "@return \\c 0 if no key pressed, else key code.\\n"]
    #[doc = "\\c TERMINATE_KEY if CTRL-C held down or program has been terminated."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "UINT32  delay_time = 5000L;  // Set the maximum wait time"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "delay_time += current_msec();"]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(current_time() > delay_time)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"WAITKEY TIMEOUT\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "key = getkey();"]
    #[doc = "if(key) // If key press occurs"]
    #[doc = "{"]
    #[doc = "if(key < 256 && isprint(key))"]
    #[doc = "eyemsg_printf(\"WAITKEY '%c'\", key);"]
    #[doc = "else"]
    #[doc = "eyemsg_printf(\"WAITKEY 0x%04X\", key);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c break_pressed(), \\c echo_key(), \\c escape_pressed(), \\c eyelink_flush_keybuttons()"]
    #[doc = "and \\c eyelink_send_keybutton()"]
    pub fn getkey() -> UINT16;
}
extern "C" {
    #[doc = "@ingroup keyinput"]
    #[doc = "Same as getkey except it returns the modifier and the key pressed."]
    #[doc = "It returns a 32 bit unsigned integer. The first 16 bits are reserved for the modifier and the"]
    #[doc = "last 16 bits are reserved for the key values. If there are no modifiers present,"]
    #[doc = "the return value of this is the same as getkey()."]
    #[doc = "If non null pointer passed in for unicode, the translated key value will be set if a key is preent."]
    pub fn getkey_with_mod(unicode: *mut UINT16) -> UINT32;
}
extern "C" {
    #[doc = " link command formatting                                                     *"]
    #[doc = " use just like printf()                                                      *"]
    #[doc = " returns command result                                                      *"]
    #[doc = " allows 500 msec. for command to finish                                      *"]
    #[doc = "The EyeLink tracker accepts text commands through the link.  These commands may be used"]
    #[doc = "to configure the system, open data files, and so on."]
    #[doc = ""]
    #[doc = "@remarks The function waits up to 500 msec. for a success or failure code to be returned"]
    #[doc = "from the tracker, then returns the error code \\c NO_REPLY.  If you need more"]
    #[doc = "time, use \\c eyelink_timed_command() instead."]
    #[doc = "@param fmt Similar to printf(), format string plus arguments."]
    #[doc = "@return \\c 0 if successfully executed, else error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "UINT32 t = current_msec();"]
    #[doc = "int i, j;"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"draw_box %d %d %d %d  7\", 100, 100, 300, 400);"]
    #[doc = ""]
    #[doc = "while(current_msec()-t < 1000)"]
    #[doc = "{"]
    #[doc = "i = eyelink_command_result();"]
    #[doc = "j = eyelink_last_message(buf);"]
    #[doc = ""]
    #[doc = "if (i == OK_RESULT)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Command executed successfully: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "else if (i!=NO_REPLY)"]
    #[doc = "{"]
    #[doc = "eyemsg_printf(\"Error in executing command: %s\", j?buf:\"\");"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t5312110 Command executed successfully: OK"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyemsg_printf(), \\c eyelink_send_command() and \\c eyelink_timed_command()"]
    #[doc = ""]
    pub fn eyecmd_printf(fmt: *const ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " link message formatting                                                     *"]
    #[doc = " use just like printf()                                                      *"]
    #[doc = " returns any send error                                                      *"]
    #[doc = "This sends a text message to the EyeLink tracker, which timestamps it and writes it to"]
    #[doc = "the EDF data file.  Messages are useful for recording trial conditions, subject responses,"]
    #[doc = "or the time of important events.  This function is used with the same formatting methods"]
    #[doc = "as printf(), allowing numbers to be included.  Avoid end-of-line characters (\"\\n\") at"]
    #[doc = "end of messages."]
    #[doc = ""]
    #[doc = "@param fmt Similar to printf(), format string plus arguments."]
    #[doc = "@return \\c 0 if successfully sent to tracker, else error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = "char program_name[100] = \"Windows Sample Experiment 2.0\";"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"RECORDED BY %s\", program_name);"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "\\b Output:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "MSG\t2248248 RECORDED BY Windows Sample Experiment 2.0"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyecmd_printf()"]
    pub fn eyemsg_printf(fmt: *const ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " @ingroup messaging"]
    #[doc = "This allows us to send messages to the Eyelink tracker to be logged into"]
    #[doc = "the data file with a time offset.  Use it just like printf() to format the message text."]
    #[doc = ""]
    #[doc = "@param exectime time offset that reflects in the message's time stamp"]
    #[doc = "@param fmt printf format string"]
    #[doc = "@return \\c 0 if OK, else error code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "if(open_eyelink_connection(0) !=0)"]
    #[doc = "return 0;"]
    #[doc = "open_data_file(\"msgtest.edf\");"]
    #[doc = ""]
    #[doc = "eyemsg_printf(\"hello\");"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf_ex(-100,\"hello1\");"]
    #[doc = "msec_delay(100);"]
    #[doc = ""]
    #[doc = "eyemsg_printf_ex(100,\"hello2\");"]
    #[doc = "msec_delay(100);"]
    #[doc = "eyemsg_printf(\"hello3\");"]
    #[doc = "msec_delay(100);"]
    #[doc = "close_data_file();"]
    #[doc = "receive_data_file(\"\",\".\",1);"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = "As you can see in the edf file data generated by the above code, both"]
    #[doc = "Message1 and Message2 has the same time stamp and message3 and message4 has the"]
    #[doc = "same time stamp."]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "MSG     8004932 Message1"]
    #[doc = "MSG     8004932 Message2"]
    #[doc = "MSG     8005232 Message3"]
    #[doc = "MSG     8005232 Message4"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn eyemsg_printf_ex(exectime: UINT32, fmt: *const ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " Start recording with data types requested                                   *"]
    #[doc = " Check that all requested link data is arriving                              *"]
    #[doc = " return 0 if OK, else trial exit code                                        *"]
    #[doc = "Starts the EyeLink tracker recording, sets up link for data reception if enabled."]
    #[doc = ""]
    #[doc = "@remarks Recording may take 10 to 30 milliseconds to begin from this command.  The function"]
    #[doc = "also waits until at least one of all requested link data types have been received."]
    #[doc = "If the return value is not zero, return the result as the trial result code."]
    #[doc = "@param file_samples If \\c 1, writes samples to EDF file.  If \\c 0, disables sample recording."]
    #[doc = "@param file_events If \\c 1, writes events to EDF file.  If \\c 0, disables event recording."]
    #[doc = "@param link_samples If \\c 1, sends samples through link.  If \\c 0, disables link sample access."]
    #[doc = "@param link_events If \\c 1, sends events through link.  If \\c 0, disables link event access."]
    #[doc = "@return \\c 0 if successful, else trial return code."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,0,0);"]
    #[doc = "if(error != 0)  return error;"]
    #[doc = ""]
    #[doc = "begin_realtime_mode(100);"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if((error=check_recording())!=0) return error;"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "end_realtime_mode();"]
    #[doc = "pump_delay(100);"]
    #[doc = "stop_recording();"]
    #[doc = ""]
    #[doc = "while(getkey());          // dump any accumulated key presses"]
    #[doc = ""]
    #[doc = "return check_record_exit();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c check_record_exit(), \\c check_recording(), \\c eyelink_data_start() and \\c stop_recording()"]
    pub fn start_recording(
        file_samples: INT16,
        file_events: INT16,
        link_samples: INT16,
        link_events: INT16,
    ) -> INT16;
}
extern "C" {
    #[doc = " Check if we are recording: if not, report an error                          *"]
    #[doc = " Also calls record_abort_hide() if recording aborted                         *"]
    #[doc = " Returns 0 if recording in progress                                          *"]
    #[doc = " Returns ABORT_EXPT if link disconnected                                     *"]
    #[doc = " Handles recors abort menu if trial interrupted                              *"]
    #[doc = " Returns TRIAL_ERROR if other non-recording state                            *"]
    #[doc = " Typical use is                                                              *"]
    #[doc = "   if((error=check_recording())!=0) return error;                            *"]
    #[doc = "Check if we are recording: if not, report an error.  Call this function while recording."]
    #[doc = "It will return \\c 0 if recording is still in progress, or an error code if not.  It will"]
    #[doc = "also handle the EyeLink Abort menu by calling \\c record_abort_handler().  Any errors returned"]
    #[doc = "by this function should be returned by the trial function.  On error, this will disable"]
    #[doc = "realtime mode and restore the heuristic."]
    #[doc = ""]
    #[doc = "@return <tt>TRIAL_OK (0)</tt> if no error.\\n"]
    #[doc = "<tt>REPEAT_TRIAL, SKIP_TRIAL, ABORT_EXPT, TRIAL_ERROR</tt> if recording aborted."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c start_recording()"]
    #[doc = ""]
    #[doc = "\\sa \\c check_record_exit(), \\c eyelink_abort(), \\c start_recording() and \\c stop_recording()"]
    pub fn check_recording() -> INT16;
}
extern "C" {
    #[doc = " halt recording, return when tracker finished mode switch"]
    #[doc = "Stops recording, resets EyeLink data mode."]
    #[doc = ""]
    #[doc = "@remarks Call 50 to 100 msec after an event occurs that ends the trial.  This function"]
    #[doc = "waits for mode switch before returning."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c start_recording()"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_data_stop(), \\c set_offline_mode() and \\c start_recording()"]
    pub fn stop_recording();
}
extern "C" {
    #[doc = " enter tracker idle mode, wait  till finished mode switch                    *"]
    #[doc = "Places EyeLink tracker in off-line (idle) mode."]
    #[doc = "Wait till the tracker has finished the mode transition."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "if(eyelink_is_connected())"]
    #[doc = "{"]
    #[doc = "set_offline_mode();"]
    #[doc = "eyecmd_printf(\"close_data_file\");    // close data file"]
    #[doc = "eyelink_close(1);         // disconnect from tracker"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "close_eyelink_system();"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c eyelink_abort()"]
    pub fn set_offline_mode();
}
extern "C" {
    #[doc = " call at end of trial, return result                                         *"]
    #[doc = " check if we are in Abort menu after recording stopped                       *"]
    #[doc = " returns trial exit code                                                     *"]
    #[doc = "Checks if we are in Abort menu after recording stopped and returns trial exit code. Call this"]
    #[doc = "function on leaving a trial.  It checks if the EyeLink tracker is displaying the Abort menu, and"]
    #[doc = "handles it if required.  The return value from this function should be returned as the trial"]
    #[doc = "result code."]
    #[doc = ""]
    #[doc = "@return \\c TRIAL_OK if no error.\\n"]
    #[doc = "<tt>REPEAT_TRIAL, SKIP_TRIAL, ABORT_EXPT</tt> if Abort menu activated."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c start_recording()"]
    #[doc = ""]
    #[doc = "\\sa \\c check_recording(), \\c eyelink_abort(), \\c start_recording() and \\c stop_recording()"]
    pub fn check_record_exit() -> INT16;
}
extern "C" {
    #[doc = "CALIBRATION, DRIFT CORRECTION CONTROL"]
    #[doc = " Call this to stop calibration/drift correction in progress"]
    #[doc = " This could be called from a Windows message handler"]
    #[doc = "This function should be called from an message or event handler if an ongoing call to"]
    #[doc = "\\c do_drift_correct() or \\c do_tracker_setup() should return immediately."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = "switch (message)"]
    #[doc = "{"]
    #[doc = "case WM_KEYDOWN:"]
    #[doc = "case WM_CHAR:"]
    #[doc = "{"]
    #[doc = "UINT16 key = process_key_messages(hwnd, message, wparam, lparam);"]
    #[doc = "eyemsg_printf(\"key %d\", key);"]
    #[doc = ""]
    #[doc = "if (key == 0x5100 && (eyelink_current_mode() & IN_SETUP_MODE))"]
    #[doc = "exit_calibration();"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup(), \\c do_drift_correct() and \\c eyelink_current_mode()"]
    pub fn exit_calibration();
}
extern "C" {
    #[doc = " Starts tracker into Setup Menu.                                             *"]
    #[doc = " From this the operator can do camera setup, calibrations, etc.              *"]
    #[doc = " Pressing ESC on the tracker exits.                                          *"]
    #[doc = " Leaving the setup menu on the tracker (ESC) key) also exits.                *"]
    #[doc = " RETURNS: 0 if OK, 27 if aborted, TERMINATE_KEY if pressed                   *"]
    #[doc = "Switches the EyeLink tracker to the Setup menu, from which camera setup, calibration,"]
    #[doc = "validation, drift correction, and configuration may be performed. Pressing the 'ESC' key on"]
    #[doc = "the tracker keyboard will exit the Setup menu and return from this function.  Calling"]
    #[doc = "\\c exit_calibration() from an event handler will cause any call to \\c do_tracker_setup() in"]
    #[doc = "progress to return immediately."]
    #[doc = ""]
    #[doc = "@return Always \\c 0."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "COLORREF target_foreground_color = RGB(0,0,0);"]
    #[doc = "COLORREF target_background_color = RGB(255,255,255);"]
    #[doc = "int i = SCRWIDTH/60;     // Selects best size for calibration target"]
    #[doc = "int j = SCRWIDTH/300;    // Selects size for focal spot in target"]
    #[doc = "if(j < 2) j = 2;"]
    #[doc = ""]
    #[doc = "set_target_size(i, j);"]
    #[doc = ""]
    #[doc = "set_calibration_colors(target_foreground_color, target_background_color);"]
    #[doc = ""]
    #[doc = "set_cal_sounds(\"\", \"\", \"\");"]
    #[doc = "set_dcorr_sounds(\"\", \"off\", \"off\");"]
    #[doc = ""]
    #[doc = "do_tracker_setup();"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_drift_correct(), \\c set_cal_sounds(), \\c set_calibration_colors() and \\c set_target_size()"]
    pub fn do_tracker_setup() -> INT16;
}
extern "C" {
    #[doc = "PERFORM DRIFT CORRECTION ON TRACKER"]
    #[doc = " Performs a drift correction, with target at (x,y).                          *"]
    #[doc = " If operator aborts with ESC, we assume there's a setup                      *"]
    #[doc = " problem and go to the setup menu (which may clear the                       *"]
    #[doc = " display).  Redraw display if needed and repeat the                          *"]
    #[doc = " call to  do_drift_correct() in this case.                                   *"]
    #[doc = " ARGS: x, y: position of target                                              *"]
    #[doc = "       draw: draws target if 1, 0 if you draw target first                   *"]
    #[doc = "       allow_setup: 0 disables ESC key setup mode entry                      *"]
    #[doc = " RETURNS: 0 if OK, 27 if Setup was called, TERMINATE_KEY if pressed          *"]
    #[doc = "Performs a drift correction before a trial."]
    #[doc = ""]
    #[doc = "@remarks When the 'ESC' key is pressed during drift correction, \\c &lt;allow_setup&gt; determines"]
    #[doc = "the result.  If \\c 1, the EyeLink Setup menu is accessed. This will always clear"]
    #[doc = "the display, so redrawing of hidden stimuli may be required.  Otherwise, the drift"]
    #[doc = "correction is aborted. Calling \\c exit_calibration() from an event handler will cause"]
    #[doc = "any call to \\c do_drift_correct() in progress to return immediately.  In all cases,"]
    #[doc = "the return code will be \\c 27 (\\c ESC_KEY)."]
    #[doc = "@param x X Position of drift correction target."]
    #[doc = "@param y Y Position of drift correction target."]
    #[doc = "@param draw If \\c 1, the drift correction will clear the screen to the target background color,"]
    #[doc = "draw the target, and clear the screen again when the drift correction is done."]
    #[doc = "If \\c 0, the fixation target must be drawn by the user."]
    #[doc = "@param allow_setup If \\c 1, accesses Setup menu before returning, else aborts drift correction."]
    #[doc = "@return \\c 0 if successful, \\c 27 if 'ESC' key was pressed to enter Setup menu or abort."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int target_shown = 0;"]
    #[doc = "int draw_own_target = 1;"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "if (draw_own_target && !target_shown)"]
    #[doc = "{"]
    #[doc = "target_shown = 1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "error = do_drift_correct(SCRWIDTH/2, SCRHEIGHT/2,"]
    #[doc = "draw_own_target, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27)"]
    #[doc = "break;"]
    #[doc = "else"]
    #[doc = "target_shown = 0;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup() and \\c set_dcorr_sounds()"]
    pub fn do_drift_correct(x: INT16, y: INT16, draw: INT16, allow_setup: INT16) -> INT16;
}
extern "C" {
    #[doc = " @ingroup setup_eyelink"]
    #[doc = "Performs a drift correction before a trial. Same as do_drift_correct() except, this takes the x,y values as float."]
    #[doc = ""]
    #[doc = "@remarks When the 'ESC' key is pressed during drift correction, \\c &lt;allow_setup&gt; determines"]
    #[doc = "the result.  If \\c 1, the EyeLink Setup menu is accessed. This will always clear"]
    #[doc = "the display, so redrawing of hidden stimuli may be required.  Otherwise, the drift"]
    #[doc = "correction is aborted. Calling \\c exit_calibration() from an event handler will cause"]
    #[doc = "any call to \\c do_drift_correct() in progress to return immediately.  In all cases,"]
    #[doc = "the return code will be \\c 27 (\\c ESC_KEY)."]
    #[doc = "@param x X Position of drift correction target."]
    #[doc = "@param y Y Position of drift correction target."]
    #[doc = "@param draw If \\c 1, the drift correction will clear the screen to the target background color,"]
    #[doc = "draw the target, and clear the screen again when the drift correction is done."]
    #[doc = "If \\c 0, the fixation target must be drawn by the user."]
    #[doc = "@param allow_setup If \\c 1, accesses Setup menu before returning, else aborts drift correction."]
    #[doc = "@return \\c 0 if successful, \\c 27 if 'ESC' key was pressed to enter Setup menu or abort."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int target_shown = 0;"]
    #[doc = "int draw_own_target = 1;"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if(!eyelink_is_connected())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "if (draw_own_target && !target_shown)"]
    #[doc = "{"]
    #[doc = "target_shown = 1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "error = do_drift_correctf(SCRWIDTH/2, SCRHEIGHT/2,"]
    #[doc = "draw_own_target, 1);"]
    #[doc = ""]
    #[doc = "if(error!=27)"]
    #[doc = "break;"]
    #[doc = "else"]
    #[doc = "target_shown = 0;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup() and \\c set_dcorr_sounds()"]
    pub fn do_drift_correctf(x: f32, y: f32, draw: INT16, allow_setup: INT16) -> INT16;
}
extern "C" {
    #[doc = " (USED BY do_tracker_setup(), YOU DO NOT NEED TO CALL normally               *"]
    #[doc = " Called for you by do_tracker_setup() and do_drift_correct()                 *                 *"]
    #[doc = "This function needs some \"helper\" graphics to clear the scren and draw the"]
    #[doc = "fixation targets.  Since C graphics are compiler-dependent, these are found"]
    #[doc = "in other C source files."]
    #[doc = ""]
    #[doc = "While tracker is in any mode with fixation targets."]
    #[doc = "Reproduce targets tracker needs."]
    #[doc = "(if local_trigger) Local Spacebar acts as trigger."]
    #[doc = "(if local_control)  Local keys echoes to tracker."]
    #[doc = "@return \\c 0 if OK, \\c 27 if aborted, \\c TERMINATE_KEY if pressed."]
    pub fn target_mode_display() -> INT16;
}
extern "C" {
    #[doc = " (USED BY do_tracker_setup(), YOU DO NOT NEED TO CALL   normally             *"]
    #[doc = "This handles display of the EyeLink camera images.  While in imaging mode,"]
    #[doc = "it contiuously requests and displays the current camera image.  It also"]
    #[doc = "displays the camera name and threshold setting.  Keys on the subject PC"]
    #[doc = "keyboard are sent to the tracker, so the experimenter can use it during"]
    #[doc = "setup.  It will exit when the tracker leaves imaging mode or disconnects."]
    #[doc = ""]
    #[doc = "@return \\c 0 if OK, \\c TERMINATE_KEY if pressed, \\c -1 if disconnect."]
    #[doc = "@remark This function not normally used externally.  If you need camera setup"]
    #[doc = "use do_tracker_setup() or if you need drift correction use do_drift_correct()"]
    pub fn image_mode_display() -> INT16;
}
extern "C" {
    #[doc = " displays general STOP-icon alert box"]
    #[doc = " text is formatted via printf-like arguments"]
    #[doc = "When an error occurs, a notification must be given to the user.  If no alert_printf_hook"]
    #[doc = "is set, this function uses the Windows MessageBox() function in windows. On other"]
    #[doc = "platforms printf is called."]
    #[doc = ""]
    #[doc = "@param fmt A printf() formatting string<...>:  any arguments required."]
    #[doc = ""]
    #[doc = "@remark The error message may no showup in certain display environment eg."]
    #[doc = "SDL with SDL_FULLSCREEN|SDL_HWSURFACE |  SDL_DOUBLEBUF"]
    pub fn alert_printf(fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " THIS ROUTINE MAY NEED TO BE CREATED FOR EACH PLATFORM                       *"]
    #[doc = " This call should be implemented for a standard programming interface        *"]
    #[doc = " Copies tracker file <src> to local file <dest>.                             *"]
    #[doc = " If specifying full file name, be sure to add \".edf\"                         *"]
    #[doc = " extensions for data files.                                                  *"]
    #[doc = " If <src> = \"\", tracker will send last opened data file.                     *"]
    #[doc = " If <dest> is NULL or \"\", creates local file with source file name.          *"]
    #[doc = " Else, creates file using <dest> as name.  If <dest_is_path> != 0            *"]
    #[doc = " uses source file name but adds <dest> as directory path.                    *"]
    #[doc = " returns: file size if OK, negative =  error code                            *"]
    #[doc = "This receives a data file from the EyeLink tracker PC."]
    #[doc = "\\param[in] src Name of eye tracker file (including extension).  If \"\" (empty string), asks"]
    #[doc = "tracker for name of last opened data file."]
    #[doc = "\\param[in] dest Name of local file to write to (including extension).  This must be a"]
    #[doc = "valid file name or directory name."]
    #[doc = "\\param[in] dest_is_path If nonzero, appends file name to &lt;dest&gt; as a directory path."]
    #[doc = "\\return \\c 0 if file transfer was cancelled.\\n"]
    #[doc = "Size of file if successful.\\n"]
    #[doc = "\\c -1 if file size is negative.\\n"]
    #[doc = "\\c -2 if cannot create local file.\\n"]
    #[doc = "\\c -3 if file transfer was cancelled.\\n"]
    #[doc = "\\c -4 if file transfer was aborted.\\n"]
    #[doc = "\\c -5 if error occurred while writing file.\\n"]
    #[doc = "\\c -6 if link was terminated.\\n"]
    #[doc = ""]
    #[doc = "\\b Example: See \\c open_data_file()"]
    #[doc = ""]
    #[doc = "\\sa \\c close_data_file() and \\c open_data_file()"]
    #[doc = ""]
    #[doc = "\\remark If linked against eyelink_exptkit20.lib or w32_dialogs.h is included,"]
    #[doc = "the behaviour of this function is receive_data_file_dialog()."]
    pub fn receive_data_file(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
    ) -> INT32;
}
extern "C" {
    #[doc = " exact same as receive_data_file. except the feedback parameters can be used"]
    #[doc = " for showing what is the full size of the edf file and howmuch is received so far."]
    #[doc = " this function is currently used internally only."]
    #[doc = "This receives a data file from the EyeLink tracker PC."]
    #[doc = "Exact same as \\c receive_data_file(). except the feedback parameters can be used"]
    #[doc = "for showing what is the full size of the edf file and how much is received so far."]
    #[doc = "This function is currently used internally only."]
    #[doc = ""]
    #[doc = "@param[in] src Name of eye tracker file (including extension).  If \"\" (empty string), asks"]
    #[doc = "tracker for name of last opened data file."]
    #[doc = "@param[in] dest Name of local file to write to (including extension).  This must be a"]
    #[doc = "valid file name or directory name."]
    #[doc = "@param[in] dest_is_path If nonzero, appends file name to &lt;dest&gt; as a directory path."]
    #[doc = "@param[in] progress A function pointer, that takes size and received size integers."]
    #[doc = "This allows, one to display progress bar on edf file transfer."]
    #[doc = "@return \\c 0 if file transfer was cancelled.\\n"]
    #[doc = "Size of file if successful.\\n"]
    #[doc = "\\c -1 if file size is negative.\\n"]
    #[doc = "\\c -2 if cannot create local file."]
    #[doc = "\\c -3 if file transfer was cancelled"]
    #[doc = "\\c -4 if file transfer was aborted"]
    #[doc = "\\c -5 if error occurred while writing file"]
    #[doc = "\\c -6 if link was terminated"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\sa \\c receive_data_file, \\c close_data_file() and \\c open_data_file()"]
    pub fn receive_data_file_feedback(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
        progress: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_uint, received: ::std::os::raw::c_uint),
        >,
    ) -> INT32;
}
extern "C" {
    pub fn receive_data_file_feedback_v2(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
        progress: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_uint, received: ::std::os::raw::c_uint),
        >,
    ) -> INT32;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "This function sends a file to the Eyelink tracker. Source destination file name"]
    #[doc = "should be given. Using this function, an image or video can be uploaded from the display"]
    #[doc = "PC to the host Tracker PC. The image can later be used as a Gaze Cursor Backdrop via a call"]
    #[doc = "to eyelink_send_command()."]
    #[doc = ""]
    #[doc = "@param src           Name of local file (including extension)."]
    #[doc = "@param dest          Name of eye tracker file to write to (including extension)."]
    #[doc = "@param dest_is_path  If nonzero, appends file name to &lt;dest&gt; as a directory path."]
    #[doc = "@param progress      A function pointer, that takes size and received size integers."]
    #[doc = "This allows, one to display progress bar on file transfer."]
    #[doc = ""]
    #[doc = "@return Returns \\c size of file if transferred file size is equal to the real file size. \\n"]
    #[doc = "\\c -1 if fail to connect tracker ftpd.\\n"]
    #[doc = "\\c -2 if fail to open file.\\n"]
    #[doc = "\\c -4 if fail to receive reply from tracker ftpd. \\n"]
    #[doc = "\\c -5 if transferred file size is unequal to the real file size."]
    pub fn send_data_file_feedback(
        src: *mut ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_is_path: INT16,
        progress: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_uint, received: ::std::os::raw::c_uint),
        >,
    ) -> INT32;
}
extern "C" {
    #[doc = " These functions were added as future revisions of EyeLink"]
    #[doc = " might require significant time to open and close EDF files"]
    #[doc = " Opens EDF file on tracker hard disk"]
    #[doc = "Opens an EDF file, closes any existing file."]
    #[doc = ""]
    #[doc = "@param name Name of data file,which can only use letters(uppercase and lowercase),"]
    #[doc = "numbers(0-9),and underscore(appears from 2nd place). Name extension"]
    #[doc = "can only be edf."]
    #[doc = "@return Returns \\c 0 if success, else error code."]
    pub fn open_data_file(name: *mut ::std::os::raw::c_char) -> INT16;
}
extern "C" {
    #[doc = " Closes EDF file on tracker hard disk"]
    #[doc = "Closes any open EDF file."]
    #[doc = ""]
    #[doc = "@return Returns \\c 0 if success, else error code."]
    pub fn close_data_file() -> INT16;
}
extern "C" {
    #[doc = " @ingroup keyinput"]
    #[doc = "This function tests if the 'ESC' key is held down, and is usually used to break out of"]
    #[doc = "nested loops.  This does not allow processing of Windows messages, unlike \\c getkey()."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, this call will not work in realtime mode at all,"]
    #[doc = "and will take several seconds to respond if graphics are being drawn"]
    #[doc = "continuously.  This function works well in realtime mode under Windows 2000."]
    #[doc = "@return \\c 1 if 'ESC' key held down; \\c 0 if not."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c break_pressed()"]
    #[doc = ""]
    #[doc = "\\sa \\c break_pressed(), \\c getkey() and \\c echo_key()"]
    pub fn escape_pressed() -> INT16;
}
extern "C" {
    #[doc = " @ingroup keyinput"]
    #[doc = "Tests if the program is being interrupted.  You should break out of loops immediately if"]
    #[doc = "this function does not return \\c 0, if \\c getkey() return \\c TERMINATE_KEY, or if"]
    #[doc = "\\c eyelink_is_connected() returns \\c 0."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, this call will not work in realtime mode at all, and"]
    #[doc = "will take several seconds to respond if graphics are being drawn continuously."]
    #[doc = "This function works well in realtime mode under Windows 2000."]
    #[doc = "@return \\c 1 if CTRL-C is pressed, \\c terminal_break() was called,  or the program has been"]
    #[doc = "terminated with ALT-F4; \\c 0 otherwise."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "eyelink_flush_keybuttons(0);"]
    #[doc = ""]
    #[doc = "while(1)"]
    #[doc = "{"]
    #[doc = "if((error=check_recording())!=0) return error;"]
    #[doc = ""]
    #[doc = "if(break_pressed())"]
    #[doc = "return ABORT_EXPT;"]
    #[doc = ""]
    #[doc = "if(escape_pressed())"]
    #[doc = "return SKIP_TRIAL;"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c echo_key(), \\c escape_pressed() and \\c getkey()"]
    pub fn break_pressed() -> INT16;
}
extern "C" {
    #[doc = " ASYNCHRONOUS BREAKOUTS *********/"]
    #[doc = " Because Windows is multi-tasking, some other event (i.e. a timer event or"]
    #[doc = " ALT-TAB) may affect your application during loops or calibration."]
    #[doc = " Your event handlers can call these functions to stop ongoing operations"]
    #[doc = ""]
    #[doc = " call from Windows event handlers when application must exit"]
    #[doc = " forces calibration or drift correction to exit with result=27"]
    #[doc = " when <assert> is nonzero,  will caused break_pressed() to test true"]
    #[doc = " continuously, also causes getkey() to return TERMINATE_KEY"]
    #[doc = " If <assert> is 0, will restore break_pressed() and getkey() to normal"]
    #[doc = "This function can be called in an event handler to signal that the program is terminating."]
    #[doc = "Calling this function with an argument of \\c 1 will cause \\c break_pressed() to return \\c 1, and"]
    #[doc = "\\c getkey() to return \\c TERMINATE_KEY.  These functions can be re-enabled by calling"]
    #[doc = "\\c terminal_break() with an argument of \\c 0."]
    #[doc = ""]
    #[doc = "@param assert \\c 1 to signal a program break, \\c 0 to reset break."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = ""]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "switch (message)"]
    #[doc = "{"]
    #[doc = "case WM_CLOSE:        // If ALT-F4 pressed, force program to close"]
    #[doc = "PostQuitMessage(0);"]
    #[doc = "terminal_break(1);// break out of loops"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "case WM_DESTROY:      // Window being closed by ALT-F4"]
    #[doc = "PostQuitMessage( 0 );"]
    #[doc = "..."]
    #[doc = "terminal_break(1);// break out of loops"]
    #[doc = "break;"]
    #[doc = ""]
    #[doc = "case WM_QUIT:         // Needs to break out of any loops"]
    #[doc = "terminal_break(1);"]
    #[doc = "break;"]
    #[doc = "..."]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c break_pressed() and \\c getkey()"]
    pub fn terminal_break(assert: INT16);
}
extern "C" {
    pub fn application_terminated() -> INT16;
}
extern "C" {
    #[doc = " Sets up for realtime execution (minimum delays)"]
    #[doc = " This may take some time (assume up to 100 msec)"]
    #[doc = " <delay> sets min time so delay may be useful"]
    #[doc = " Effects vary by operating system"]
    #[doc = " Keyboard, mouse, and sound may be disabled in some OS"]
    #[doc = " Has little effect in Win9x/ME"]
    #[doc = "Sets the application priority and cleans up pending Windows activity to place the"]
    #[doc = "application in realtime mode.  This could take up to 100 milliseconds, depending on"]
    #[doc = "the operation system, to set the application priority.  Use the \\c &lt;delay&gt; value to set"]
    #[doc = "the minimum time this function takes, so that this function can act as a useful delay."]
    #[doc = ""]
    #[doc = "@remarks Warning:  Under Windows XP, on single core machines, this call will lock out all"]
    #[doc = "keyboard input.  The Task Manager will take about 30 seconds to respond to"]
    #[doc = "CTRL-ALT-DEL, so press this once and be patient.  The keyboard functions well"]
    #[doc = "in realtime mode under Windows 2000.  This function has little or no effect under"]
    #[doc = "Windows 95/98/Me. Keyboard, mouse, and sound may be disabled in some OS."]
    #[doc = ""]
    #[doc = "@remarks Under Windowns Xp the application need to run under administrator credentials to"]
    #[doc = "get the realtime priorities."]
    #[doc = ""]
    #[doc = "@remarks  Under Windows Vista and later, the application need to be run as \"Run as Administrator\""]
    #[doc = "to get realtime priorities."]
    #[doc = ""]
    #[doc = "@remarks  Under Linux, the application need to be run as root to get realtime priorities."]
    #[doc = ""]
    #[doc = "@param delay Minimum delay in milliseconds (should be about 100)."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "#include <eyelink.h>"]
    #[doc = ""]
    #[doc = "int error;"]
    #[doc = ""]
    #[doc = "error = start_recording(1,1,1,1);"]
    #[doc = "if(error != 0)  return error;     // return error code if failed"]
    #[doc = ""]
    #[doc = "begin_realtime_mode(100);"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "end_realtime_mode();"]
    #[doc = ""]
    #[doc = "..."]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "\\sa \\c end_realtime_mode()"]
    pub fn begin_realtime_mode(delay: UINT32);
}
extern "C" {
    #[doc = " Exits realtime execution mode"]
    #[doc = " Typically just lowers priority"]
    #[doc = "Returns the application to a priority slightly above normal, to end realtime mode.  This"]
    #[doc = "function should execute rapidly, but there is the possibility that Windows will allow"]
    #[doc = "other tasks to run after this call, causing delays of 1-20 milliseconds."]
    #[doc = ""]
    #[doc = "@remarks Warning:  This function has little or no effect under Windows 95/98/Me."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c begin_realtime_mode()"]
    #[doc = ""]
    #[doc = "\\sa \\c begin_realtime_mode()"]
    pub fn end_realtime_mode();
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "Raise application priority."]
    #[doc = "May interfere with other applications."]
    pub fn set_high_priority();
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "Sets application priority to system normal"]
    pub fn set_normal_priority();
}
extern "C" {
    #[doc = " @ingroup priority"]
    #[doc = "returns whether the current mode is real-time."]
    #[doc = ""]
    #[doc = "@return \\c 1 if in realtime mode, else \\c 0."]
    pub fn in_realtime_mode() -> INT32;
}
extern "C" {
    pub fn eyelink_enable_extended_realtime();
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents an RGB color."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EYECOLOR {
    #[doc = "< Red"]
    pub r: byte,
    #[doc = "< Green"]
    pub g: byte,
    #[doc = "< Blue"]
    pub b: byte,
    pub unused: byte,
}
#[test]
fn bindgen_test_layout_EYECOLOR() {
    assert_eq!(
        ::std::mem::size_of::<EYECOLOR>(),
        4usize,
        concat!("Size of: ", stringify!(EYECOLOR))
    );
    assert_eq!(
        ::std::mem::align_of::<EYECOLOR>(),
        1usize,
        concat!("Alignment of ", stringify!(EYECOLOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYECOLOR>())).unused as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(EYECOLOR),
            "::",
            stringify!(unused)
        )
    );
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents a palette index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EYEPALETTE {
    #[doc = "< Number of colors in the palette"]
    pub ncolors: ::std::os::raw::c_int,
    #[doc = "< Actual colors"]
    pub colors: *mut EYECOLOR,
}
#[test]
fn bindgen_test_layout_EYEPALETTE() {
    assert_eq!(
        ::std::mem::size_of::<EYEPALETTE>(),
        16usize,
        concat!("Size of: ", stringify!(EYEPALETTE))
    );
    assert_eq!(
        ::std::mem::align_of::<EYEPALETTE>(),
        8usize,
        concat!("Alignment of ", stringify!(EYEPALETTE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPALETTE>())).ncolors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPALETTE),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPALETTE>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPALETTE),
            "::",
            stringify!(colors)
        )
    );
}
impl Default for EYEPALETTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents pixel format of an image or surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EYEPIXELFORMAT {
    pub colorkey: byte,
    pub Rmask: INT32,
    pub Gmask: INT32,
    pub Bmask: INT32,
    pub Amask: INT32,
    pub palette: *mut EYEPALETTE,
}
#[test]
fn bindgen_test_layout_EYEPIXELFORMAT() {
    assert_eq!(
        ::std::mem::size_of::<EYEPIXELFORMAT>(),
        32usize,
        concat!("Size of: ", stringify!(EYEPIXELFORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<EYEPIXELFORMAT>(),
        8usize,
        concat!("Alignment of ", stringify!(EYEPIXELFORMAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).colorkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(colorkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Rmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Gmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Bmask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).Amask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEPIXELFORMAT>())).palette as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEPIXELFORMAT),
            "::",
            stringify!(palette)
        )
    );
}
impl Default for EYEPIXELFORMAT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup display"]
#[doc = "\\brief Represents a bitmap image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EYEBITMAP {
    #[doc = "< width of the image"]
    pub w: INT32,
    #[doc = "< height of the image"]
    pub h: INT32,
    #[doc = "< pitch of image lines. This can be 0. if this is 0, then ((depth+7)/8)*width is used"]
    pub pitch: INT32,
    #[doc = "< Depth of the image. possible values are 8,15,16,24,32"]
    pub depth: INT32,
    #[doc = "< uncompressed pixel data"]
    pub pixels: *mut ::std::os::raw::c_void,
    #[doc = "< pixel format of the image."]
    pub format: *mut EYEPIXELFORMAT,
}
#[test]
fn bindgen_test_layout_EYEBITMAP() {
    assert_eq!(
        ::std::mem::size_of::<EYEBITMAP>(),
        32usize,
        concat!("Size of: ", stringify!(EYEBITMAP))
    );
    assert_eq!(
        ::std::mem::align_of::<EYEBITMAP>(),
        8usize,
        concat!("Alignment of ", stringify!(EYEBITMAP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).depth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).pixels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EYEBITMAP>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EYEBITMAP),
            "::",
            stringify!(format)
        )
    );
}
impl Default for EYEBITMAP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IMAGETYPE_JPEG: IMAGETYPE = 0;
pub const IMAGETYPE_PNG: IMAGETYPE = 1;
pub const IMAGETYPE_GIF: IMAGETYPE = 2;
pub const IMAGETYPE_BMP: IMAGETYPE = 3;
pub const IMAGETYPE_XPM: IMAGETYPE = 4;
#[doc = "@ingroup display"]
pub type IMAGETYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @ingroup error_reporting"]
    #[doc = "Returns error description for given function with error id."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "int rv = open_eyelink_connection(0);"]
    #[doc = "if(rv)"]
    #[doc = "{"]
    #[doc = "char *errmsg = eyelink_get_error(rv,\"open_eyelink_connection\");"]
    #[doc = "printf(\"Error: %s \\n\", errmsg); // report the error"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = "@param[in] id Error id"]
    #[doc = "@param[in] function_name Name of the function that generated the error id."]
    pub fn eyelink_get_error(
        id: ::std::os::raw::c_int,
        function_name: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@}"]
    #[doc = "Splice 'path' to 'fname', store in 'ffname'."]
    #[doc = "Tries to create valid concatenation."]
    #[doc = "If 'fname' starts with '\\', just adds drive from 'path'."]
    #[doc = "If 'fname' contains drive specifier, it is not changed."]
    pub fn splice_fname(
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        ffname: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Checks file name for legality."]
    #[doc = "Attempts to ensure cross-platform for viewer."]
    #[doc = "No spaces allowed as this interferes with messages."]
    #[doc = "Assume viewer will translate forward/backward slash."]
    #[doc = "Windows: don't allow <>:\"/\\|"]
    #[doc = "Also, device names, such as aux, con, lpt1, and prn are not allowed in windows."]
    #[doc = "forward slashes is missed."]
    pub fn check_filename_characters(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Checks if file and/or path exists."]
    #[doc = "@returns \\c 0 if does not exist, \\c 1 if exists, \\c -1 if cannot overwrite."]
    pub fn file_exists(path: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup datafile"]
    #[doc = "Checks if path exists."]
    #[doc = "Will create directory if 'create'."]
    #[doc = "Creates directory from last name in 'path', unless ends with '\\' or 'is_dir' nonzero."]
    #[doc = "Otherwise, last item is assumed to be filename and is dropped."]
    #[doc = ""]
    #[doc = "@return \\c 0 if exists, \\c 1 if created, \\c -1 if failed."]
    pub fn create_path(
        path: *mut ::std::os::raw::c_char,
        create: INT16,
        is_dir: INT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "This function saves the entire bitmap as a .BMP, .JPG, .PNG, or .TIF file, and"]
    #[doc = "transfers the image to tracker as backdrop for gaze cursors."]
    #[doc = ""]
    #[doc = "@param hbm Bitmap to save or transfer or both."]
    #[doc = "@param xs X position."]
    #[doc = "@param ys Y position."]
    #[doc = "@param width Width."]
    #[doc = "@param height Height."]
    #[doc = "@param fname File name to save as. The extension decides the format of the file."]
    #[doc = "@param path The directory to which the file will be written."]
    #[doc = "@param sv_options If the file exists, it replaces the file unless SV_NOREPLACE is specified."]
    #[doc = "@param xd X positon."]
    #[doc = "@param yd Y positon."]
    #[doc = "@param xferoptions Transfer options set with bitwise OR of the following"]
    #[doc = "constants, determines how bitmap is processed:"]
    #[doc = "\\arg \\c BX_AVERAGE Averaging combined pixels"]
    #[doc = "\\arg \\c BX_DARKEN  Choosing darkest and keep thin dark lines."]
    #[doc = "\\arg \\c BX_LIGHTEN Choosing darkest and keep thin white lines and control how"]
    #[doc = "bitmap size is reduced to fit tracker display."]
    #[doc = "\\arg \\c BX_MAXCONTRAST Maximizes contrast for clearest image."]
    #[doc = "\\arg \\c BX_NODITHER Disables the dithering of the image."]
    #[doc = "\\arg \\c BX_GREYSCALE Converts the image to grayscale (grayscale works"]
    #[doc = "best for EyeLink I, text, etc.)."]
    #[doc = ""]
    #[doc = "\\sa el_bitmap_to_backdrop(), el_bitmap_save(), sdl_bitmap_to_backdrop(),"]
    #[doc = "sdl_bitmap_save(),sdl_bitmap_save_and_backdrop, gdi_bitmap_to_backdrop(),"]
    #[doc = "gdi_bitmap_save(),gdi_bitmap_save_and_backdrop, bitmap_save(),"]
    #[doc = "and bitmap_to_backdrop() for more information."]
    #[doc = ""]
    #[doc = "@remark This function relies on the writeImageHook set by call to set_write_image_hook()"]
    #[doc = "to write the images in different formats. By default, if eyelink_core_graphics library is used,"]
    #[doc = "gd library is used to write the images and if eyelink_gdi_graphics is used FreeImage library is used"]
    #[doc = "to write the images. If neither one of them is used, call to this function does not write the images unless,"]
    #[doc = "set_write_image_hook() is used to set the writeImageHook."]
    #[doc = ""]
    #[doc = "@remark This function should not be called when timing is critical, as this might take very long to return."]
    #[doc = ""]
    pub fn el_bitmap_save_and_backdrop(
        hbm: *mut EYEBITMAP,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        sv_options: INT16,
        xd: INT16,
        yd: INT16,
        xferoptions: UINT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "This function transfers the bitmap to the tracker PC as backdrop for gaze"]
    #[doc = "cursors."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "@param hbm Bitmap to save or transfer or both."]
    #[doc = "@param xs X position."]
    #[doc = "@param ys Y position."]
    #[doc = "@param width Width."]
    #[doc = "@param height Height."]
    #[doc = "@param xd X positon."]
    #[doc = "@param yd Y positon."]
    #[doc = "@param xferoptions Transfer options set with bitwise OR of the following"]
    #[doc = "constants, determines how bitmap is processed:"]
    #[doc = "\\arg \\c BX_AVERAGE Averaging combined pixels"]
    #[doc = "\\arg \\c BX_DARKEN  Choosing darkest and keep thin dark lines."]
    #[doc = "\\arg \\c BX_LIGHTEN Choosing darkest and keep thin white lines and control how"]
    #[doc = "bitmap size is reduced to fit tracker display."]
    #[doc = "\\arg \\c BX_MAXCONTRAST Maximizes contrast for clearest image."]
    #[doc = "\\arg \\c BX_NODITHER Disables the dithering of the image."]
    #[doc = "\\arg \\c BX_GREYSCALE Converts the image to grayscale (grayscale works"]
    #[doc = "best for EyeLink I, text, etc.)."]
    #[doc = ""]
    #[doc = "\\sa sdl_bitmap_to_backdrop(), el_bitmap_save_and_backdrop(),"]
    #[doc = "sdl_bitmap_save_and_backdrop(), gdi_bitmap_to_backdrop(),"]
    #[doc = "gdi_bitmap_save_and_backdrop(),\tand bitmap_to_backdrop() for more information."]
    #[doc = ""]
    #[doc = "@remark This function should not be called when timing is critical, as this might take very long to return."]
    pub fn el_bitmap_to_backdrop(
        hbm: *mut EYEBITMAP,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        xd: INT16,
        yd: INT16,
        xferoptions: UINT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "This function saves the entire bitmap or selected part of a bitmap in an"]
    #[doc = "image file (with an extension of .png, .bmp, .jpg, or .tif). It creates"]
    #[doc = "the specified file if this file does not exist."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "@param hbm Bitmap to save or transfer or both."]
    #[doc = "@param xs X position."]
    #[doc = "@param ys Y position."]
    #[doc = "@param width Width."]
    #[doc = "@param height Height."]
    #[doc = "@param fname File name to save as. The extension decides the format of the file."]
    #[doc = "@param path The directory to which the file will be written."]
    #[doc = "@param sv_options If the file exists, it replaces the file unless SV_NOREPLACE is specified."]
    #[doc = ""]
    #[doc = "@remark This function relies on the writeImageHook set by call to set_write_image_hook()"]
    #[doc = "to write the images in different formats. By default, if eyelink_core_graphics library is used,"]
    #[doc = "gd library is used to write the images and if eyelink_gdi_graphics is used FreeImage library is used"]
    #[doc = "to write the images. If neither one of them is used, call to this function does not write the images unless,"]
    #[doc = "set_write_image_hook() is used to set the writeImageHook."]
    #[doc = ""]
    #[doc = "@remark This function should not be called when timing is critical, as this might take very long to return."]
    pub fn el_bitmap_save(
        hbm: *mut EYEBITMAP,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        sv_options: INT16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @ingroup display"]
#[doc = "\\brief Keyboard input event structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KeyInput {
    #[doc = "< The value of type should have value of KEYINPUT_EVENT"]
    pub type_: byte,
    #[doc = "< KEYDOWN = 1 or KEYUP    = 0"]
    pub state: byte,
    #[doc = "< keys"]
    pub key: UINT16,
    #[doc = "< modifier"]
    pub modifier: UINT16,
    #[doc = "< unicode character value of the key"]
    pub unicode: UINT16,
}
#[test]
fn bindgen_test_layout_KeyInput() {
    assert_eq!(
        ::std::mem::size_of::<KeyInput>(),
        8usize,
        concat!("Size of: ", stringify!(KeyInput))
    );
    assert_eq!(
        ::std::mem::align_of::<KeyInput>(),
        2usize,
        concat!("Alignment of ", stringify!(KeyInput))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).state as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).key as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).modifier as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyInput>())).unicode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyInput),
            "::",
            stringify!(unicode)
        )
    );
}
#[doc = " @ingroup display"]
#[doc = "\\brief Mouse motion event structure (For future)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MouseMotionEvent {
    #[doc = "< MOUSE_MOTION_INPUT_EVENT"]
    pub type_: byte,
    #[doc = "< The mouse device index"]
    pub which: byte,
    #[doc = "< The current button state"]
    pub state: byte,
    #[doc = "< The X/Y coordinates of the mouse"]
    pub x: UINT16,
    #[doc = "< The X/Y coordinates of the mouse"]
    pub y: UINT16,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: UINT16,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: UINT16,
}
#[test]
fn bindgen_test_layout_MouseMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<MouseMotionEvent>(),
        12usize,
        concat!("Size of: ", stringify!(MouseMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<MouseMotionEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(MouseMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).state as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).xrel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseMotionEvent>())).yrel as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = " @ingroup display"]
#[doc = "\\brief Mouse button event structure (For future)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MouseButtonEvent {
    #[doc = "< MOUSE_BUTTON_INPUT_EVENT"]
    pub type_: byte,
    #[doc = "< The mouse device index"]
    pub which: byte,
    #[doc = "< The mouse button index"]
    pub button: byte,
    #[doc = "< BUTTONDOWN = 0 or BUTTONUP    = 1"]
    pub state: byte,
    #[doc = "< The X/Y coordinates of the mouse at press time"]
    pub x: UINT16,
    #[doc = "< The X/Y coordinates of the mouse at press time"]
    pub y: UINT16,
}
#[test]
fn bindgen_test_layout_MouseButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<MouseButtonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(MouseButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<MouseButtonEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(MouseButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).which as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).button as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).state as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseButtonEvent>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "@ingroup display"]
#[doc = "\\brief Union of all input types."]
#[doc = ""]
#[doc = "A union that is used by the callback function get_input_key_hook,"]
#[doc = "to collect input data.  At the moment, it is meant to collect only"]
#[doc = "keyboard inputs. In the future this may be used to support mouse inputs as well."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union InputEvent {
    pub type_: byte,
    pub key: KeyInput,
    pub motion: MouseMotionEvent,
    pub button: MouseButtonEvent,
    _bindgen_union_align: [u16; 6usize],
}
#[test]
fn bindgen_test_layout_InputEvent() {
    assert_eq!(
        ::std::mem::size_of::<InputEvent>(),
        12usize,
        concat!("Size of: ", stringify!(InputEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<InputEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(InputEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InputEvent>())).button as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(button)
        )
    );
}
impl Default for InputEvent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@ingroup display"]
#[doc = "\\brief Structure used set and get callback functions"]
#[doc = ""]
#[doc = "Structure used set and get callback functions so that the calibration"]
#[doc = "graphics can be drawn."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HOOKFCNS {
    #[doc = "This function is called to setup calibration/validation display."]
    #[doc = "This function called before any calibration routines are called."]
    pub setup_cal_display_hook: ::std::option::Option<unsafe extern "C" fn() -> INT16>,
    #[doc = "This is called to release any resources that are not required beyond calibration."]
    #[doc = "Beyond this call, no calibration functions will be called."]
    pub exit_cal_display_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is called if abort of record. It is used to hide display from subject."]
    pub record_abort_hide_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is responsible for initializing any resources that are"]
    #[doc = "required for camera setup."]
    #[doc = ""]
    #[doc = "@param width width of the source image to expect."]
    #[doc = "@param height height of the source image to expect."]
    #[doc = "@return -1 if failed,  0 otherwise."]
    pub setup_image_display_hook:
        ::std::option::Option<unsafe extern "C" fn(width: INT16, height: INT16) -> INT16>,
    #[doc = "This function is called to update any image title change."]
    #[doc = "@param threshold if -1 the entire tile is in the title string"]
    #[doc = "otherwise, the threshold of the current image."]
    #[doc = "@param title     if threshold is -1, the title contains the whole title"]
    #[doc = "for the image. Otherwise only the camera name is given."]
    pub image_title_hook: ::std::option::Option<
        unsafe extern "C" fn(threshold: INT16, cam_name: *mut ::std::os::raw::c_char),
    >,
    #[doc = "This function is called to supply the image line by line from top to bottom."]
    #[doc = ""]
    #[doc = "@param width  width of the picture. Essentially, number of bytes in \\c pixels."]
    #[doc = "@param line   current line of the image"]
    #[doc = "@param totlines total number of lines in the image. This will always equal the height of the image."]
    #[doc = "@param pixels pixel data."]
    #[doc = ""]
    #[doc = "Eg. Say we want to extract pixel at position (20,20) and print it out as rgb values."]
    #[doc = ""]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "if(line == 20) // y = 20"]
    #[doc = "{"]
    #[doc = "byte pix = pixels[19];"]
    #[doc = "printf(\"RGB %d %d %d\\n\",r[pix],g[pix],b[pix]);"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = "@remark certain display draw the image up side down. eg. GDI."]
    pub draw_image_line_hook: ::std::option::Option<
        unsafe extern "C" fn(width: INT16, line: INT16, totlines: INT16, pixels: *mut byte),
    >,
    #[doc = "This function is called after setup_image_display and before the first call to"]
    #[doc = "draw_image_line. This is responsible to setup the palettes to display the camera"]
    #[doc = "image."]
    #[doc = ""]
    #[doc = "@param ncolors number of colors in the palette."]
    #[doc = "@param r       red component of rgb."]
    #[doc = "@param g       blue component of rgb."]
    #[doc = "@param b       green component of rgb."]
    pub set_image_palette_hook: ::std::option::Option<
        unsafe extern "C" fn(ncolors: INT16, r: *mut byte, g: *mut byte, b: *mut byte),
    >,
    #[doc = "This is called to notify that all camera setup things are complete.  Any"]
    #[doc = "resources that are allocated in setup_image_display can be released in this"]
    #[doc = "function."]
    pub exit_image_display_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "Called to clear the calibration display."]
    pub clear_cal_display_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is responsible for erasing the target that was drawn"]
    #[doc = "by the last call to draw_cal_target."]
    pub erase_cal_target_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is responsible for the drawing of the target for calibration,validation"]
    #[doc = "and drift correct at the given coordinate."]
    #[doc = "@param x x coordinate of the target."]
    #[doc = "@param y y coordinate of the target."]
    #[doc = "@remark The x and y are relative to what is sent to the tracker for the command screen_pixel_coords."]
    pub draw_cal_target_hook: ::std::option::Option<unsafe extern "C" fn(x: INT16, y: INT16)>,
    #[doc = "This function is called to signal new target."]
    pub cal_target_beep_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This function is called to signal end of calibration."]
    #[doc = "@param error if non zero, then the calibration has error."]
    pub cal_done_beep_hook: ::std::option::Option<unsafe extern "C" fn(error: INT16)>,
    #[doc = "This function is called to singnal the end of drift correct."]
    #[doc = "@param error if non zero, then the drift correction failed."]
    pub dc_done_beep_hook: ::std::option::Option<unsafe extern "C" fn(error: INT16)>,
    #[doc = "This function is called to signal a new drift correct target."]
    pub dc_target_beep_hook: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "This is called to check for keyboard input."]
    #[doc = "In this function:"]
    #[doc = "\\arg check if there are any input events"]
    #[doc = "\\arg if there are input events, fill key_input and return 1."]
    #[doc = "otherwise return 0. If 1 is returned this will be called"]
    #[doc = "again to check for more events."]
    #[doc = ""]
    #[doc = "@param[out] key_input  fill in the InputEvent structure to return"]
    #[doc = "key,modifier values."]
    #[doc = "@return if there is a key, return 1 otherwise return 0."]
    #[doc = ""]
    #[doc = "@remark Special keys and modifiers should match the following code."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Special \\b keys:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "#define F1_KEY    0x3B00"]
    #[doc = "#define F2_KEY    0x3C00"]
    #[doc = "#define F3_KEY    0x3D00"]
    #[doc = "#define F4_KEY    0x3E00"]
    #[doc = "#define F5_KEY    0x3F00"]
    #[doc = "#define F6_KEY    0x4000"]
    #[doc = "#define F7_KEY    0x4100"]
    #[doc = "#define F8_KEY    0x4200"]
    #[doc = "#define F9_KEY    0x4300"]
    #[doc = "#define F10_KEY   0x4400"]
    #[doc = ""]
    #[doc = "#define PAGE_UP    0x4900"]
    #[doc = "#define PAGE_DOWN  0x5100"]
    #[doc = "#define CURS_UP    0x4800"]
    #[doc = "#define CURS_DOWN  0x5000"]
    #[doc = "#define CURS_LEFT  0x4B00"]
    #[doc = "#define CURS_RIGHT 0x4D00"]
    #[doc = ""]
    #[doc = "#define ESC_KEY   0x001B"]
    #[doc = "#define ENTER_KEY 0x000D"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "Modifier: If you are using SDL you do not need to modify the modifier value as they match the value."]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "#define ELKMOD_NONE   0x0000"]
    #[doc = "#define ELKMOD_LSHIFT 0x0001"]
    #[doc = "#define ELKMOD_RSHIFT 0x0002"]
    #[doc = "#define ELKMOD_LCTRL  0x0040"]
    #[doc = "#define ELKMOD_RCTRL  0x0080"]
    #[doc = "#define ELKMOD_LALT   0x0100"]
    #[doc = "#define ELKMOD_RALT   0x0200"]
    #[doc = "#define ELKMOD_LMETA  0x0400"]
    #[doc = "#define ELKMOD_RMETA  0x0800,"]
    #[doc = "#define ELKMOD_NUM    0x1000"]
    #[doc = "#define ELKMOD_CAPS   0x2000"]
    #[doc = "#define ELKMOD_MODE   0x4000"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub get_input_key_hook: ::std::option::Option<
        unsafe extern "C" fn(event: *mut InputEvent) -> ::std::os::raw::c_short,
    >,
    #[doc = "This function is called whenever alert_printf is called.  In windows, if no"]
    #[doc = "callback is set calls MessageBox function. In other platforms, if no call back is set"]
    #[doc = "prints out to console."]
    pub alert_printf_hook:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
}
#[test]
fn bindgen_test_layout_HOOKFCNS() {
    assert_eq!(
        ::std::mem::size_of::<HOOKFCNS>(),
        136usize,
        concat!("Size of: ", stringify!(HOOKFCNS))
    );
    assert_eq!(
        ::std::mem::align_of::<HOOKFCNS>(),
        8usize,
        concat!("Alignment of ", stringify!(HOOKFCNS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).setup_cal_display_hook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(setup_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).exit_cal_display_hook as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(exit_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).record_abort_hide_hook as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(record_abort_hide_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS>())).setup_image_display_hook as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(setup_image_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).image_title_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(image_title_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).draw_image_line_hook as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(draw_image_line_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).set_image_palette_hook as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(set_image_palette_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS>())).exit_image_display_hook as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(exit_image_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).clear_cal_display_hook as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(clear_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).erase_cal_target_hook as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(erase_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).draw_cal_target_hook as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(draw_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).cal_target_beep_hook as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(cal_target_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).cal_done_beep_hook as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(cal_done_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).dc_done_beep_hook as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(dc_done_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).dc_target_beep_hook as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(dc_target_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).get_input_key_hook as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(get_input_key_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS>())).alert_printf_hook as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS),
            "::",
            stringify!(alert_printf_hook)
        )
    );
}
#[doc = " Drift Correct Done error beep"]
pub const _EL_CAL_BEEP_EL_DC_DONE_ERR_BEEP: _EL_CAL_BEEP = -2;
#[doc = " Calibration Done error beep"]
pub const _EL_CAL_BEEP_EL_CAL_DONE_ERR_BEEP: _EL_CAL_BEEP = -1;
#[doc = " Calibration Done correct beep"]
pub const _EL_CAL_BEEP_EL_CAL_DONE_GOOD_BEEP: _EL_CAL_BEEP = 0;
#[doc = " Calibration target present beep"]
pub const _EL_CAL_BEEP_EL_CAL_TARG_BEEP: _EL_CAL_BEEP = 1;
#[doc = " Drift Correct Done correct beep"]
pub const _EL_CAL_BEEP_EL_DC_DONE_GOOD_BEEP: _EL_CAL_BEEP = 2;
#[doc = " Drift Correct target present beep"]
pub const _EL_CAL_BEEP_EL_DC_TARG_BEEP: _EL_CAL_BEEP = 3;
#[doc = "@ingroup display"]
#[doc = "\\brief Enum used for calibration beeps"]
pub type _EL_CAL_BEEP = ::std::os::raw::c_int;
#[doc = "@ingroup display"]
#[doc = "\\brief Enum used for calibration beeps"]
pub use self::_EL_CAL_BEEP as EL_CAL_BEEP;
#[doc = "@ingroup display"]
#[doc = "\\brief Structure used set and get callback functions"]
#[doc = ""]
#[doc = "Structure used set and get callback functions so that the calibration"]
#[doc = "graphics can be drawn."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HOOKFCNS2 {
    #[doc = "Major version. At the moment the version number must be set to 1"]
    pub major: ::std::os::raw::c_int,
    #[doc = "Minor version. At the moment the version number must be set to 0"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "The value set here will be passed to every single call back functions"]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = "This function is called to setup calibration/validation display."]
    #[doc = "This function called before any calibration routines are called."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub setup_cal_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This is called to release any resources that are not required beyond calibration."]
    #[doc = "Beyond this call, no calibration functions will be called."]
    #[doc = "@return 0 upon success."]
    pub exit_cal_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This function is responsible for initializing any resources that are"]
    #[doc = "required for camera setup."]
    #[doc = ""]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param width width of the source image to expect."]
    #[doc = "@param height height of the source image to expect."]
    #[doc = "@return -1 if failed,  0 otherwise."]
    pub setup_image_display_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            width: INT16,
            height: INT16,
        ) -> INT16,
    >,
    #[doc = "This function is called to update any image title change."]
    #[doc = "@param threshold if -1 the entire tile is in the title string"]
    #[doc = "otherwise, the threshold of the current image."]
    #[doc = "@param title     if threshold is -1, the title contains the whole title"]
    #[doc = "for the image. Otherwise only the camera name is given."]
    #[doc = "@return 0 upon success."]
    pub image_title_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            title: *mut ::std::os::raw::c_char,
        ) -> INT16,
    >,
    #[doc = "This function is called to supply the image."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param width  width of the picture."]
    #[doc = "@param height height of the picture."]
    #[doc = "@param pixels pixels pointer to the pixel data. The size of the pixel data can be calculate by width*height*4."]
    #[doc = "The image comes in RGBA(network order) format."]
    #[doc = "@return 0 upon success."]
    pub draw_image: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            width: INT16,
            height: INT16,
            pixels: *mut byte,
        ) -> INT16,
    >,
    #[doc = "This is called to notify that all camera setup things are complete.  Any"]
    #[doc = "resources that are allocated in setup_image_display can be released in this"]
    #[doc = "function."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub exit_image_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "Called to clear the calibration display."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub clear_cal_display_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This function is responsible for erasing the target that was drawn"]
    #[doc = "by the last call to draw_cal_target."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@return 0 upon success."]
    pub erase_cal_target_hook:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void) -> INT16>,
    #[doc = "This function is responsible for the drawing of the target for calibration,validation"]
    #[doc = "and drift correct at the given coordinate."]
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param x x coordinate of the target."]
    #[doc = "@param y y coordinate of the target."]
    #[doc = "@remark The x and y are relative to what is sent to the tracker for the command screen_pixel_coords."]
    #[doc = "@return 0 upon success."]
    pub draw_cal_target_hook: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, x: f32, y: f32) -> INT16,
    >,
    #[doc = "@param userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "This function is called to signal new target."]
    #[doc = "@return 0 upon success."]
    pub play_target_beep_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            beep_type: EL_CAL_BEEP,
        ) -> INT16,
    >,
    #[doc = "This is called to check for keyboard input."]
    #[doc = "In this function:"]
    #[doc = ""]
    #[doc = "\\arg check if there are any input events"]
    #[doc = "\\arg if there are input events, fill key_input and return 1."]
    #[doc = "otherwise return 0. If 1 is returned this will be called"]
    #[doc = "again to check for more events."]
    #[doc = ""]
    #[doc = "@param[in] userData User context data set on userData field of HOOKFCNS2 set"]
    #[doc = "at the time of call to setup_graphic_hook_functions."]
    #[doc = ""]
    #[doc = "@param[out] key_input  fill in the InputEvent structure to return"]
    #[doc = "key,modifier values."]
    #[doc = "@return if there is a key, return 1 otherwise return 0. return -1 if there is an error."]
    #[doc = ""]
    #[doc = "@remark Special keys and modifiers should match the following code."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Special \\b keys:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = ""]
    #[doc = "#define F1_KEY    0x3B00"]
    #[doc = "#define F2_KEY    0x3C00"]
    #[doc = "#define F3_KEY    0x3D00"]
    #[doc = "#define F4_KEY    0x3E00"]
    #[doc = "#define F5_KEY    0x3F00"]
    #[doc = "#define F6_KEY    0x4000"]
    #[doc = "#define F7_KEY    0x4100"]
    #[doc = "#define F8_KEY    0x4200"]
    #[doc = "#define F9_KEY    0x4300"]
    #[doc = "#define F10_KEY   0x4400"]
    #[doc = ""]
    #[doc = "#define PAGE_UP    0x4900"]
    #[doc = "#define PAGE_DOWN  0x5100"]
    #[doc = "#define CURS_UP    0x4800"]
    #[doc = "#define CURS_DOWN  0x5000"]
    #[doc = "#define CURS_LEFT  0x4B00"]
    #[doc = "#define CURS_RIGHT 0x4D00"]
    #[doc = ""]
    #[doc = "#define ESC_KEY   0x001B"]
    #[doc = "#define ENTER_KEY 0x000D"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "Modifier: If you are using SDL you do not need to modify the"]
    #[doc = "modifier value as they match the value."]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "#define ELKMOD_NONE   0x0000"]
    #[doc = "#define ELKMOD_LSHIFT 0x0001"]
    #[doc = "#define ELKMOD_RSHIFT 0x0002"]
    #[doc = "#define ELKMOD_LCTRL  0x0040"]
    #[doc = "#define ELKMOD_RCTRL  0x0080"]
    #[doc = "#define ELKMOD_LALT   0x0100"]
    #[doc = "#define ELKMOD_RALT   0x0200"]
    #[doc = "#define ELKMOD_LMETA  0x0400"]
    #[doc = "#define ELKMOD_RMETA  0x0800,"]
    #[doc = "#define ELKMOD_NUM    0x1000"]
    #[doc = "#define ELKMOD_CAPS   0x2000"]
    #[doc = "#define ELKMOD_MODE   0x4000"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub get_input_key_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            event: *mut InputEvent,
        ) -> INT16,
    >,
    #[doc = "This function is called whenever alert_printf is called.  In windows, if no"]
    #[doc = "callback is set calls MessageBox function. In other platforms, if no call back is set"]
    #[doc = "prints out to console."]
    pub alert_printf_hook: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            msg: *const ::std::os::raw::c_char,
        ) -> INT16,
    >,
    pub reserved1: ::std::os::raw::c_int,
    pub reserved2: ::std::os::raw::c_int,
    pub reserved3: ::std::os::raw::c_int,
    pub reserved4: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HOOKFCNS2() {
    assert_eq!(
        ::std::mem::size_of::<HOOKFCNS2>(),
        128usize,
        concat!("Size of: ", stringify!(HOOKFCNS2))
    );
    assert_eq!(
        ::std::mem::align_of::<HOOKFCNS2>(),
        8usize,
        concat!("Alignment of ", stringify!(HOOKFCNS2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).userData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(userData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).setup_cal_display_hook as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(setup_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).exit_cal_display_hook as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(exit_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).setup_image_display_hook as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(setup_image_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).image_title_hook as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(image_title_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).draw_image as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(draw_image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).exit_image_display_hook as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(exit_image_display_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HOOKFCNS2>())).clear_cal_display_hook as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(clear_cal_display_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).erase_cal_target_hook as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(erase_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).draw_cal_target_hook as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(draw_cal_target_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).play_target_beep_hook as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(play_target_beep_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).get_input_key_hook as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(get_input_key_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).alert_printf_hook as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(alert_printf_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved1 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved3 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HOOKFCNS2>())).reserved4 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(HOOKFCNS2),
            "::",
            stringify!(reserved4)
        )
    );
}
impl Default for HOOKFCNS2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Primary function to setup display graphics hook functions."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "INT16 ELCALLTYPE init_expt_graphics(HWND hwnd, DISPLAYINFO *info)"]
    #[doc = "{"]
    #[doc = "HOOKFCNS fcns;"]
    #[doc = "memset(&fcns,0,sizeof(fcns));"]
    #[doc = "fcns.setup_cal_display_hook = setup_cal_display;"]
    #[doc = "fcns.exit_cal_display_hook  = exit_cal_display;"]
    #[doc = "fcns.record_abort_hide_hook = record_abort_hide;"]
    #[doc = "fcns.setup_image_display_hook = setup_image_display;"]
    #[doc = "fcns.image_title_hook       = image_title;"]
    #[doc = "fcns.draw_image_line_hook   = draw_image_line;"]
    #[doc = "fcns.set_image_palette_hook = set_image_palette;"]
    #[doc = "fcns.exit_image_display_hook= exit_image_display;"]
    #[doc = "fcns.clear_cal_display_hook = clear_cal_display;"]
    #[doc = "fcns.erase_cal_target_hook  = erase_cal_target;"]
    #[doc = "fcns.draw_cal_target_hook   = draw_cal_target;"]
    #[doc = "fcns.cal_target_beep_hook   = cal_target_beep;"]
    #[doc = "fcns.cal_done_beep_hook     = cal_done_beep;"]
    #[doc = "fcns.dc_done_beep_hook      = dc_done_beep;"]
    #[doc = "fcns.dc_target_beep_hook    = dc_target_beep;"]
    #[doc = "fcns.get_input_key_hook     = get_input_key;"]
    #[doc = "fcns.alert_printf_hook      = alert_printf_hook;"]
    #[doc = ""]
    #[doc = "setup_graphic_hook_functions(&fcns);"]
    #[doc = ""]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn setup_graphic_hook_functions(hooks: *mut HOOKFCNS);
}
extern "C" {
    pub fn get_all_hook_functions() -> *mut HOOKFCNS;
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Primary function to setup display graphics hook functions of the second revision of the interface."]
    #[doc = "One of the major difference between this and setup_graphic_hook_functions is, this has fewer functions to implement"]
    #[doc = "also, takes extra parameters like the major and minor versions for future enhancements."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "INT16 ELCALLTYPE init_expt_graphics(HWND hwnd, DISPLAYINFO *info)"]
    #[doc = "{"]
    #[doc = "HOOKFCNS2 fcns;"]
    #[doc = "memset(&fcns,0,sizeof(fcns));"]
    #[doc = "fcns.major = 1;"]
    #[doc = "fcns.minor = 0;"]
    #[doc = "fcns.userData = ts;"]
    #[doc = ""]
    #[doc = "fcns.draw_image   = draw_image;"]
    #[doc = "fcns.exit_image_display_hook= exit_image_display;"]
    #[doc = "fcns.setup_image_display_hook = setup_image_display;"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "fcns.setup_cal_display_hook = setup_cal_display;"]
    #[doc = "fcns.clear_cal_display_hook = clear_display;"]
    #[doc = "fcns.erase_cal_target_hook  = clear_display;"]
    #[doc = "fcns.draw_cal_target_hook   = draw_cal_target;"]
    #[doc = "fcns.image_title_hook       = image_title;"]
    #[doc = ""]
    #[doc = "fcns.get_input_key_hook     = get_input_key;"]
    #[doc = "fcns.alert_printf_hook      = alert_printf_hook;"]
    #[doc = "return setup_graphic_hook_functions_V2(&fcns);"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn setup_graphic_hook_functions_V2(hooks: *mut HOOKFCNS2) -> INT16;
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Returns a pointer to  HOOKFCNS2, with values that are set by"]
    #[doc = "setup_graphic_hook_functions_V2()."]
    #[doc = ""]
    #[doc = "This function with combination of setup_graphic_hook_functions"]
    #[doc = "can be used to over-ride an existing hook function."]
    pub fn get_all_hook_functions_V2() -> *mut HOOKFCNS2;
}
extern "C" {
    #[doc = " @ingroup bitmap_save"]
    #[doc = "Use this function to set function pointer, so that the call to"]
    #[doc = "el_bitmap_save and el_bitmap_save_and_backdrop will use the passed in"]
    #[doc = "function to write the image to disk."]
    pub fn set_write_image_hook(
        hookfn: ::std::option::Option<
            unsafe extern "C" fn(
                outfilename: *mut ::std::os::raw::c_char,
                format: ::std::os::raw::c_int,
                bitmap: *mut EYEBITMAP,
            ) -> ::std::os::raw::c_int,
        >,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_peep_input_event(
        event: *mut InputEvent,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_get_input_event(
        event: *mut InputEvent,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_peep_last_input_event(
        event: *mut InputEvent,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_flush_input_event();
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Function to initialize the gaze to href and href to gaze mapping."]
    #[doc = "This function should be called before calling \\c eyelink_href_to_gaze()"]
    #[doc = "or \\c eyelink_gaze_to_href()."]
    #[doc = "@param left Left pixel value (normally 0)."]
    #[doc = "@param top Top pixel value (normally 0)."]
    #[doc = "@param right Right pixel value (width of the display)."]
    #[doc = "@param bottom Bottom pixel value (height of the display)."]
    #[doc = "@return \\c -1 if the tracker does not support the commands,"]
    #[doc = "href_point_eye"]
    #[doc = "set_href_point"]
    pub fn eyelink_initialize_mapping(left: f32, top: f32, right: f32, bottom: f32) -> INT32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Apply href->gaze to point (xp, yp). This function requires HREFPT data in"]
    #[doc = "FSAMPLE. The function \\c eyelink_initialize_mapping() should be called"]
    #[doc = "before calling this function."]
    #[doc = "@param xp X point to apply href->gaze."]
    #[doc = "@param yp Y point to apply href->gaze."]
    #[doc = "@param sample Sample."]
    #[doc = "@return \\c 0 if OK, \\c -1 if there is a math error, \\c -2 if the tracker"]
    #[doc = "does not support this operation."]
    pub fn eyelink_href_to_gaze(xp: *mut f32, yp: *mut f32, sample: *mut FSAMPLE) -> INT32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Apply gaze->href to point (xp, yp). This function requires HREFPT data in"]
    #[doc = "FSAMPLE. The function \\c eyelink_initialize_mapping() should be called"]
    #[doc = "before calling this function."]
    #[doc = "@param xp X point to apply gaze->href."]
    #[doc = "@param yp Y point to apply gaze->href."]
    #[doc = "@param sample Sample."]
    #[doc = "@return \\c 0 if OK, \\c -1 if there is a math error, \\c -2 if the tracker"]
    #[doc = "does not support this operation."]
    pub fn eyelink_gaze_to_href(xp: *mut f32, yp: *mut f32, sample: *mut FSAMPLE) -> INT32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Convenient function to calculate the href angle."]
    #[doc = "@param x1 Point 1 x."]
    #[doc = "@param y1 Point 1 y."]
    #[doc = "@param x2 Point 2 x."]
    #[doc = "@param y2 Point 2 y."]
    pub fn eyelink_href_angle(x1: f32, y1: f32, x2: f32, y2: f32) -> f32;
}
extern "C" {
    #[doc = " @ingroup extra_data"]
    #[doc = "Convenient function to calculate the href resolution."]
    #[doc = "@param x X value of point."]
    #[doc = "@param y Y value of point."]
    #[doc = "@param xres Pointer to return the x resolution."]
    #[doc = "@param yres Pointer to return the y resolution."]
    pub fn eyelink_href_resolution(x: f32, y: f32, xres: *mut f32, yres: *mut f32);
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "\\deprecated Use eyelink_draw_cross_hair() instead."]
    #[doc = ""]
    #[doc = "Value is image coord scaled so l,t=0, r,b=8192"]
    #[doc = "Values may be negative or beyond image limits"]
    #[doc = "Value is 0x8000 in X (or L) field if crosshair is not to be drawn"]
    #[doc = "Head camera: indexes 0..3 are markers"]
    #[doc = "Eye camera:"]
    #[doc = "Index 0 is pupil center"]
    #[doc = "Index 1 is CR center"]
    #[doc = "Index 2 is pupil-limit box left, top"]
    #[doc = "Index 3 is pupil-limit box right, bottom"]
    #[doc = "@param xhairs_on Set to indicate if xhairs enabled on display (may be \\c NULL)."]
    #[doc = "@param x array of 4 to be filled to return x data"]
    #[doc = "@param y array of 4 to be filled to return y data"]
    #[doc = "@return Channel number (\\c 1 = left, \\c 2 = head, \\c 3 = right)."]
    #[doc = ""]
    #[doc = ""]
    pub fn get_image_xhair_data(
        x: *mut INT16,
        y: *mut INT16,
        xhairs_on: *mut INT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_get_extra_raw_values(
        s: *mut FSAMPLE,
        rv: *mut FSAMPLE_RAW,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eyelink_get_extra_raw_values_v2(
        s: *mut FSAMPLE,
        eye: ::std::os::raw::c_int,
        rv: *mut FSAMPLE_RAW,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup velocity_acceleration"]
    #[doc = "Calculates left x velocity, left y velocity, right x velocity and right y velocity from queue of samples."]
    #[doc = "@param[in] slen Sample model to use for velocity calculation. Acceptable models"]
    #[doc = "are \\c FIVE_SAMPLE_MODEL, \\c NINE_SAMPLE_MODEL, \\c SEVENTEEN_SAMPLE_MODEL and"]
    #[doc = "\\c EL1000_TRACKER_MODEL."]
    #[doc = "@param[out] xvel Left and right x velocity."]
    #[doc = "Expects an array of 2 elements of floats. The array is filled with left and right"]
    #[doc = "velocity values.  Upon return of this function xvel[0] contains the left x velocity"]
    #[doc = "data and xvel[1] contains right x velocity data.  If velocity cannot be calculated"]
    #[doc = "for any reason(eg. insufficient samples, no data) MISSING_DATA is filled for the given"]
    #[doc = "velocity."]
    #[doc = "@param[out] yvel Left and right y velocity."]
    #[doc = "Expects an array of 2 elements of floats. The array is filled with left and right"]
    #[doc = "velocity values.  Upon return of this function yvel[0] contains the left y velocity"]
    #[doc = "data and xvel[1] contains right y velocity data.  If velocity cannot be calculated"]
    #[doc = "for any reason(eg. insufficient samples, no data) MISSING_DATA is filled for the given"]
    #[doc = "velocity."]
    #[doc = "@param[out] vel_sample Velocity for sample."]
    #[doc = "Expects a FSAMPLE structure to fill in the sample, the velocity is calculated for."]
    #[doc = ""]
    #[doc = "\\b Example:"]
    #[doc = "<pre>"]
    #[doc = "@code"]
    #[doc = "#include <stdio.h>"]
    #[doc = "#include <core_expt.h>"]
    #[doc = ""]
    #[doc = "int main(int argc, char ** argv)"]
    #[doc = "{"]
    #[doc = "if(open_eyelink_connection(0)) // connect to tracker"]
    #[doc = "{"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "eyecmd_printf(\"link_sample_data  = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS\"); // tell the tracker to stuff the sample with"]
    #[doc = "if(start_recording(0,0,1,0)) // start recording failed."]
    #[doc = "{"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if(!eyelink_wait_for_block_start(100, 1, 0)) // wait for block start"]
    #[doc = "{"]
    #[doc = "stop_recording();"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "else"]
    #[doc = "{"]
    #[doc = "UINT32 st = current_time();"]
    #[doc = "while(current_time()-st<10000) // record for 10 seconds"]
    #[doc = "{"]
    #[doc = "FSAMPLE fs;"]
    #[doc = "float xvel[2];"]
    #[doc = "float yvel[2];"]
    #[doc = "if(check_recording()!=0)"]
    #[doc = "{"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return -4; // recording aborted."]
    #[doc = "}"]
    #[doc = "eyelink_calculate_velocity_x_y(FIVE_SAMPLE_MODEL,xvel,yvel,&fs);"]
    #[doc = "printf(\"%lu %f %f %f %f\\n\",fs.time,xvel[0],yvel[0], xvel[1], yvel[1]);"]
    #[doc = "pump_delay(100); // we check the velocity every 100 ms."]
    #[doc = "}"]
    #[doc = "stop_recording();"]
    #[doc = "close_eyelink_connection();"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</pre>"]
    pub fn eyelink_calculate_velocity_x_y(
        slen: ::std::os::raw::c_int,
        xvel: *mut f32,
        yvel: *mut f32,
        vel_sample: *mut FSAMPLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup velocity_acceleration"]
    #[doc = "Calculates overall velocity for left and right eyes separately."]
    #[doc = "@param[in] slen Sample model to use for velocity calculation. Acceptable models"]
    #[doc = "are \\c FIVE_SAMPLE_MODEL, \\c NINE_SAMPLE_MODEL, \\c SEVENTEEN_SAMPLE_MODEL and"]
    #[doc = "\\c EL1000_TRACKER_MODEL."]
    #[doc = "@param[out] vel A float array of 2 to fill in the calculated results. Upon return of this function,"]
    #[doc = "vel[0] will contain overall velocity for left eye and vel[1] will contain overall velocity"]
    #[doc = "for right eye.  If velocity cannot be calculated for any reason(eg. insufficient"]
    #[doc = "samples, no data) MISSING_DATA is filled for the given velocity."]
    #[doc = "@param[out] vel_sample Velocity for sample."]
    #[doc = "Expects a FSAMPLE structure to fill in the sample, the velocity is calculated for."]
    pub fn eyelink_calculate_velocity(
        slen: ::std::os::raw::c_int,
        vel: *mut f32,
        vel_sample: *mut FSAMPLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup velocity_acceleration"]
    #[doc = "Calculates overall velocity and acceleration for left and right eyes separately."]
    #[doc = "@param[in] slen Sample model to use for velocity calculation. Acceptable models"]
    #[doc = "are \\c FIVE_SAMPLE_MODEL, \\c NINE_SAMPLE_MODEL, \\c SEVENTEEN_SAMPLE_MODEL and"]
    #[doc = "\\c EL1000_TRACKER_MODEL."]
    #[doc = "@param[out] vel A float array of 2 to fill in the calculated velocity results. Upon return of this function,"]
    #[doc = "vel[0] will contain overall velocity for left eye and vel[1] will contain overall velocity"]
    #[doc = "for right eye.  If velocity cannot be calculated for any reason(eg. insufficient"]
    #[doc = "samples, no data) MISSING_DATA is filled for the given velocity."]
    #[doc = "@param[out] acc A float array of 2 to fill in the calculated acceleration results. Upon return of this function,"]
    #[doc = "acc[0] will contain overall acceleration for left eye and acc[1] will contain overall acceleration"]
    #[doc = "for right eye.  If acceleration cannot be calculated for any reason(eg. insufficient"]
    #[doc = "samples, no data) MISSING_DATA is filled for the given acceleration."]
    #[doc = "@param[out] vel_sample Velocity for sample."]
    #[doc = "Expects a FSAMPLE structure to fill in the sample, the velocity is calculated for."]
    pub fn eyelink_calculate_overallvelocity_and_acceleration(
        slen: ::std::os::raw::c_int,
        vel: *mut f32,
        acc: *mut f32,
        vel_sample: *mut FSAMPLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup message_file"]
    #[doc = "Very similar to eyemsg_printf, with the following features:"]
    #[doc = "\\arg Optionally write the timestamped message to file instead of sending over the link to tracker."]
    #[doc = "\\arg Optional time of event."]
    #[doc = "@param t optional time of event (0 = NOW)"]
    #[doc = "@param fmt format messages"]
    pub fn timemsg_printf(t: UINT32, fmt: *mut ::std::os::raw::c_char, ...) -> INT16;
}
extern "C" {
    #[doc = " @ingroup message_file"]
    #[doc = "Creates message file, once open call to timemsg_printf(), will not send messages to tracker."]
    #[doc = "Messages are kept in a queue if the application is in realtime mode, and written to disk on"]
    #[doc = "non real-time mode except when close_message_file() is called while in real-time mode."]
    #[doc = "@param[in] fname Message file name"]
    pub fn open_message_file(fname: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup message_file"]
    #[doc = "Flush and close message file, opened by open_message_file."]
    pub fn close_message_file();
}
#[doc = "@}"]
pub type CrossHairInfo = _CrossHairInfo;
#[doc = " @ingroup display"]
#[doc = "\\brief Structure to hold cross hair information."]
#[doc = ""]
#[doc = "Structure to hold cross hair information that are needed to"]
#[doc = "draw the cross hair on camera images."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CrossHairInfo {
    #[doc = "< for the moment this should be set to 1."]
    pub majorVersion: ::std::os::raw::c_short,
    #[doc = "< for the moment this should be set to 0."]
    pub minorVersion: ::std::os::raw::c_short,
    #[doc = "Display width of the camera image. This need not to match the"]
    #[doc = "size given at setup_image_display_hook"]
    pub w: ::std::os::raw::c_int,
    #[doc = "Display height of the camera image. This need not to match"]
    #[doc = "the size given at setup_image_display_hook"]
    pub h: ::std::os::raw::c_int,
    #[doc = "Private data used by internals of  eyelink_draw_cross_hair."]
    #[doc = "This pointer should not be touched externally"]
    pub privatedata: *mut ::std::os::raw::c_void,
    #[doc = "Attribute to hold any user data. Any data set here"]
    #[doc = "untouched by eyelink_draw_cross_hair."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = "drawLine shoud draw a line from (x1,y1) -> (x2,y2)"]
    #[doc = "with the given color"]
    #[doc = "@param[in] x1"]
    pub drawLine: ::std::option::Option<
        unsafe extern "C" fn(
            dt: *mut CrossHairInfo,
            x1: ::std::os::raw::c_int,
            y1: ::std::os::raw::c_int,
            x2: ::std::os::raw::c_int,
            y2: ::std::os::raw::c_int,
            colorindex: ::std::os::raw::c_int,
        ),
    >,
    #[doc = "drawLozenge shoud draw circle if the width and height are equal. otherwise"]
    #[doc = "find the smallest width and draw semi-circles on the longest side at both ends and connect"]
    #[doc = "the semi circles with lines."]
    pub drawLozenge: ::std::option::Option<
        unsafe extern "C" fn(
            dt: *mut CrossHairInfo,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            colorindex: ::std::os::raw::c_int,
        ),
    >,
    #[doc = "getMouseState shoud fill values for (x,y) with current mouse position and the"]
    #[doc = "state = 1 if pressed. the x and y values are respective to top left hand corner of the image"]
    pub getMouseState: ::std::option::Option<
        unsafe extern "C" fn(
            dt: *mut CrossHairInfo,
            x: *mut ::std::os::raw::c_int,
            y: *mut ::std::os::raw::c_int,
            state: *mut ::std::os::raw::c_int,
        ),
    >,
    #[doc = "< for future use"]
    pub reserved1: ::std::os::raw::c_int,
    #[doc = "< for future use"]
    pub reserved2: ::std::os::raw::c_int,
    #[doc = "< for future use"]
    pub reserved3: ::std::os::raw::c_int,
    #[doc = "< for future use"]
    pub reserved4: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__CrossHairInfo() {
    assert_eq!(
        ::std::mem::size_of::<_CrossHairInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_CrossHairInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_CrossHairInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_CrossHairInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).majorVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(majorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).minorVersion as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(minorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).privatedata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(privatedata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).userdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).drawLine as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(drawLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).drawLozenge as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(drawLozenge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).getMouseState as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(getMouseState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved3 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CrossHairInfo>())).reserved4 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CrossHairInfo),
            "::",
            stringify!(reserved4)
        )
    );
}
impl Default for _CrossHairInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @ingroup display"]
    #[doc = "Convenient function to draw cross hair on camera image. It is very tedious to draw and maintain"]
    #[doc = "cross hair drawing. This is due to evolving eyelink camera image protocol and the introduction"]
    #[doc = "of newer trackers and still single library handle all eyelink trackers.  eyelink_draw_cross_hair"]
    #[doc = "fixes this issue by allowing the drawing function to draw to the device contexts and does all"]
    #[doc = "magic of extracting cursor info from the tracker."]
    #[doc = ""]
    #[doc = "eyelink_draw_cross_hair calls drawLine(), drawEllipse() and getMouseState() to draw the cross hair."]
    #[doc = "eyelink_draw_cross_hair expects both width(w) and height(h) are correct and the function pointers to"]
    #[doc = "drawLine, drawEllipse and getMouseState are not NULL."]
    #[doc = "@param[in] chi initialized CrossHairInfo structure."]
    pub fn eyelink_draw_cross_hair(chi: *mut CrossHairInfo) -> INT32;
}
extern "C" {
    #[doc = "Returns the eyelink_core library version number."]
    #[doc = "@param[out] c fills in the version number of th eyelink_core library."]
    pub fn eyelink_dll_version(c: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Passes the colors of the display background and fixation target to the"]
    #[doc = "EXPTSPPT library.  During calibration, camera image display, and drift"]
    #[doc = "correction, the display background should match the brightness of the"]
    #[doc = "experimental stimuli as closely as possible, in order to maximize tracking"]
    #[doc = "accuracy.  This function passes the colors of the display background and"]
    #[doc = "fixation target to the EXPTSPPT library.  This also prevents flickering of"]
    #[doc = "the display at the beginning and end of drift correction."]
    #[doc = ""]
    #[doc = "@param fg Color used for drawing calibration target."]
    #[doc = "@param bg Color used for drawing calibration background."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c do_tracker_setup()"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup()"]
    pub fn set_calibration_colors(fg: *mut SDL_Color, bg: *mut SDL_Color);
}
extern "C" {
    #[doc = " The standard calibration and drift correction target is a disk (for"]
    #[doc = "peripheral delectability) with a central \"hole\" target (for accurate"]
    #[doc = "fixation).  The sizes of these features may be set with this function."]
    #[doc = ""]
    #[doc = "@param diameter Size of outer disk, in pixels."]
    #[doc = "@param holesize Size of central feature.  If \\c &lt;holesize&gt; is \\c 0,"]
    #[doc = "no central feature will be drawn."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c do_tracker_setup()"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup()"]
    pub fn set_target_size(diameter: UINT16, holesize: UINT16);
}
extern "C" {
    #[doc = " Selects the sounds to be played during \\c do_tracker_setup(), including"]
    #[doc = "calibration, validation and drift correction.  These events are the"]
    #[doc = "display or movement of the target, successful conclusion of calibration"]
    #[doc = "or good validation, and failure or interruption of calibration or validation."]
    #[doc = ""]
    #[doc = "@remarks If no sound card is installed, the sounds are produced as \"beeps\""]
    #[doc = "from the PC speaker.  Otherwise, sounds can be selected by passing a string."]
    #[doc = "If the string is \"\" (empty), the default sounds are played.  If the string"]
    #[doc = "is \"off\", no sound will be played for that event.  Otherwise, the string"]
    #[doc = "should be the name of a .WAV file to play."]
    #[doc = "@param ontarget Sets sound to play when target moves."]
    #[doc = "@param ongood Sets sound to play on successful operation."]
    #[doc = "@param onbad Sets sound to play on failure or interruption."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c do_tracker_setup()"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup() and \\c set_dcorr_sounds()"]
    pub fn set_cal_sounds(
        ontarget: *mut ::std::os::raw::c_char,
        ongood: *mut ::std::os::raw::c_char,
        onbad: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Selects the sounds to be played during \\c do_drift_correct().  These events"]
    #[doc = "are the display or movement of the target, successful conclusion of drift"]
    #[doc = "correction, and pressing the 'ESC' key to start the Setup menu."]
    #[doc = ""]
    #[doc = "@remarks If no sound card is installed, the sounds are produced as \"beeps\""]
    #[doc = "from the PC speaker.  Otherwise, sounds can be selected by passing a string."]
    #[doc = "If the string is \"\" (empty), the default sounds are played.  If the string"]
    #[doc = "is \"off\", no sound will be played for that event.  Otherwise, the string"]
    #[doc = "should be the name of a .WAV file to play."]
    #[doc = "@param ontarget Sets sound to play when target moves."]
    #[doc = "@param ongood Sets sound to play on successful operation."]
    #[doc = "@param onbad Sets sound to play on failure or interruption."]
    #[doc = ""]
    #[doc = "\\b Example: See \\c do_tracker_setup()"]
    #[doc = ""]
    #[doc = "\\sa \\c do_tracker_setup() and \\c set_cal_sounds()"]
    pub fn set_dcorr_sounds(
        ontarget: *mut ::std::os::raw::c_char,
        ongood: *mut ::std::os::raw::c_char,
        onbad: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "To adjust camera image position. By default the camera is placed at the"]
    #[doc = "centre of the screen."]
    #[doc = ""]
    #[doc = "@param left Left position."]
    #[doc = "@param top Top position."]
    #[doc = "@param right Right position."]
    #[doc = "@param bottom Bottom position."]
    pub fn set_camera_image_position(left: INT16, top: INT16, right: INT16, bottom: INT16)
        -> INT16;
}
extern "C" {
    #[doc = " Returns screen resolution in pixels and colour depth in bits per pixel of the current display mode,"]
    #[doc = "and fills the respective pointers to integer arguments accordingly."]
    #[doc = "The main purpose of this function is to obtain the current resolution of the desktop environment"]
    #[doc = "before the call to initialize the main window."]
    #[doc = "@param csw Current Screen Width in pixels."]
    #[doc = "@param csh Current Screen Height in pixels."]
    #[doc = "@param ccd Current colour depth in bits per pixel."]
    #[doc = "@return \\c 1 if success, \\c 0 if failure to detect display mode."]
    #[doc = "@remark This function utilizes GDI under Windows, Quartz under Mac OS X and SDL under Ubuntu (requires SDL1.2.10 and up)."]
    #[doc = "It may fail if none of these combinations are present."]
    #[doc = ""]
    #[doc = "Custom initialization of SDL using current display mode can be done in the following manner:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "int customGraphicsSetup()"]
    #[doc = "{"]
    #[doc = "int screen_w, screen_h, pixel_d; // screen width, height and pixel depth"]
    #[doc = "SDL_Surface *mainwindow = NULL;"]
    #[doc = "if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) // initialize SDL"]
    #[doc = "{"]
    #[doc = "printf(\"Couldn't initialize SDL: %s!\",SDL_GetError());"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "if (get_current_display_information(&screen_w, &screen_h, &pixel_d)){"]
    #[doc = "printf(\"Setting video mode to: %dx%dx%d\\n\", screen_w, screen_h, pixel_d);"]
    #[doc = "mainwindow = SDL_SetVideoMode(screen_w,screen_h,pixel_d,SDL_SWSURFACE|SDL_FULLSCREEN); // set video mode"]
    #[doc = "}else{"]
    #[doc = "printf(\"Failed to detect current video mode. Setting to default: 800x600x32\");"]
    #[doc = "mainwindow = SDL_SetVideoMode(800,600,32,SDL_SWSURFACE|SDL_FULLSCREEN); // set video mode"]
    #[doc = "}"]
    #[doc = "if(!mainwindow)"]
    #[doc = "{"]
    #[doc = "printf(\"Failed to set video mode: %s! \",SDL_GetError());"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "if(init_expt_graphics(mainwindow, NULL)) // tell core graphics to use the set video mode."]
    #[doc = "return -1;"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    pub fn get_current_display_information(
        csw: *mut ::std::os::raw::c_int,
        csh: *mut ::std::os::raw::c_int,
        ccd: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Measures parameters of the current display mode, and fills a \\c DISPLAYINFO"]
    #[doc = "structure with the data.  This process may take over 100 milliseconds, as"]
    #[doc = "it measures actual refresh rate.  The returned data can be used to compute"]
    #[doc = "sizes for drawing, and to check that the current display mode matches the"]
    #[doc = "requirements of the experiment.  A global \\c DISPLAYINFO structure called"]
    #[doc = "dispinfo should be set up at the start of the program if you wish to use"]
    #[doc = "the \\c SCRWIDTH and \\c SCRHEIGHT macros."]
    #[doc = ""]
    #[doc = "@remarks This is the contents of the \\c DISPLAYINFO structure:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "typedef struct"]
    #[doc = "{"]
    #[doc = "INT32 left;      // left of display"]
    #[doc = "INT32 top;       // top of display"]
    #[doc = "INT32 right;     // right of display"]
    #[doc = "INT32 bottom;    // bottom of display"]
    #[doc = "INT32 width;     // width of display"]
    #[doc = "INT32 height;    // height of display"]
    #[doc = "INT32 bits;      // bits per pixel"]
    #[doc = "INT32 palsize;   // total entries in palette (0 if not indexed)"]
    #[doc = "INT32 palrsvd;   // number of static entries in palette"]
    #[doc = "INT32 pages;     // pages supported"]
    #[doc = "float refresh;   // refresh rate in Hz"]
    #[doc = "INT32 winnt;     // 0 for 9x/Me, 1 for NT, 2 for 2000, 3 for XP"]
    #[doc = "} DISPLAYINFO;"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = "If refresh cannot be measured, the \"refresh\" field will contain a value less than 40."]
    #[doc = "@param di Pointer to \\c DISPLAYINFO structure to fill."]
    pub fn get_display_information(di: *mut DISPLAYINFO);
}
extern "C" {
    #[doc = " You must always create a borderless, full-screen window for your experiment."]
    #[doc = "This function registers the window with EXPTSPPT so it may be used for"]
    #[doc = "calibration and drift correction.  The window should not be destroyed until"]
    #[doc = "it is released with \\c close_expt_graphics(). This window will be subclassed"]
    #[doc = "(some messages intercepted) during calibration and drift correction."]
    #[doc = ""]
    #[doc = "@param hwnd Handle of window that is to be used for calibration and drift"]
    #[doc = "correction.  If \\c NULL is passed in, SDL initialized and"]
    #[doc = "requested display mode is set."]
    #[doc = "@param info \\c NULL or pointer to a \\c DISPLAYINFO structure to fill with"]
    #[doc = "display mode data.  If \\c NULL is passed in, current display mode is"]
    #[doc = "used."]
    #[doc = "@return \\c 0 if success, \\c -1 if error occurred internally."]
    #[doc = ""]
    #[doc = "Default initialization of eyelinkn_core_library:"]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "int defaultGraphicsSetup()"]
    #[doc = "{"]
    #[doc = "DISPLAYINFO disp;"]
    #[doc = "memset(&disp,0,sizeof(DISPLAYINFO));"]
    #[doc = ""]
    #[doc = "disp.width =640;"]
    #[doc = "disp.height = 480;"]
    #[doc = "disp.bits =32;"]
    #[doc = "disp.refresh = 60;"]
    #[doc = "if(init_expt_graphics(NULL, &disp))"]
    #[doc = "{"]
    #[doc = "printf(\"init_expt_graphics failed \\n\");"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "Custom initialization of SDL can be done in the following manner."]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "int customGraphicsSetup()"]
    #[doc = "{"]
    #[doc = "SDL_Surface *mainwindow = NULL;"]
    #[doc = "if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) // initialize SDL"]
    #[doc = "{"]
    #[doc = "printf(\"Couldn't initialize SDL: %s!\",SDL_GetError());"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "mainwindow = SDL_SetVideoMode(800,600,32,SDL_SWSURFACE|SDL_FULLSCREEN); // set video mode"]
    #[doc = "if(!mainwindow)"]
    #[doc = "{"]
    #[doc = "printf(\"Failed to set video mode: %s! \",SDL_GetError());"]
    #[doc = "return -1;"]
    #[doc = "}"]
    #[doc = "if(init_expt_graphics(mainwindow, NULL)) // tell core graphics to use the set video mode."]
    #[doc = "return -1;"]
    #[doc = "return 0;"]
    #[doc = "}"]
    #[doc = "@remark eyelink_core_graphics library does not support OPENGL."]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    pub fn init_expt_graphics(hwnd: *mut SDL_Surface, info: *mut DISPLAYINFO) -> INT16;
}
extern "C" {
    #[doc = " Call this function at the end of the experiment or before destroying the"]
    #[doc = "window registered with \\c init_expt_graphics().  This call will disable"]
    #[doc = "calibration and drift correction until a new window is registered."]
    pub fn close_expt_graphics();
}
extern "C" {
    #[doc = " This function saves the entire bitmap as a .BMP, .JPG, .PNG, or .TIF file,"]
    #[doc = "and transfers the image to tracker as backdrop for gaze cursors (See"]
    #[doc = "\\c bitmap_save() and \\c bitmap_to_backdrop() for more information)."]
    #[doc = ""]
    #[doc = "@param hbm Handle to the bitmap image."]
    #[doc = "@param xs Specifies the x-coordinate of the upper-left corner of the source"]
    #[doc = "bitmap."]
    #[doc = "@param ys Specifies the y-coordinate of the upper-left corner of the source"]
    #[doc = "bitmap."]
    #[doc = "@param width Specify the width of the source image to be copied  (set to \\c 0"]
    #[doc = "to use all)."]
    #[doc = "@param height Specify the height of the source image to be copied  (set to"]
    #[doc = "\\c 0 to use all)."]
    #[doc = "@param fname Name of the image file to be saved.  Currently, only .PNG, .BMP,"]
    #[doc = ".JPG, and .TIF files are saved."]
    #[doc = "@param path Directory or drive path in quotes (\".\" for current directory)."]
    #[doc = "@param sv_options Use \\c SV_NOREPLACE if not to replace an existing file;"]
    #[doc = "use \\c SV_MAKEPATH to create a new path."]
    #[doc = "@param xd Specifies the x-coordinate of the upper-left corner of the tracker"]
    #[doc = "screen."]
    #[doc = "@param yd Specifies the y-coordinate of the upper-left corner of the tracker"]
    #[doc = "screen."]
    #[doc = "@param bx_options Set with a bitwise OR of the following constants:"]
    #[doc = "\\c BX_MAXCONTRAST: Maximizes contrast for clearest image;"]
    #[doc = "\\c BX_AVERAGE: averages combined pixels;"]
    #[doc = "\\c BX_DARKEN: chooses darkest (keep thin dark lines);"]
    #[doc = "\\c BX_LIGHTEN: chooses darkest (keep thin white lines);"]
    #[doc = "\\c BX_NODITHER: disables dithering to get clearest text;"]
    #[doc = "\\c BX_GREYSCALE: converts to grayscale."]
    #[doc = "@return \\c 0 if successful, \\c -1 if couldn't save, \\c -2 if couldn't transfer"]
    pub fn sdl_bitmap_save_and_backdrop(
        hbm: *mut SDL_Surface,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        sv_options: INT16,
        xd: INT16,
        yd: INT16,
        bx_options: UINT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function transfers the bitmap to the tracker PC as backdrop for gaze cursors."]
    #[doc = "The field \"bx_options\", set with bitwise OR of the following constants, determines"]
    #[doc = "how bitmap is processed: \\c BX_AVERAGE (averaging combined pixels), \\c BX_DARKEN"]
    #[doc = "(choosing darkest and keep thin dark lines), and \\c BX_LIGHTEN (choosing darkest"]
    #[doc = "and keep thin white lines) control how bitmap size is reduced to fit tracker display;"]
    #[doc = "\\c BX_MAXCONTRAST maximizes contrast for clearest image; \\c BX_NODITHER disables"]
    #[doc = "the dithering of the image; \\c BX_GREYSCALE converts the image to grayscale"]
    #[doc = "(grayscale works best for EyeLink I, text, etc.)"]
    #[doc = ""]
    #[doc = "@param hbm Handle to the bitmap image."]
    #[doc = "@param xs Specifies the x-coordinate of the upper-left corner of the source bitmap."]
    #[doc = "@param ys Specifies the y-coordinate of the upper-left corner of the source bitmap."]
    #[doc = "@param width Specify the width of the source image to be copied  (set to \\c 0 to"]
    #[doc = "use all)."]
    #[doc = "@param height Specify the height of the source image to be copied  (set to \\c 0 to"]
    #[doc = "use all)."]
    #[doc = "@param xd Specifies the x-coordinate of the upper-left corner of the tracker screen."]
    #[doc = "@param yd Specifies the y-coordinate of the upper-left corner of the tracker screen."]
    #[doc = "@param bx_options Set with a bitwise OR of the following constants:"]
    #[doc = "\\c BX_MAXCONTRAST: Maximizes contrast for clearest image;"]
    #[doc = "\\c BX_AVERAGE: averages combined pixels;"]
    #[doc = "\\c BX_DARKEN: chooses darkest (keep thin dark lines);"]
    #[doc = "\\c BX_LIGHTEN: chooses darkest (keep thin white lines);"]
    #[doc = "\\c BX_NODITHER: disables dithering to get clearest text;"]
    #[doc = "\\c BX_GREYSCALE: converts to grayscale."]
    #[doc = "@return \\c 0 if successful, else \\c -1 or \\c -2"]
    pub fn sdl_bitmap_to_backdrop(
        hbm: *mut SDL_Surface,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        xd: INT16,
        yd: INT16,
        bx_options: UINT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function saves the entire bitmap or selected part of a bitmap in an image file"]
    #[doc = "(with an extension of .png, .bmp, .jpg, or .tif). It creates the specified file if"]
    #[doc = "this file does not exist.  If the file exists, it replaces the file unless"]
    #[doc = "\\c SV_NOREPLACE is specified in the field of \"sv_options\". The directory to which"]
    #[doc = "the file will be written is specified in the path field."]
    #[doc = ""]
    #[doc = "@param hbm Handle to the bitmap image."]
    #[doc = "@param xs Specifies the x-coordinate of the upper-left corner of the source bitmap."]
    #[doc = "@param ys Specifies the y-coordinate of the upper-left corner of the source bitmap."]
    #[doc = "@param width Specify the width of the source image to be copied  (set to \\c 0 to use all)."]
    #[doc = "@param height Specify the height of the source image to be copied  (set to \\c 0 to use all)."]
    #[doc = "@param fname Name of the image file to be saved.  Currently, only .PNG, .BMP, .JPG,"]
    #[doc = "and .TIF files are saved."]
    #[doc = "@param path Directory or drive path in quotes (\".\" for current directory)."]
    #[doc = "@param sv_options Use \\c SV_NOREPLACE if not to replace an existing file; use \\c SV_MAKEPATH to create a new path."]
    #[doc = "@return \\c 0 if successful, else \\c -1."]
    pub fn sdl_bitmap_save(
        hbm: *mut SDL_Surface,
        xs: INT16,
        ys: INT16,
        width: INT16,
        height: INT16,
        fname: *mut ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
        sv_options: INT16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Allow one to set arbituary target in place of circle target. Eg. a custom cursor."]
    #[doc = "@param surface"]
    pub fn set_cal_target_surface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = "Allow one to set arbituary background in place of flat background"]
    #[doc = "@param surface"]
    pub fn set_cal_background_surface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = "Removes the custom background. equivalent of calling set_cal_background_surface(NULL);"]
    pub fn reset_background_surface();
}
extern "C" {
    #[doc = " @internal"]
    pub fn disable_custombackground_on_imagemode();
}
extern "C" {
    #[doc = "Allow one to set target with animation.  The expected video can be loadable using VFW(type 1 avi) also,"]
    #[doc = "both audio and video streams must be present. The audio stream must be of pcm type."]
    #[doc = ""]
    #[doc = "@param aviname  Name of the avi to use"]
    #[doc = "@param playCount How many time to loop through the video. Specify -1 to loop indefinitely."]
    #[doc = "@options for future use."]
    pub fn set_cal_animation_target(
        aviName: *const ::std::os::raw::c_char,
        playCount: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CCDBS {
    pub userdata: *mut ::std::os::raw::c_void,
    pub buttons: [::std::os::raw::c_char; 256usize],
    pub internal: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__CCDBS() {
    assert_eq!(
        ::std::mem::size_of::<_CCDBS>(),
        272usize,
        concat!("Size of: ", stringify!(_CCDBS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CCDBS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CCDBS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CCDBS>())).userdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CCDBS),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CCDBS>())).buttons as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CCDBS),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CCDBS>())).internal as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_CCDBS),
            "::",
            stringify!(internal)
        )
    );
}
impl Default for _CCDBS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CCDBS = _CCDBS;
pub type getExButtonStates =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CCDBS) -> ::std::os::raw::c_int>;
extern "C" {
    #[doc = " Enables non keyboard devices to be used for calibration control."]
    #[doc = ""]
    #[doc = "@param[in] buttonStatesfcn   callback function reads the device and returns appropriate data."]
    #[doc = "@remark: Use EXTERNAL_DEV_NONE to disable the device."]
    #[doc = "Use EXTERNAL_DEV_CEDRUS for built-in cedrus device support."]
    #[doc = ""]
    #[doc = "@param[in] config - A character string of the config file content or config file name. Whether the  config is"]
    #[doc = "the content or a file name is determined by looking for a new line character. If there is a new line character the"]
    #[doc = "content is assumed.  To use the default config,"]
    #[doc = "set the parameter to NULL. The default config will be:"]
    #[doc = ""]
    #[doc = "<pre>"]
    #[doc = "\\code"]
    #[doc = "# User mode definition"]
    #[doc = "# [MODE n]"]
    #[doc = "# Defines a 'user' mode, where n is the mode ID"]
    #[doc = "# Valid Commands for user mode:"]
    #[doc = "#\tTEXT_LINE \"This is a line of text\""]
    #[doc = "# \tDISPLAY_IMAGE"]
    #[doc = "# \tBUTTON id button_command [command args]"]
    #[doc = "# \t\tValid BUTTON button_commands:"]
    #[doc = "# \t\t\tNO_ACTION"]
    #[doc = "#"]
    #[doc = "# \t\t\tAUTO_THRESH"]
    #[doc = "# \t\t\tPUPIL_THRESH_UP"]
    #[doc = "# \t\t\tPUPIL_THRESH_DOWN"]
    #[doc = "# \t\t\tCR_THRESH_UP"]
    #[doc = "# \t\t\tCR_THRESH_DOWN"]
    #[doc = "#"]
    #[doc = "# \t\t\tSTART_CALIBRATION"]
    #[doc = "# \t\t\tSTART_VALIDATION"]
    #[doc = "#\t\t\tSTART_DRIFT_CORRECT"]
    #[doc = "#"]
    #[doc = "# \t\t\tGOTO_MODE"]
    #[doc = "# \t\t\tEXIT"]
    #[doc = "#"]
    #[doc = "# \t\t\tNEXT_IMAGE (only makes sense when DISPLAY_IMAGE is set for mode)"]
    #[doc = "# \t\t\tPREV_IMAGE (only makes sense when DISPLAY_IMAGE is set for mode)"]
    #[doc = "#"]
    #[doc = "# Predefined modes"]
    #[doc = "# [MODE C]"]
    #[doc = "# Calibration mode"]
    #[doc = "# Valid Commands"]
    #[doc = "# \tREDO_LAST_TARGET"]
    #[doc = "# \tACCEPT_TARGET"]
    #[doc = "#"]
    #[doc = "# [MODE V]"]
    #[doc = "# Validation mode"]
    #[doc = "# Valid Commands"]
    #[doc = "# \tREDO_LAST_TARGET"]
    #[doc = "# \tACCEPT_TARGET"]
    #[doc = "#"]
    #[doc = "# [MODE D]"]
    #[doc = "# Drift Correction mode"]
    #[doc = "# Valid Commands"]
    #[doc = "# \tACCEPT_TARGET"]
    #[doc = ""]
    #[doc = "[MODE 1]"]
    #[doc = "TEXT_LINE \"EyeLink Setup:\""]
    #[doc = "TEXT_LINE \"1 -> View Camera Images\""]
    #[doc = "TEXT_LINE \"2 -> Start Calibration\""]
    #[doc = "TEXT_LINE \"3 -> Start Validation\""]
    #[doc = "TEXT_LINE \"4 -> Exit EyeLink Setup\""]
    #[doc = ""]
    #[doc = "BUTTON 1 GOTO_MODE 2"]
    #[doc = "BUTTON 2 GOTO_MODE C"]
    #[doc = "BUTTON 3 GOTO_MODE V"]
    #[doc = "BUTTON 4 EXIT"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "[MODE 2]"]
    #[doc = "TEXT_LINE \"Camera Views:\""]
    #[doc = "TEXT_LINE \"1 -> Next Camera View\""]
    #[doc = "TEXT_LINE \"2 -> Previous Camera View\""]
    #[doc = "TEXT_LINE \"3 -> Go To Pupil Threshold Adjustment Mode\""]
    #[doc = "TEXT_LINE \"4 -> Exit EyeLink Setup\""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "BUTTON 1 NEXT_IMAGE"]
    #[doc = "BUTTON 2 PREV_IMAGE"]
    #[doc = "BUTTON 3 GOTO_MODE 3"]
    #[doc = "BUTTON 4 EXIT"]
    #[doc = "DISPLAY_IMAGE TRUE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "[MODE 3]"]
    #[doc = "TEXT_LINE \"Pupil Threshold Adjustment:\""]
    #[doc = "TEXT_LINE \"1 -> Increase Threshold\""]
    #[doc = "TEXT_LINE \"2 -> Decrease Threshold\""]
    #[doc = "TEXT_LINE \"3 -> Auto Threshold\""]
    #[doc = "TEXT_LINE \"4 -> Go To CR Threshold Adjustment Mode\""]
    #[doc = ""]
    #[doc = "BUTTON 1 PUPIL_THRESH_UP"]
    #[doc = "BUTTON 2 PUPIL_THRESH_DOWN"]
    #[doc = "BUTTON 3 AUTO_THRESH"]
    #[doc = "BUTTON 4 GOTO_MODE 4"]
    #[doc = "DISPLAY_IMAGE TRUE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "[MODE 4]"]
    #[doc = "TEXT_LINE \"CR Threshold Adjustment:\""]
    #[doc = "TEXT_LINE \"1 -> Increase Threshold\""]
    #[doc = "TEXT_LINE \"2 -> Decrease Threshold\""]
    #[doc = "TEXT_LINE \"3 -> Auto Threshold\""]
    #[doc = "TEXT_LINE \"4 -> Go To EyeLink Setup Mode\""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "BUTTON 1 CR_THRESH_UP"]
    #[doc = "BUTTON 2 CR_THRESH_DOWN"]
    #[doc = "BUTTON 3 AUTO_THRESH"]
    #[doc = "BUTTON 4 GOTO_MODE 1"]
    #[doc = "DISPLAY_IMAGE TRUE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "[MODE C]"]
    #[doc = "BUTTON 1 ACCEPT_TARGET"]
    #[doc = "BUTTON 2 REDO_LAST_TARGE"]
    #[doc = "BUTTON 4 EXIT"]
    #[doc = ""]
    #[doc = "[MODE V]"]
    #[doc = "BUTTON 1 ACCEPT_TARGET"]
    #[doc = "BUTTON 2 REDO_LAST_TARGE"]
    #[doc = "BUTTON 4 EXIT"]
    #[doc = ""]
    #[doc = "[MODE D]"]
    #[doc = "BUTTON 1 ACCEPT_TARGET"]
    #[doc = "BUTTON 4 EXIT"]
    #[doc = ""]
    #[doc = "\\endcode"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = "@param[in] userData  user data to pass back in the callback."]
    #[doc = "@return 1 upon success, 0 otherwise"]
    #[doc = ""]
    #[doc = ""]
    pub fn enable_external_calibration_device(
        buttonStatesfcn: getExButtonStates,
        config: *const ::std::os::raw::c_char,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @}"]
    pub fn set_cal_font(fontPath: *const ::std::os::raw::c_char, size: ::std::os::raw::c_int);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct private_hwdata {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDL_BlitMap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct private_yuvhwfuncs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct private_yuvhwdata {
    pub _address: u8,
}
